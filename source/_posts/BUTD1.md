---
title: Tips and Tricks for Visual Question Answering
date: 2020-07-23 07:50:12
tags: [VQA, attention, CVPR, 2018]
mathjax: true
categories: VQA藏书阁
cover: /2020/07/23/BUTD1/1.png
---
[Paper Download Address](https://arxiv.org/abs/1708.02711)

这篇文章提出了一个相对简单的VQA模型，达到了SOTA的效果，文章的核心目的是分享一个成功的VQA模型的细节

model首先得到问题和图片的联合嵌入(joint embedding)，随后是针对一组候选答案的多标签分类器，这种通用方法是现在很多VQA模型的基础，模型的细节对于获得高质量的结果至关重要

同时作者在模型上采用了一些关键的技术创新，极大提高了模型的表现，作者在探索模型空间结构和超参数上进行了大量的实验，以确定每个组件的重要性

主要发现概括如下

—— 使用sigmoid输出，允许每个问题有多个正确答案，而不是一个常见的单标签softmax

—— 使用软分数作为GT目标，使得task为候选答案分数的回归，而不是传统的分类

—— 对所有非线性层使用gated tanh激活函数

—— 采用bottom-up注意力得到的图片特征，自底向上注意力提供的是特定区域的特征，而非CNN传统的网格特征图

—— 使用预先训练好的候选答案表示来初始化输出层的权重

—— 在随机梯度下降的训练过程中对训练数据采用较大的mini-batches，以及智能打乱(smart shuffling)

## Background

自[VQA奠基性论文][1]发表以来，VQA task就成为了计算机视觉领域研究者关注的焦点，因为该task是对深度视觉理解的评估，这是计算机视觉的首要任务

[1]: https://arxiv.org/abs/1505.00468

VQA任务是极具挑战性的，其需要理解文本问题，解析图像的视觉元素，并对这些模式进行推理，有时还需要借助外部知识或常识

其它类似的task还有图像字幕和视觉对话

### Datasets

数据集包含图片，human-proposed问题和GT答案，VQA-real数据集是在2015年提出VQA task的时候提出的，存在的问题是模型对于QA对的language-based priors和rote-learning成为了提高表现的过于有效的方法，这使得无法对model进行有效评价和边角，因此该数据集有了新的版本VQA v2，这个数据集中，每个问题都有两张对应图像，更重要的是，这两幅图像的选择使得每一幅图像都能得到不同的答案，这种设置显然不鼓励盲目猜测，即仅从问题推断答案，这是文章中实验的主要数据集

这篇文章中另一个用到的数据集是Visual Genome，这个数据集包含场景图形式(scene graphs)的图片注释，这构成了图像的细粒度(fine-grained)描述，它们提供了一组出现在场景中的视觉元素，物体，人)，以及它们的属性(例如颜色，外观)和它们之间的关系，与VQA v2的问题相比，这个数据集的问题有更多样化的形式和更多样化的答案。这个数据集的答案通常比较长，而VQA v2的答案只有1至3个词，文章中只用这个数据集中和VQA问题答案重叠的问题子集

### Method

VQA的主流方法包含三个步骤：

(1) 将问答视为从候选答案中选择正确答案的分类问题

因为当前VQA数据集中的问题本质上大多是可视化的，因此正确的答案只涵盖了一小组单词和短语(通常是几百到几千)

(2) 深度神经网络实现联合嵌入模型

大多数VQA模型都是基于深度神经网络实现图像和问题的联合嵌入，这两个输入分别用CNN和RNN映射成固定大小的向量表示，然后通过进一步的非线性映射将其投射到相同的语义空间，随后可以按元素顺序相乘的连接方式组合，并作为分类器的输入

(3) 示例问题/答案作为监督进行端到端(end-to-end)的训练

由于深度学习在监督学习问题上的成功，整个神经网络都是从问题、图像和它们的GT答案端到端进行训练的

因为图像和问题的输入空间维数巨大，所以产生的训练信号稀疏，因而需要大量的训练数据。

作者通过大量的一系列实验表明，在实现过程中一些关键的选择(例如，门选激活、回归输出、智能打乱等)可以显著提高相对简单的模型的性能，文章将展示如何通过一步步的选择来优化一个幼稚的实现

## Proposed model

![](0.png)

### Question embedding

首先用空格和标点将问题分解成单词，数字也被当做是单词，为了提高计算效率，问题被削减到最多14个单词，多余的单词简单地抛弃(因为实际上只有0.25%的问题长度超过了14)

每个单词都被转换成一个带有查找表的向量表示，这些向量是用预先训练好的Grove嵌入来初始化的(Global Vectors for Word Representation)，初始值中没有零向量，小于14个单词的问题末尾用零向量填充，处理的词嵌入结果为$14 \times 300$

然后将其馈入GRU，循环单元的内部状态为512维，我们采用RNN的末态，作为question embedding，在过程中，作者并没有标记开端和结尾，也没有修剪序列和标记数字，作者发现对于相同迭代次数，始终运行循环单元会更有效

### Image features

输入图片通过CNN得到大小为$K \times 2048$的向量，K是图像区域的个数，每个区域都由2048维向量来编码

这里作者给出了两种方法：一是在ImageNet上预训练的200层的ResNet，得到$14 \times 14$的feature map之后再进行平均池化，得到$7 \times 7$的feature map，二是用基于ResNet和Faster R-CNN的bottom-up attention

作者对K=36和自适应K进行评估，自适应K允许K随着图像的复杂程度变化，上限为100，VQA v2在自适应K的情况下K的平均值为60

在VQA模型的训练过程中，CNN都是预先训练并保持固定的，这样可以从输入图像中提取特征作为预处理步骤以提高效率

### Image attention

文章中的模型采用了常见的问题导向注意力机制，作者将这一阶段称为top-down attention，出于和bottom-up attention的对比

对于 $i=1 \dots K$，特征向量$v_i$和问题词嵌入串联，通过一个非线性层$f_a$和一个线性层，得到权重，和特征进行矩阵点乘

![](1.png)

超参数$w_a$通过学习得到，所有位置的注意力权重都使用softmax函数进行标准化(2)，然后用归一化值对所有位置的图像特征进行加权和求和(3)，最后得到2048维向量表示注意力图

### Multimodal fusion

特征向量v和词嵌入q通过非线性层，求Hadamard积

![](2.png)

h作为图片和问题的联合嵌入，馈入分类器

### Output classifier

从训练集中出现8次以上的所有正确答案中预先确定一组候选答案，称之为输出词汇表，共有N=3129个候选答案。作者将VQA视为一个多标签分类任务，实际上，VQA v2数据集中的每一个训练问题都与一个或多个答案相关联，每个答案的软精度为[0,1]

在训练中，有一些训练问题(约7%)在选择的输出词汇中没有正确答案，这些问题也没有被舍弃，它们通过将输出词汇表的所有候选词汇的预测分数趋近于零来提供一个有用的训练信号

多标签分类器将联合嵌入h通过一个非线性层$f_o$，然后通过一个线性映射$w_o$来预测N个候选对象的得分

![](3.png)

$\sigma$是sigmoid函数，$w_o \in R^{N*512}$是一个可学习矩阵

目标函数为

![](4.png)

i和j对应M个训练问题和N个候选答案

上述公式被证明比其他VQA模型中常用的softmax分类器更有效，首先，sigmoid输出允许优化每个问题的多个正确答案，其次使用软分数作为目标提供了比二进制目标稍微丰富的训练信号，因为它们捕获了GT注释中偶尔出现的不确定性

### Pretraining the classifier

在训练过程中，每个候选答案的合适表示形式被学习为$w_o$，作者建议使用来自两个源(source)的候选答案的先验信息来初始化$w_o$，当答案不能通过预先训练的嵌入精确匹配时，使用经过拼写检查、去掉连字符或从多词表达式中保留单个词后的最接近匹配，放入矩阵$w_o^text$

作者还使用了候选答案对应的图片中的视觉信息，用Google Images 来对每个候选答案检索10张图片，这些图片被馈入在ImageNet上预训练的ResNet-101，提取10张图的平均特征，对于每个候选答案的2048维向量按行写入矩阵$w_o^img$

这些视觉表征与通过单词嵌入获得的语言表征是互补的

![](5.png)

将先验表示$w_o^{text}$和$w_o^{img}$组合

$f_o^{text}$和$f_o^{img}$是非线性函数，h是(4)式的Hadamard积

### Nonlinear layers

上述网络中采用了多个非线性层，通常的实现方法是一个仿射变换后接一个ReLU函数，作者采用的是门控双曲正切激活函数(gated hyperbolic tangent activation)

![](6.png)

W'是可学习矩阵，b'是可学习偏移量，g作为一个门控，公式的灵感来源于GRU和LSTM，这也可以看作是Highway Network的一个特例

### Training

作者采用随机梯度下降来训练网络，选择不需要固定学习速率，并且对参数的初始化不敏感的[AdaDelta algorithm][2]

[2]:https://arxiv.org/abs/1212.5701

模型容易过拟合，所以作者通过提前停止来防止过拟合，首先训练不使用VQA v2数据集的官方验证集来进行监控，并确定产生最佳性能的epoch，然后以相同的epoch数重复训练，并使用验证集作为训练数据

同时使用Visual Genome的QA对作为额外的训练数据，只使用正确答案与根据VQA v2数据集确定的输出词汇表重叠的问题

在随机梯度下降的训练过程中，作者加强了训练实例的shuffling，以保持VQA v2对在同一mini-batches内的平衡，这些对对应相同的问题有不同的图像和答案

作者直觉上认为，这样的pair可能导致将网络参数拉向不同方向的梯度，将一个示例和它平衡的对应部分保存在同一个小批中可以使学习更加稳定，并鼓励网络识别成对实例之间的细微差别

### Implementation

除了一些用于多线程加载输入数据的Java代码外，模型完全是使用自定义深度学习库在Matlab中实现的，一个网络通常需要训练12到18个epochs，单Nvidia K40 GPU采用K-36特征大概花费12到18小时，在CPU上需花费两倍时间

## Ablative experiments

所有实验均为single network，在VQA v2和上文提到的部分Visual Genome上训练，结果采用最好的epoch，每个实验进行了三次重复，每次采用不同的随机种子，展示的结果是三次重复实验的平均值，主要的性能指标是标准的VQA准确度，此外，文章还额外做了成对的精度测量(两张不同图片的相同问题，产生两个不同的答案)，这个标准比标准的每道题得分要难得多，因为它要求对两组图像都有正确的答案，不能盲目猜测和依赖语言先验

### Training data

作者比较了在相同的小批量中保持平衡的训练数据变换与标准的、任意的随机变换，前者取得了更高的准确率，这是可以预料的，因为提出的方法的目的是学习区分平衡对

随后作者评估了抛弃那些在词汇表中没有他们的真实答案的训练问题，早期实验证明了这些例子仍然具有有用的训练信号的，在实验表格中发现，这些训练问题有非常小的好处

### Question embedding

作者采用的是预训练的300维的GloVe词嵌入，前接单层GRU处理字，作者将这个选择和一系列更简单更高级的方法对比

从零开始学习词嵌入将会降低0.87%的performance，在训练数据较少的情况下差距更大，这个实验一方面显示了利用非vqa训练数据的好处，另一方面，它表明一个足够大的VQA训练集可能会完全消除这种好处，使用较低维度的GloVe vectors(100或200)，也会降低性能 (那会不会采用400或者更多会有更好的效果还是边际效应严重递减，作者没做对应实验)

对于embedding问题，作者还做了一个实验，用于验证GloVe是否真的提取了词信息，还是因为向量在词嵌入空间的简单传播本身就是benefit。作者对GloVe vector进行了随机的shuffle，将它们与从输入字典中随机选择的单词联系起来，结果是得到了比从零开始学习的词嵌入更差的效果，得出的结论是GloVe vector确实获取了词信息

作者还尝试了在单词embeddings之后进行tanh激活，但对结果没有明显的改变，同时用更高级的方式(向后、双向或两层GRU)来替代GRU会导致性能的下降

### Image features

文章中的最佳模型使用了bottom-up attention的图像特征，通过一个faster R-CNN框架和一个底层的聚焦于特定图像区域的ResNet101获得。该方法对目标检测使用固定的阈值，因此特征数与图像内容自适应。它的最大值为100，并产生K=60的平均值。作者用K=36的固定数量的特征进行实验，性能仅略微下降，考虑到较低的实现和计算成本，这可能是一个合理的选择

在实验中作者还发现L2的规范化图像特征对于良好的性能至关重要

### Image attention

参考模型使用单一的K个注意权值集合，使用softmax进行归一化，之前的一些研究报告称，使用多组注意力权重会有更好的表现，作者的实验表明他们都是瞎说的

### Output vocabulary

作者将在训练集中出现超过L次的答案加入词汇表，经过测试L的最佳值大概在8到12之间，对应词数量在2400到3800之间，较高的L仍可以通过较低的参数数量和计算复杂度提供合理的性能

### Output classifier

作者采用softmax输出和软分数作为GT目标

![](7.png)

上表显示了软分数明显表现得更好

随后作者比较了使用sigmoid和使用常见的softmax输出，均采用交叉熵损失，softmax使用数据集中提供的单一GT答案，而sigmoid使用完整的注释数据，由于多个注释者之间的分歧，有时会为一个问题标记多个正确答案，sigmoid表现显著优于softmax

然后作者对$w_o^{text}$和$w_o^{img}$的预训练进行评估，考虑两种baseline：随机初始化和随机shuffle，作者提出的方法优于这两种baseline

作者将每个答案的召回率定义为

![](8.png)

M是问题数量，s是GT分数，$\hat{s}$是预测分数

注意到作者文中提出的方法虽然有总体上的好处，但是对很多答案的召回率会产生负面影响

### General architecture

所有的非线性层都采用了gated tanh，结果优于gated ReLU，且显著优于simple ReLU和tanh，作者还尝试过highway，residual，gating的其它组合，但是没有得到更好的效果，门控层的一个好处是，在不增加隐藏状态维数的情况下，学习参数的数量翻倍

作者对隐藏层的维度进行试验，得到512是最佳的

最后图像表示和问题表示的融合采用矩阵元素点乘的方式，实验证明这种方法比矩阵连接方式要好，但是作者没有对其它高级的特征融合方式进行测试

### Minibatch size

mini-batches的大小对模型的表现有很大的影响，{128; 256; 384; 512; 768}比其它更小的minibatch值要更好一些，虽然他们需要显着更多的内存和高端gpu

### Training set size

作者在四个模型上实验了训练效果和训练数据量的关系

四个模型如下：

(1) 作者的最佳模型

(2) 用从零开始学习的词嵌入代替GloVe vectors

(3) 分类器从零开始学习而非预训练两个w矩阵

(4) 结合(2)和(3)

不出所料，性能会随着训练数据量的增加而单调地提高，并且呈对数趋势

![](9.png)

作者发现只要10%的训练数据就能获得不错的性能，对整个数据集进行训练所获得的增益相对于10倍的数据增长显得很小，这种情况在数据遵循Zipf 法则的自然语言问题和其它均有长尾分布的问题中很常见，少数的样本足够学到最常见的情况，但是要覆盖罕见数据，则需要的数据数量则指数级增长

采用额外的数据来预训练词嵌入和分类器总是有利的，随着训练数据的增多，从零开始的baseline模型之间的差距会逐渐减少

预先训练的单词嵌入和预先训练的分类器都提供了相同量级的提升，且这两种技术是互补的，通过结合它们可以获得最佳性能

### Ensembling

为了获得更好的性能，作者采用了将多个网络集成在一起的尝试，集成采用的是最简单的方式，训练同一个模型的多个实例，采用不同的初始化随机种子，这影响了学习参数的初始化和梯度下降的优化，在测试的时候，将所有实例得到的分数汇总，取最高分

性能随着网络实例数量的增加而单调增加，作者通过30个网络获得了最终的最佳结果。多个实例的训练是独立的，在多个cpu或gpu上具有明显的并行性。作者发现，即使是2-5个实例的小集合也可以在单个网络上显著提高性能

![](10.png)











