---
title: BarcodeTree：多层次结构的可伸缩比较
date: 2020-11-26 10:12:51
tags: [VIS, 2019, comparison, TVCG, 树可视化, InfoVis]
categories: 可视化胭脂铺
cover: /2020/11/26/barcodeTree/1.png
---

{% tip bell %}
IEEE引用格式：G. Li et al., “BarcodeTree: Scalable Comparison of Multiple Hierarchies,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 1, pp. 1022–1032, 2020, doi: 10.1109/TVCG.2019.2934535.
{% endtip %}

## 摘要

本文提出了一种新的可视化技术BarcodeTree(BCT)，用于比较多棵树的拓扑结构和节点属性值。BCT可以同时提供100个浅层且稳定的树的概览，而不需要聚合单个节点。每个BCT使用类似于条形码的样式在单行中显示，允许树垂直堆叠，匹配节点水平排列，以方便比较并保持空间效率。作者设计了一些视觉线索和交互技术来帮助用户理解树的拓扑结构和比较树。在两种BCT与icicle plots的比较实验中，结果表明BCT降低了不同树之间的垂直距离，使树之间的比较更加直观。本文还提供了两个案例研究，涉及数百棵树的数据集，以演示BCT的效用。

## 文章简介

数据集有时由许多相似的树(不同地方的图书馆)或随着时间变化的单个树组成(一个网站的网站地图)，这种树集合的可视化概述可以极大地帮助执行比较，识别存在或者不存在的节点或子树，亦或是查找趋势和异常值

之前的许多文献都是单树可视化，少有树的可视化比较，大多局限于一次可视化两棵树，也有同时展示三棵树或者更多树的可视化，但是结果显示不超过40棵树，随着各种数据源的不断增长，越来越需要可视化更多的树

本文提出了BarcodeTree(BCT)，用于跨多棵树对拓扑结构和节点属性值进行可伸缩的比较，BCT将每棵树线性化为单行，垂直压缩可视化，便于多棵树的堆叠和匹配节点的对齐，减少了匹配节点之间的距离，本文研究了两种变种，BCTw(宽度编码)和BCTh(高度编码)，它们分别将节点深度编码为矩形的宽度或高度，及节点属性可以用颜色编码，或者(在BCTw的情况下)用矩形的高度编码。为了帮助用户理解拓扑结构，作者还设计了“结构提示”来突出显示光标下节点的后代、祖先和兄弟节点。

![](1.png)

BCTs的设计是通过使用相对较浅和稳定的树数据集来实现的。所谓“稳定”，指的是有一个预定义的通用树，它是数据集中所有树的超级树，树之间的区别在于它们可能包含超级树中不同的节点子集和属性，每个节点上的值可能会改变。举一些这种树的数据集的例子：

1. 一个大学图书馆的多日日常节约记录，书遵循预先定义的分类系统
2. 多个图书馆的藏书
3. 不同政府或者同一政府多个部分的长期预算
4. 电子商务网站产品分类层次随时间增长的层次结构

作者将两种BCT和[icicle plots](https://scihubtw.tw/10.2307/2685881)以及[Indented Pixel Tree Plots (IPTP)](https://scihubtw.tw/10.1007/978-3-642-17289-2_33)进行研究比较，在所有研究任务中，花在IPTP上的时间都比icicle plots多，然后进行对照实验，比较BCTw、BCTh和icicle plots，发现BCTs在需要理解单个树拓扑的任务上花费的时间明显更多，而在比较多棵树的任务上花费的时间明显更少

本文的贡献有：

1. BarcodeTree，一种新颖的可视化技术，用于比较多个浅层和稳定树的拓扑结构和节点属性值，可以容纳100棵树，每棵树有数百个节点(但扇出度较小)，在正常屏幕尺寸范围内
2. 视觉反馈(“结构线索”)帮助用户理解拓扑结构
3. 一个RCT表明，BCTs可以使树比较任务比与之竞争的可视化技术更容易
4. 两个涉及图书馆图书数据集的用例来演示BCTs的效用

## 相关工作

### 单树可视化

根据父节点-子节点关系的可视化编码，可以将树可视化分为显式和隐式技术，显式技术用可见的边，线段或弧对这些关系进行编码，隐式技术使用包含(例如，子节点嵌套或封闭在父节点内)或邻接

大多数显式的树形可视化在2D或3D空间中排列分层数据，而在1D空间中排列节点的研究还不够。[Thread Arc](https://scihubtw.tw/10.1109/infvis.2003.1249028)按照时间顺序将树中的节点沿1D行排列，并在节点之间使用圆弧来编码父子关系。然而，在线弧中使用的弧使它很难压缩布局成一个薄条状，这将最终导致堆叠许多树在一起。相反，BCT不使用显式的视觉元素编码父子关系，这增加了堆叠多棵树的空间效率

在隐式树可视化中，包含编码的一个突出示例是[treemap](https://scihubtw.tw/10.1109/visual.1991.175815)，子节点在父节点体内安营扎寨，通过大小来显示节点属性值，而非叶节点的属性值通常是其子节点的和。相比之下，BCTs允许节点的属性值独立于其子节点的值。树状图通常排列为2D或3D。[ArcTree](https://innovis.cpsc.ucalgary.ca/innovis/uploads/Publications/Publications/Neumann_2005_AVR.pdf)将分层数据线性化，并将节点排列在单行中，这可以看作是一个“一维”树图

邻接编码，比如冰柱图(icicle plots)，是显式编码和包含编码之间的折中，与显式编码相比，使用邻接不显示节点之间的显式边缘，从而节省了空间，与树状图等包含编码相比，使用邻接并不那么节省空间，但使树的不同层次更容易区分，冰柱图显示了垂直邻接的父子关系:子节点位于父节点之下。树的每一层都是一行，而整棵树占据几行。虽然可以将多个冰柱图垂直堆叠起来进行树的比较，但BCTs比冰柱图需要更少的垂直空间。这样BCTs就减少了不同树的匹配节点之间的距离。

BCTs可以理解为另一种邻接编码。它以深度优先遍历的顺序将树的节点映射到双杠上。每个父节点既不包含子节点，也没有到子节点的显式链接，但是用户仍然可以识别底层的拓扑结构。这类似于缩进轮廓的布局(在许多文件浏览器中使用)和缩进像素树图(IPTP)，这两种布局都按照深度优先遍历的顺序定位节点。缩进大纲布局很适合显示带有文本标签的节点。为了使用户能够阅读这些文本标签，缩进大纲总是将节点垂直排列而不是水平排列。如果从节点中删除文本标签，压缩并旋转90度，就可以得到一个类似于BCTh的布局，使其适合将多个树堆叠在一起。IPTP为树的每一层分配单独的行，就像icicle plots一样，因此这两种布局的垂直压缩程度都不如BCTs

### 树的可视化比较

比较是数据分析中必不可少的一项工作。有一系列技术可以用于可视化地比较树，本文将其细分为:并置(juxtaposition)、合并视图(merged views)和原子(atomic representations)表示。

并置是最普遍的策略，可以在空间或时间上进行。空间并置可以通过节点-链接表示，径向表示法和树状图来实现。这种并排视图可以通过刷屏、链接和动态查询来利用交互，交互式地突出显示其他树的相应节点。但是，如果没有交互，就很难理解许多节点突出显示的差异，这使得它无法向用户提供跨多颗树的许多更改的概览。此外，因为以前工作中的表示没有像BCTs中那样垂直压缩(也就是说，它们没有压缩)，这些先前的技术无法扩展树的数量。之前的作品也将冰柱图并列比较。其中一些将两个冰柱图邻接排列，并用边连接匹配的叶节点。通过镜像冰柱图，代码流允许用户比较两棵以上的树。明确绘制的链接提供了拓扑结构差异的概述，但也占用了很大的空间，再次阻止了该技术一次容纳数量超过“少量的树”。[Taxonaut](https://scihubtw.tw/10.3897/bdj.4.e9787)将多个缩进轮廓水平并置，并使用联合树对它们进行对齐，但它的可伸缩性仍然不尽如人意，因为每个缩进的大纲需要占用几列。一些研究使用弯曲波段在树中连接匹配节点，但代价是将单个节点“模糊在一起”。时间并置，例如[时间树](https://wenku.baidu.com/view/e0f076d86f1aff00bed51ee0.html)，使用动画在不同的树之间转换，这种策略也不能很好地适用于大量的树木。用户记住帧之间变化的能力有限，因此必须多次查看动画

之前的一些作品建议将多棵树合并到一个单一的视觉表现中，以提高空间效率。[Beck et al](https://scihubtw.tw/10.1145/1879211.1879238)提出了一种依赖结构矩阵，该矩阵沿邻接矩阵的每边排列一个冰柱图，矩阵中的每个单元编码节点的差异。这种方法一次只能容纳两棵树，矩阵只显示叶子节点比较的结果。[Graham et al](https://scihubtw.tw/10.1109/tvcg.2007.70556)通过将一些树合并成一个有向无环图(DAG)表示来探索这些树。与联合树相比，DAG允许显示一个节点的多个祖先路径。合并的视图需要显示多个树之间的差异。然而，多个树的关系是复杂的，尤其是在处理大量树时，而且在一个合并视图中显示这些结果也很困难

对于数量足够大的树，有限的屏幕空间无法显示所有树的全部细节，因此开发了将树可视化为原子表示的技术。之前的工作将每棵树可视化为散点图中的单个点，以支持对大量树的比较。两点之间的距离表示关联树之间的相似程度。[TreeEvo](https://scihubtw.tw/10.1109/tvcg.2017.2744080)主要关注家谱的结构异质性。它使用像素线可视化每个家族树，并将它们分组到Sankey图的节点中。关系的显式表示只显示来自高级概述的比较结果，但不能提供拓扑结构和节点属性值的详细比较。

尽管之前在树的比较方面做了大量的工作，但据我们所知，之前的方法还不能同时完整地显示100棵树，即在一个典型的PC屏幕上同时显示所有单个节点、拓扑结构和节点属性值。这是BCT的一个独特的特点

## 需求分析

本文寻求一种技术来比较多个浅层和稳定的树，这种技术比以前的技术更具可扩展性。首先考虑以前关于树比较的文献，以确定支持哪些任务。[Guerra-G’omez et al](http://www.cs.umd.edu/hcil/trs/2012-14/2012-14.pdf)确定了五种树形比较

1. 比较节点没有属性值时的拓扑差异
2. 比较拓扑结构没有变化的叶节点的属性值
3. 比较拓扑结构没有变化的所有节点的属性值
4. 比较叶节点的属性值与拓扑结构的变化
5. 比较拓扑变化时所有节点的属性值

Munzner等人指出，结构比较是通过将一棵树上的每个节点与另一棵树上对应的节点相关联来实现的，除了比较任务，Chi等人还为多树探索确定了全局和局部任务，全局任务指的是比较多个树以发现趋势/模式。本地任务指查找有关拓扑或节点属性的特定信息。本文设法支持上述所有类型的任务。可以考虑的一些与树相关的附加任务是编辑树的方法(例如，移动节点或子树)，但是这样的编辑任务超出了本文的范围，因为本文寻求可视化数据

因此，本文对新布局的需求来自三个主要需求。为了支持Guerra-G’omez的五个任务，需要一种技术，以一种能够实现高效比较的方式显示拓扑和节点属性，为了支持全局任务，该技术应该显示尽可能多的树，同时还应该显示每棵树中尽可能多的单个节点。为支持本地任务提供每个树的拓扑结构的清晰描述也是可取的。然而，与容纳许多树和许多节点相比，清晰的拓扑结构不那么重要。这是因为用户总是可以从使用新布局的许多树的概览开始，比较多个树并发现趋势或异常值，然后再向下钻取到一个或几个树，这些树使用更传统的布局来更清楚地显示拓扑。

以下是本文具体的设计要求。R1和R2解决全局任务的需要，R3和R4支持Guerra-G’omez等人确定的五种比较，R5支持本地任务

{% folding, R1：在一个屏幕中显示许多树 %}

在一个典型的显示空间中提供概述对于比较多个树是非常重要的，这也是树比较的许多使用场景的需求之一

{% endfolding %}

{% folding cyan, R2：表示每棵树中的多个节点 %}

可视化应该显示每个树中的单个节点。在用户仍在查看多树数据集的概述时提供这种细粒度的信息，减少了用户向下钻取更详细视图的需要

{% endfolding %}

{% folding green, R3：为每个节点显示一个定量属性 %}

对每个节点的属性值进行编码，以便能够跨树比较节点值，从而揭示趋势和异常值。

{% endfolding %}

{% folding yellow, R4：便于在许多树中比较节点的存在/不存在或属性值 %}

在多棵树中找到匹配的节点、比较它们的属性值以及比较不同树中节点的存在与否应该很容易

{% endfolding %}

{% folding red, R5：显示每棵树中的拓扑(父-子)关系  %} 

它应该有可能辨别树数据的拓扑结构。最后列出这一要求是为了表明，如果为了提高空间效率而牺牲一些对父子关系清晰度的牺牲是可以接受的(R1,R2)

{% endfolding %}

## BarcodeTree设计

根据以上的设计要求，本文提出了BarcodeTree，BCT是一种比较多棵树之间拓扑结构和节点属性值的树形可视化方法。在本节中，将介绍BCT的可视化设计，然后提出交互技术来帮助用户理解底层的层次数据

### 视觉编码设计

为了实现树和节点数量的可扩展性，作者研究了多棵树到垂直和水平位置的映射拓扑。具体来说，BCT将每棵树可视化在单行中，以最小化其垂直范围，从而最大限度地增加可以垂直堆叠的树的数量(R1)，BCT还在每行中水平地打包节点。父子关系以一种节省空间的方式编码到相对位置，以最大化可以水平打包的节点数量(R2)

BCT将每个节点表示为一个矩形，可以非常有效地呈现，这意味着可以以交互帧速率呈现大量节点(R1，R2)，矩形的视觉通道(宽度，高度，颜色)可以编码节点深度和节点属性值(R3)，将节点深度映射到矩形宽度产生BCTw。具体来说，根节点的宽度最大，深度越深的节点的宽度越小。BCTw中相邻节点的宽度差是相同的。将节点深度映射到矩形高度会产生BCTh，这使得用户更容易地感知每个节点的深度。在大量树的可视化结果中，每个节点只占用很小的空间以适应屏幕空间。具体来说，每个节点的宽度和高度都很小。较小的长度可以编码节点深度，因为目标层次化数据相对较浅。然而，节点属性值具有较高的动态范围。因此节点属性值只能编码为节点颜色，而不受节点大小的限制。将节点属性值编码到颜色通道中无法支持精确的比较。其余视觉通道(高度BCTw和宽度的BCTh)在某些情况下可以重复编码属性值作为补充。但是，将属性值编码到BCTh的节点宽度中，会导致对齐后节点之间的间隙增大，从而降低空间利用效率。因此，这种设计被排除。

BCTs使用预先排序的深度优先遍历来确定水平节点的位置，它对父-子关系进行编码。根据第一次遍历时间的顺序，将层次结构中的节点从左到右添加到布局中。每个节点的后代被放置在节点的右侧。用户可以通过扫描N的右侧找到节点N的后代，直到遇到与N宽度或高度相同的另一个节点，这取决于使用的BCT的变体。因此，BCT允许用户解释树的拓扑结构(R5)，由于它的紧凑性，BCT可以嵌入到单行文本中，就像火花线一样。例如，{% inlineimage /2020/11/26/barcodeTree/2.png %}表示具有11个节点和4个级别的树。

### 交互设计

为了帮助用户理解和导航分层数据，本文为BCTs设计了三种交互技术。下面以BCTw作为一个例子来说明交互技术和这些设计也可以应用到BCTh

**结构线索突出**，尽管用户可以分辨出BCTs中的拓扑，但这个过程可能很繁琐，需要用户顺序地扫描节点。为了帮助理解(R5)，本文添加了交互式结构线索。下图显示了如何使用下划线或标记来表示光标下节点的祖先、子节点和兄弟节点

![](3.png)

为了表示后代，首先使用单个水平笔画(图a)。然而，发现分析人员仍然难以理解后代的特征，如子树的数量或平衡。因此，团队开发了图b中的变体，其中每个子树都用单独的水平笔画表示。笔画的数量和长度表示子树的数量和大小，便于判断树是否平衡

**压缩与对角线条纹符号**，对于具有数万个节点的树，BCTs表示可能非常宽，很难在屏幕中容纳。在探索大型层次数据时，用户通常只对少数子树感兴趣，其他部分会分散他们的注意力。如果几个感兴趣的子树不能在相同的屏幕空间中显示，用户需要水平地来回滚动以在这些子树之间导航。为了方便这种探索，用户可以选择感兴趣的子树，然后将每个连续的无兴趣区域聚合为对角条纹符号

![](4.png)

**折叠/展开节点**，当一个分支中的节点不能在屏幕中显示时，它将阻碍用户的导航。本文提供了折叠/扩展交互，以最大限度地利用BCT可视化表示进行交互可视化，图中显示随着用户细化他们感兴趣的焦点而逐步打开分支的情况。压缩分支用等腰三角形预览。预览图标在压缩分支的根节点下面

![](5.png)

三角形符号的视觉编码类似于Space-树，三角形底的宽度编码为平均宽度(项目数除以深度)。高度编码子树的深度。暗度编码子树的节点总数。即使是折叠的子树，用户仍然可以从三角形符号中获得概览信息，甚至可以对整个子树进行粗略的比较。单击节点可以打开折叠的分支

### 对齐比较法

为了比较多棵树之间的拓扑结构和节点属性值，本文提出了一种包含两个步骤的比对方法。第一步是垂直地并置多个树，第二步是水平地对齐BCTs。还介绍了对齐结果和排序交互的可视化编码

**水平对齐**，本文的方法对多个树进行对齐，并将匹配节点映射到相同的水平位置，以帮助用户比较它们的拓扑结构(R4)。本文的对齐方法构造了一个联合树，将多棵树合并成一棵树(见下图算法)，然后用BCT对并集树进行可视化，得到并集BCT，并将每棵树中的节点映射到它们在并集BCT中的匹配节点的位置。并联BCT作为节点的一种超集，由多个节点组成。构造union BCT是一个自顶向下的递归过程。每次迭代合并所有匹配的子节点(及其子树)，然后追加未匹配的子节点。映射策略确定每个节点的位置，允许在垂直叠加多棵树后将匹配节点放置在同一水平位置

![](6.png)

由于对齐结果将多棵树的节点合并，因此对齐结果的宽度大于单个BCT。本文方法支持交互式地对齐一个节点子集，并将其他节点按原始BCT顺序排列，这减少了比较结果的宽度。本文方法提供了两种对齐策略，即对齐感兴趣的子树和将树对齐到某个级别


{% tip bolt %}未完待续{% endtip %}

{% btns rounded grid5 %}

{% cell 演示地址, http://vis.pku.edu.cn/graphvis/en/barcodetree/index.html, fab fa-apple %}

{% cell 论文地址, http://vis.pku.edu.cn/research/publication/infovis19_barcodetree.pdf, fas fa-book-open %}

{% endbtns %}