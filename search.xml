<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React基础速通计划：React Hooks</title>
      <link href="2022/06/26/reactHooks/"/>
      <url>2022/06/26/reactHooks/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要有Hook"><a href="#为什么要有Hook" class="headerlink" title="为什么要有Hook"></a>为什么要有Hook</h2><p>本质：让函数组件可以拥有状态</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入useState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 2.调用useState，设置初始值（此处是初始值0）</span></span><br><span class="line"><span class="comment">// 3.从useState返回值中拿到状态和修改状态的方法</span></span><br><span class="line"><span class="comment">// 返回值为一个数组，包含状态和状态修改方法</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="comment">// 4.使用状态和状态修改方法</span></span><br><span class="line">    &lt;button</span><br><span class="line">      onClick=&#123;<span class="function">() =&gt;</span> &#123; setCount(count + <span class="number">1</span>) &#125;&#125;</span><br><span class="line">    &gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ol><li>在修改状态时，一定要用新值代替旧值而不是直接修改，尤其是引用类型</li><li>useState函数多次执行相互独立，每次调用为函数组件提供一个状态</li><li>useState不能嵌套在for/if/其他函数中，因为react按照hook调用顺序识别每个hook</li></ol></div><h3 id="回调函数作为状态参数"><a href="#回调函数作为状态参数" class="headerlink" title="回调函数作为状态参数"></a>回调函数作为状态参数</h3><p>回调函数return出去的值将作为初始值，只在渲染组件时执行该回调函数</p><p>这样可以根据传参提供不同的初始值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> props.count</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      onClick=&#123;<span class="function">() =&gt;</span> &#123; setCount(count + <span class="number">1</span>) &#125;&#125;</span><br><span class="line">    &gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Counter count=&#123;<span class="number">10</span>&#125; /&gt;</span><br><span class="line">      &lt;Counter count=&#123;<span class="number">20</span>&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>为react函数提供副作用处理 （主作用指根据数据渲染UI，其余都属于副作用，常见副作用有手动修改dom，数据请求，localstorage修改等）</p><h3 id="基础使用-1"><a href="#基础使用-1" class="headerlink" title="基础使用"></a>基础使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入useEffect</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dom修改操作</span></span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前点击了<span class="subst">$&#123;count&#125;</span>次`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      onClick=&#123;<span class="function">() =&gt;</span> &#123; setCount(count + <span class="number">1</span>) &#125;&#125;</span><br><span class="line">    &gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="useEffect依赖项"><a href="#useEffect依赖项" class="headerlink" title="useEffect依赖项"></a>useEffect依赖项</h3><p>基础使用中是不添加依赖项的情况，在组件初始渲染和任何状态改变导致的组件更新时都会执行</p><p>当我们添加空数组的时候，表示只在初始渲染的时候执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前点击了<span class="subst">$&#123;count&#125;</span>次`</span></span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      onClick=&#123;<span class="function">() =&gt;</span> &#123; setCount(count + <span class="number">1</span>) &#125;&#125;</span><br><span class="line">    &gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>当我们在数组中添加依赖项时，只有依赖项改变才会执行useEffect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`当前点击了<span class="subst">$&#123;count&#125;</span>次`</span></span><br><span class="line">&#125;, [count])</span><br></pre></td></tr></table></figure><h3 id="useEffect清理副作用"><a href="#useEffect清理副作用" class="headerlink" title="useEffect清理副作用"></a>useEffect清理副作用</h3><p>有时候useEffect中的副作用操作是需要被清理的，比如计时器操作，如下代码所示，如果没有副作用清理操作，当组件被删除的时候计时器仍在运行，可以在console中看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;计时器运行中&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setFlag(<span class="literal">false</span>)&#125;&gt;<span class="keyword">delete</span>&lt;/button&gt;</span><br><span class="line">      &#123;flag ? <span class="xml"><span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>useEffect清理副作用的操作流程一般如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;               </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     此处为副作用操作</span></span><br><span class="line"><span class="comment">  */</span>   </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;                          </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       在这里写清理副作用的代码        </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于之前的计时器代码的清理副作用操作如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;计时器运行中&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(timeId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [flag, setFlag] = useState(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setFlag(<span class="literal">false</span>)&#125;&gt;<span class="keyword">delete</span>&lt;/button&gt;</span><br><span class="line">      &#123;flag ? <span class="xml"><span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>用于获取绑定dom对象或是组件对象</p><h3 id="获取dom"><a href="#获取dom" class="headerlink" title="获取dom"></a>获取dom</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入useRef</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2.使用useRef传入null，返回值是一个对象，current属性存放拿到的dom对象</span></span><br><span class="line">  <span class="keyword">const</span> testRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(testRef)</span><br><span class="line">  &#125;, [testRef])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;<span class="comment">/* 3.用ref来绑定dom*/</span>&#125;</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 ref=&#123;testRef&#125;&gt;hello world&lt;/h1&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="获取组件"><a href="#获取组件" class="headerlink" title="获取组件"></a>获取组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foo.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Foo</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./Foo&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> h1Foo = useRef(<span class="literal">null</span>)  </span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(h1Foo)  </span><br><span class="line">    &#125;, [])  </span><br><span class="line">    <span class="keyword">return</span> (    </span><br><span class="line">        &lt;div&gt; <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">h1Foo</span> &#125; /&gt;</span></span>&lt;/div&gt;  </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入context</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 2.创建context对象</span></span><br><span class="line"><span class="keyword">const</span> Context = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Foo <span class="tag">&lt;<span class="name">Bar</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 4.底层组件通过useContext取出内容</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name, list &#125; = useContext(Context)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Bar &#123;name&#125; &#123;list&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;this is name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> value = &#123;</span><br><span class="line">  name,</span><br><span class="line">  list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.顶层组件用Provider包裹根元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;value&#125;&gt;</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span></span>&lt;/div&gt;</span><br><span class="line">    &lt;/Context.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础速通计划：React组件</title>
      <link href="2022/06/19/reactComponent/"/>
      <url>2022/06/19/reactComponent/</url>
      
        <content type="html"><![CDATA[<p>昨天搬家搬了一天，今天继续 b 站 react 学习计划</p><div class="note orange no-icon flat"><div class="site-card-group"><a class="site-card" href="https://www.bilibili.com/video/BV1Z44y1K7Fj?spm_id_from=333.337.search-card.all.click&vd_source=beaf1e6a6aabc6fe578a4976a22a4d85"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bilibili.png"/></div><div class="info"><span class="title">React入门到实战2022</span></div></a></div></div><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>数据和方法的简单封装</p><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&quot;<span class="attr">red</span>&quot;&#125;&#125;&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Hello&gt;&lt;/Hello&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>一些说明：</p><div class="note warning no-icon flat"><ol><li>组件首字母大写：react 判断组件和普通 html 标签的依据</li><li>函数组件必须有返回值，无需渲染则返回 null</li><li>函数名为组件标签名，可成对也可自闭合</li></ol></div><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Hello /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>一些说明：</p><div class="note warning no-icon flat"><ol><li>同函数组件，类组件必须大写字母开头</li><li>类组件继承自 React.Component 父类</li><li>类组件必须提供 render 方法，并必须有返回值</li></ol></div><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>on+事件名称 = {事件处理程序}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;clickHandler&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类组件（标准写法，避免this的指向问题）</span></span><br><span class="line"><span class="comment">// 这样的写法能够使得回调函数中this指向当前组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickHandler&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件对象-e-的使用"><a href="#事件对象-e-的使用" class="headerlink" title="事件对象 e 的使用"></a>事件对象 e 的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clickHandler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 阻止默认行为(链接跳转)</span></span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.clickHandler&#125;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外参数传递"><a href="#额外参数传递" class="headerlink" title="额外参数传递"></a>额外参数传递</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递额外参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clickHandler = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.clickHandler(&#x27;Hello World&#x27;)&#125;&gt;百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同时需要事件对象e和传递额外参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  clickHandler = <span class="function">(<span class="params">e, msg</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.clickHandler(e, &#x27;Hello World&#x27;)&#125;&gt;百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h3><div class="note orange no-icon flat"><p>在 react hook 出现前，函数组件是没有状态的</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">// 1.定义状态</span></span><br><span class="line">    name: <span class="string">&#x27;current name&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 事件回调函数</span></span><br><span class="line">  changeName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 3.状态修改</span></span><br><span class="line">    <span class="comment">// 不能直接赋值修改，必须通过setState，这个方法是继承得到的</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="string">&#x27;name was changed&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 2.使用状态</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        <span class="built_in">this</span> is TestComponent</span><br><span class="line">        当前名字为&#123;<span class="built_in">this</span>.state.name&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.changeName&#125;&gt;change&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类组件修改-counter"><a href="#类组件修改-counter" class="headerlink" title="类组件修改 counter"></a>类组件修改 counter</h3><p>咱直接在上一段代码中修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">// 1.定义状态</span></span><br><span class="line">    name: <span class="string">&#x27;current name&#x27;</span>,</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 事件回调函数</span></span><br><span class="line">  changeName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 3.状态修改</span></span><br><span class="line">    <span class="comment">// 不能直接赋值修改，必须通过setState</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="built_in">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">      name: <span class="string">`name was changed <span class="subst">$&#123;<span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 2.使用状态</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        <span class="built_in">this</span> is TestComponent</span><br><span class="line">        当前名字为&#123;<span class="built_in">this</span>.state.name&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.changeName&#125;&gt;change&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-指向相关问题"><a href="#this-指向相关问题" class="headerlink" title="this 指向相关问题"></a>this 指向相关问题</h3><p>如果在组件中并不使用箭头函数，而是直接使用函数的话，会出现 this 的指向问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handler&#125;&gt;click to test&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码会出现 this 输出为 undefine 的问题</p><p>如果一定要采用非箭头函数的写法，有以下修正方式</p><div class="note warning no-icon flat"><ol><li>constructor 修正</li><li>箭头函数调用</li></ol></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：constructor修正</span></span><br><span class="line"><span class="comment">// 使用bind来修正this</span></span><br><span class="line"><span class="comment">// 相当于在组件初始化阶段将this永远指向组件的实例对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.handler = <span class="built_in">this</span>.handler.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  handler () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handler&#125;&gt;click to test&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二：箭头函数调用</span></span><br><span class="line"><span class="comment">// 通过箭头函数的写法，直接沿用父函数中的this指向</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handler () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 此处箭头函数的父级函数为render</span></span><br><span class="line">      <span class="comment">// render函数中的this指向为当前组件对象(react内部修正)</span></span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handler()&#125;&gt;click to test&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><div class="note green no-icon flat"><p>受控组件：被 react 的状态控制的组件</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="comment">// 1. 声明用于控制值的react组件状态</span></span><br><span class="line">    msg: <span class="string">&#x27;this is message&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  inputChange (e) &#123;</span><br><span class="line">    <span class="comment">// 4. 拿到输入框中的值，交给state</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      msg: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 2. 绑定state中的值</span></span><br><span class="line">      <span class="comment">// 3. 绑定事件，拿到当前输入框中的数据</span></span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;&#123;<span class="built_in">this</span>.state.msg&#125;&lt;/div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">          value=&#123;<span class="built_in">this</span>.state.msg&#125;</span><br><span class="line">          onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.inputChange(e)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p>非受控组件：手动操作 dom 来获取文本框的值，文本框状态不受 state 中的状态控制</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入creatRef函数</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; createRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 2. 调用createRef函数，创建Ref示例属性</span></span><br><span class="line">  msgRef = createRef()</span><br><span class="line">  getValue = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 通过msgRef.current可以拿到input对应的dom元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msgRef.current.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 3. 为input添加ref属性</span></span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">          ref=&#123;<span class="built_in">this</span>.msgRef&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.getValue&#125;&gt;点击获取变化的值&lt;/button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><div class="note warning no-icon flat"><ol><li>父组件提供需要传递的数据 state</li><li>给子组件标签添加属性值为 state 中的数据</li><li>子组件通过 props 接收父组件中传过来的值<br>|—类组件使用 this.props 获取 props 对象<br>|—函数式组件直接通过参数获取 props 对象</li></ol></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// App 父组件 Son 自组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过props接收父组件传过来的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;SonA，&#123;props.msg&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonB</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;SonB, &#123;<span class="built_in">this</span>.props.msg&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1.准备数据</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;this is message&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="comment">/* 子组件身上绑定属性 */</span>&#125;</span><br><span class="line">        &lt;SonA msg=&#123;<span class="built_in">this</span>.state.msg&#125;/&gt;</span><br><span class="line">        &lt;SonB msg=&#123;<span class="built_in">this</span>.state.msg&#125;/&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p>props 可以传递任何数据：数字、字符串、布尔值、数组、对象、函数、JSX</p></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// App 父组件 Son 自组件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过props接收父组件传过来的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  props.getMsg()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;SonA, &#123;props.list.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      &lt;div key=&#123;item&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">    )&#125;, &#123;props.child&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonB</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;SonB, &#123;<span class="built_in">this</span>.props.msg&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.准备数据</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;this is message&#x27;</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getMsg = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="comment">/* 子组件身上绑定属性 */</span>&#125;</span><br><span class="line">        &lt;SonA</span><br><span class="line">          msg=&#123;<span class="built_in">this</span>.state.msg&#125;</span><br><span class="line">          list=&#123;<span class="built_in">this</span>.state.list&#125;</span><br><span class="line">          getMsg=&#123;<span class="built_in">this</span>.getMsg&#125;</span><br><span class="line">          child=&#123;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;SonB msg=&#123;<span class="built_in">this</span>.state.msg&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><div class="tip warning"><p>根据单项数据流的要求，子组件只能读取 props 中的数据，不能进行修改</p></div><p>解构 props 可以让代码整体变得更加简单，只解构需要使用的部分即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入后解构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;list, child&#125; = props</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;SonA, &#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      &lt;div key=&#123;item&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">    )&#125;, &#123;child&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在参数位置解构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span> (<span class="params">&#123;list, child&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;SonA, &#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">      &lt;div key=&#123;item&#125;&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">    )&#125;, &#123;child&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>子传父的本质是子组件调用父组件传递的函数，并将想要传递的数据当成函数的实参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span>(<span class="params">&#123;getSonMsg&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getSonMsg(<span class="string">&#x27;这是子组件的信息&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;<span class="built_in">this</span> is son</span><br><span class="line">      &lt;button onClick=&#123;clickHandler&#125;&gt;click&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getSonMsg = <span class="function">(<span class="params">sonMsg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sonMsg)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;SonA getSonMsg=&#123;<span class="built_in">this</span>.getSonMsg&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h3><p>兄弟通信的本质还是借助父子组件通信</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonA</span>(<span class="params">&#123;getSonMsg&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getSonMsg(<span class="string">&#x27;这是子组件A的信息&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;<span class="built_in">this</span> is son</span><br><span class="line">      &lt;button onClick=&#123;clickHandler&#125;&gt;click&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SonB</span>(<span class="params">&#123;brotherMsg&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;brotherMsg&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSonMsg = <span class="function">(<span class="params">sonMsg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      msg: sonMsg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;SonA getSonMsg=&#123;<span class="built_in">this</span>.getSonMsg&#125;/&gt;</span><br><span class="line">        &lt;SonB brotherMsg=&#123;<span class="built_in">this</span>.state.msg&#125;/&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="Context-跨组件通信"><a href="#Context-跨组件通信" class="headerlink" title="Context 跨组件通信"></a>Context 跨组件通信</h3><p>实现从上往下跨任意层传递信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入createContext</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      <span class="built_in">this</span> is ComA</span><br><span class="line">      &lt;ComB /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 3.通过Consumer使用数据</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;/Consumer&gt;</span><br><span class="line">      <span class="built_in">this</span> is ComB</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;this is a message&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 2.使用provider包裹根组件</span></span><br><span class="line">      &lt;Provider value=&#123;<span class="built_in">this</span>.state.msg&#125;&gt;</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;ComA /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">      &lt;/Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p>to be continued (maybe)</p></div>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React基础速通计划：React基础与JSX</title>
      <link href="2022/06/16/reactBasic/"/>
      <url>2022/06/16/reactBasic/</url>
      
        <content type="html"><![CDATA[<p>b站React学习计划启动</p><div class="note orange no-icon flat"><div class="site-card-group"><a class="site-card" href="https://www.bilibili.com/video/BV1Z44y1K7Fj?spm_id_from=333.337.search-card.all.click&vd_source=beaf1e6a6aabc6fe578a4976a22a4d85"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bilibili.png"/></div><div class="info"><span class="title">React入门到实战2022</span></div></a></div></div><h2 id="React基础搭建与目录简化"><a href="#React基础搭建与目录简化" class="headerlink" title="React基础搭建与目录简化"></a>React基础搭建与目录简化</h2><p>采用creat-react-app手脚架来搭建react应用</p><p>终端输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app react-basic</span><br></pre></td></tr></table></figure><p>一些说明：</p><ol><li>npx create-react-app 是固定命令，create-react-app是React脚手架的名称</li><li>react-basic表示项目名称</li><li>npx命令会临时安装create-react-app包，初始化项目完成后会自动删掉</li></ol><p>在安装完成后终端输入<code>npm start</code>启动项目</p><p>我们可以在页面中看到一个转动的react图标和几行字</p><p>打开项目目录，coding文件主要在src文件夹中，首先将src文件中多余的内容删除，保留三个核心的入口文件：App.js,index.css和index.js</p><p>然后删除App.js和index.js中和一些删除文件的关联，保留内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* App.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      app</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="comment">// 引入框架核心包</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 引入渲染相关的包</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="comment">// 引入全局样式文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="comment">// 引入根组件App</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">root.render(</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>之后JSX的学习均在App.js中进行</p><h2 id="JSX基础"><a href="#JSX基础" class="headerlink" title="JSX基础"></a>JSX基础</h2><p>JSX (JavaScipt XML) 就是react中的HTML，通过js的自身可编程能力来创建HTML结构</p><p>将命令式写法简化为声明式写法 (就是咱写简单的声明写法，编译器会将其转化为命令式写法后运行)</p><h3 id="JSX表达式"><a href="#JSX表达式" class="headerlink" title="JSX表达式"></a>JSX表达式</h3><p>语法： <code>&#123; JSX表达式 &#125;</code></p><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;常规变量&#x27;</span></span><br><span class="line"><span class="keyword">const</span> getDate = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;2022.6.16&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;beautiful&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &#123; name &#125;</span><br><span class="line">      &#123; getDate() &#125;</span><br><span class="line">      &#123; flag? <span class="string">&#x27;真&#x27;</span> : <span class="string">&#x27;假&#x27;</span> &#125;</span><br><span class="line">      &#123; str.split(<span class="string">&#x27;&#x27;</span>).join(<span class="string">&#x27;-&#x27;</span>) &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><div class="tip warning"><p>注意switch-case/if条件判断/变量声明语句属于语句，而非表达式</p></div><h3 id="JSX列表渲染"><a href="#JSX列表渲染" class="headerlink" title="JSX列表渲染"></a>JSX列表渲染</h3><p>采用map进行</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">item</span>: <span class="string">&quot;条目1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">item</span>: <span class="string">&quot;条目2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">item</span>: <span class="string">&quot;条目3&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map(<span class="function">(<span class="params">list</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;list.id&#125;&gt;&#123;list.item&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><div class="tip warning"><p>遍历列表需要类型为number/string的不可重复的key来提高diff性能, key只在内部使用，不会在真实dom中出现</p></div><h3 id="JSX条件渲染"><a href="#JSX条件渲染" class="headerlink" title="JSX条件渲染"></a>JSX条件渲染</h3><p>就用刚才那个列表继续做例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">item</span>: <span class="string">&quot;条目1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">item</span>: <span class="string">&quot;条目2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">item</span>: <span class="string">&quot;条目3&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足条件才显示列表</span></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;flag ? list.map(<span class="function">(<span class="params">list</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;list.id&#125;</span>&gt;</span>&#123;list.item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>) : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>也可以用逻辑判断语句更简单地完成这个任务 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">item</span>: <span class="string">&quot;条目1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">item</span>: <span class="string">&quot;条目2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">item</span>: <span class="string">&quot;条目3&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;flag &amp;&amp; list.map(<span class="function">(<span class="params">list</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;list.id&#125;</span>&gt;</span>&#123;list.item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h3 id="JSX样式"><a href="#JSX样式" class="headerlink" title="JSX样式"></a>JSX样式</h3><p>JSX样式分为行内样式和类名样式，如下示例所示，style1是行内样式，style2是类名样式</p><p>优先级同css优先级：行内样式 &gt; 类名样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.style2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行内样式，直接在元素上绑定一个style属性</span></span><br><span class="line"><span class="keyword">const</span> style1 = &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">fontSize</span>: <span class="string">&quot;50px&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;span style=&#123;style1&#125;&gt;span1&lt;/span&gt;</span><br><span class="line">      &lt;span className=<span class="string">&quot;style2&quot;</span>&gt;span2&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>动态控制类名: 用三目表达式即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span className=&#123;flag ? <span class="string">&#x27;style1&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;&gt;span2&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="JSX注意事项"><a href="#JSX注意事项" class="headerlink" title="JSX注意事项"></a>JSX注意事项</h3><div class="note warning no-icon flat"><ol><li>JSX必须有一个根节点，如果没有根节点，可以使用&lt;&gt;&lt;/&gt;（幽灵节点）替代</li><li>所有标签必须形成闭合，成对闭合或自闭合均可</li><li>JSX语法属性名采用驼峰命名法 class -&gt; className for -&gt; htmlFor</li><li>JSX支持多行，如需换行，需用()包裹，防止bug</li></ol></div>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS事件循环</title>
      <link href="2021/09/07/eventloop/"/>
      <url>2021/09/07/eventloop/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>简单地概括，事件循环就是JS调度同步、异步任务的策略</p><p>同步任务意思就是代码是同步执行的，异步任务则是代码是异步执行的，因为JS是单线程的，所以如果JS全部采用同步任务的方式，那么遇到setTimeout这种语句，得等时间走完才能执行下面的内容</p><p>事件循环的方式就是，直接执行同步任务，将异步任务交付给其它线程，当异步任务执行完后往事件队列里面塞一个回调函数，当执行栈为空时，主线程才会去读取事件队列，看看有没有任务（异步任务执行完的回调）要执行，每次取一个来执行，重复直到事件队列为空</p><p>知道这一点，以下代码就很容易得出，先输出同步任务，再输出异步任务的结论</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;异步任务&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;同步任务&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>首先来说明一下why，为什么有宏任务和微任务之分，有的时候，一些异步操作并不想要经历整个事件循环，所以有了微任务，与之相对的就是宏任务</p><p>宏任务(Marco)和微任务(Micro)的执行顺序是，第一次事件循环，整段代码作为宏任务进入主线程执行，同步代码被直接推到执行栈执行，遇到异步代码就挂起交由其他线程执行(执行完会往事件队列塞回调)，同步代码执行完，读取微任务队列，若有则执行所有微任务，微任务清空，页面渲染，从事件队列面里取一个宏任务塞入执行栈执行，重复上述过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宏任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> macrotask of macrotask_list) &#123;</span><br><span class="line">  <span class="comment"># 执行一个宏任务</span></span><br><span class="line">  macrotask(); </span><br><span class="line">  <span class="comment"># 执行所有微任务</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> microtask of microtask_list) &#123;</span><br><span class="line">    microtask();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">#  UI渲染</span></span><br><span class="line">  render(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏任务和微任务的划分如下</p><table><thead><tr><th>任务</th><th>Chrome</th><th>Node</th><th>分类</th></tr></thead><tbody><tr><td>I/O</td><td>√</td><td>√</td><td>Marco</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>×</td><td>Marco</td></tr><tr><td>setTimeout</td><td>√</td><td>√</td><td>Marco</td></tr><tr><td>setInterval</td><td>√</td><td>√</td><td>Marco</td></tr><tr><td>setImmediate</td><td>×</td><td>√</td><td>Marco</td></tr><tr><td>process.nextTick</td><td>×</td><td>√</td><td>Micro</td></tr><tr><td>MutationObserver</td><td>√</td><td>×</td><td>Micro</td></tr><tr><td>Promise</td><td>√</td><td>√</td><td>Micro</td></tr></tbody></table><p>ok，先来看一个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>首先执行整段代码，将script start和script end加入执行栈，promise1和promise2加入微任务队列，setTimeout加入事件队列，执行，输出script start和script end，然后清理微任务队列，输出promise1, promise2，最后输出setTImeout</p><p>再看一个稍微复杂的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>), <span class="number">10</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出的顺序是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">then1</span><br><span class="line">timeout1</span><br><span class="line">timeout2</span><br></pre></td></tr></table></figure><p>promise本身的内容是立即执行的，只有then中的部分才属于micro task</p><p>再来看一个终极版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">window</span>).click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;clicked1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked promise1&#x27;</span>)); </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked timeout1&#x27;</span>), <span class="number">0</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">window</span>).click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;clicked2&#x27;</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked promise2&#x27;</span>));</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked timeout2&#x27;</span>), <span class="number">0</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">window</span>).click(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;clicked3&#x27;</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked promise3&#x27;</span>)); </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;clicked timeout3&#x27;</span>), <span class="number">0</span>); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>)</span><br></pre></td></tr></table></figure><p>首先会输出script start和script end，然后点击window，将click1加入主执行栈，clicked promise1，第三个Promise加入微任务队列，第一个和第二个setTimeout加入事件队列</p><p>第一次执行输出click1，并清理微任务队列，输出clicked promise1，clicked3，继续执行微任务输出clicked promise3，将第三个setTimeout加入事件队列</p><p>执行宏任务clicked timeout1，无微任务</p><p>执行第二个setTimeout，输出clicked2，将clicked promise2加入微任务，将clicked timeout2加入事件队列，清理微任务，输出clicked promise2</p><p>执行宏任务clicked timeout2，无微任务 (顺序执行)</p><p>执行宏任务clicked timeout3，无微任务</p><p>总体顺序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line"></span><br><span class="line">script end</span><br><span class="line"></span><br><span class="line">clicked1</span><br><span class="line"></span><br><span class="line">clicked promise1</span><br><span class="line"></span><br><span class="line">clicked3</span><br><span class="line"></span><br><span class="line">clicked promise3</span><br><span class="line"></span><br><span class="line">clicked timeout1</span><br><span class="line"></span><br><span class="line">clicked2</span><br><span class="line"></span><br><span class="line">clicked promise2</span><br><span class="line"></span><br><span class="line">clicked timeout2</span><br><span class="line"></span><br><span class="line">clicked timeout3</span><br></pre></td></tr></table></figure><p>交换第二部分和第三部分的代码，就会交换clicked timeout2和clicked timeout3的执行顺序</p>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise详解</title>
      <link href="2021/08/31/promise/"/>
      <url>2021/08/31/promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h2><p>Promise是一个<strong>构造函数</strong>，它能够接受一个函数作为参数，这个函数包含了两个参数resolve和reject，分别是<strong>异步操作</strong>执行成功时执行的回调函数和执行失败时执行的回调函数</p><p>Promise对象存在三种状态：等待态(Pending)、执行态(Fulfilled)和拒绝态(Rejected)</p><p>简单地讲，回调函数resolve(data)做的事情是，将Promise对象标记为执行态，然后进行下一步的操作then((data)=&gt;{//do sth.})，回调函数reject(error)则将Promise对象标记为拒绝态，然后可以catch这个error并执行对应的操作</p><p>我们来使用一下Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步任务1执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn1的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">fn1().then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise在创建的时候就会直接调用，所以一般的用法是用一个函数包裹Promise，然后将生成的Promise对象返回出来，构造函数中传入的两个参数resolve和reject可以随意命名，不影响使用</p><p>Promise最大的优势在于在异步操作执行完后，用链式调用的方式执行回调函数，比如原先需要层层回调的操作，就可以被简化成如下的形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作1执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn1的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作2执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn2的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">fn1().then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  <span class="keyword">return</span> fn2();</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当执行中出现问题的时候，可以用参数reject将对象标记为拒绝态，然后返回原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getpassword</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 获取输入的密码</span></span><br><span class="line">      <span class="keyword">var</span> password = <span class="string">&quot;12345&quot;</span></span><br><span class="line">      <span class="keyword">if</span>(password.length &lt; <span class="number">6</span>)&#123;</span><br><span class="line">        reject(<span class="string">&quot;密码过短&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        resolve(password)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getpassword().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;密码:&quot;</span>+data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>.then</code>中允许放入两个参数，两个分别用于承接resolve和reject时返回数据的回调函数</p><h2 id="Promise的基础实现"><a href="#Promise的基础实现" class="headerlink" title="Promise的基础实现"></a>Promise的基础实现</h2><p>基于以上内容，我们可以根据规范来实现一个Promise</p><p>实现的核心有几点，一是链式调用，二是状态的维护，当状态改变时才会触发之后的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  state = PENDING;</span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 绑定this</span></span><br><span class="line">    fn(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 链式调用，p.then().then()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._handle(&#123;</span><br><span class="line">        <span class="comment">// onFulfilled和onRejected都可能为空</span></span><br><span class="line">        onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">        onRejected: onRejected || <span class="literal">null</span>,</span><br><span class="line">        resolve: resolve,</span><br><span class="line">        reject: reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_handle</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 注册回调函数，用队列是因为可能一个promise不止一个后继节点，可能有p.then()，p.then()的情况</span></span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(callback);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">this</span>.state === FULFILLED ? callback.onFulfilled : callback.onRejected;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123; <span class="comment">//如果then中没有传递任何东西</span></span><br><span class="line">      fn = <span class="built_in">this</span>.state === FULFILLED ? callback.resolve : callback.reject;</span><br><span class="line">      fn(<span class="built_in">this</span>.value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = fn(<span class="built_in">this</span>.value);</span><br><span class="line">    fn = <span class="built_in">this</span>.state === FULFILLED ? callback.resolve : callback.reject;</span><br><span class="line">    fn(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是Promise实例，就把当前Promise实例的状态改变接口重新注册到resolve的值对应的Promise的onFulfilled中</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = value.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        then.call(value, <span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切换状态</span></span><br><span class="line">    <span class="built_in">this</span>.state = FULFILLED</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="built_in">this</span>._handle(callback));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_reject</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = REJECTED</span><br><span class="line">    <span class="built_in">this</span>.value = error</span><br><span class="line">    <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="built_in">this</span>._handle(callback));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all与实现"><a href="#Promise-all与实现" class="headerlink" title="Promise.all与实现"></a>Promise.all与实现</h2><p>Promise.all的作用是并行地执行异步操作，它能接收一个Promise数组，当他们都执行完的时候，将他们resolve的内容拼接成一个数组返回出来</p><p>我们先来简单地使用一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作1执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn1的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作2执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn2的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([fn1(), fn2()]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们要实现的只是按promise顺序执行resolve，将返回的data保存在一个数组里返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromiseAll</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rets = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">promise, id</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        rets[id] = data;</span><br><span class="line">        <span class="keyword">if</span> (rets.length === promises.length) &#123;</span><br><span class="line">          resolve(rets);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> reject(reason));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">MyPromiseAll([fn1(), fn2()]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-race与实现"><a href="#Promise-race与实现" class="headerlink" title="Promise.race与实现"></a>Promise.race与实现</h2><p>Promise.race同样接受一个Promise数组，但是它返回的是最先结束的异步操作得到的数据</p><p>比如下方代码，最后只有fn2的数据被返回出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作1执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn1的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">myresolve, myreject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;异步操作2执行完成&quot;</span>)</span><br><span class="line">      myresolve(<span class="string">&quot;返回fn2的数据&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([fn1(), fn2()]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>race的实现相比all更简单，直接把所有Promise放进去跑，谁先出来就返回即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromiseRace</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(value)</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reject(reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">MyPromiseRace([fn1(),fn2()]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FA-SSD：使用上下文和注意力机制的小目标检测</title>
      <link href="2021/07/08/FASSD/"/>
      <url>2021/07/08/FASSD/</url>
      
        <content type="html"><![CDATA[<p>论文主要提出一种基于上下文的目标检测方法和一种基于注意力的目标检测方法，并将两者结合，在小目标检测问题上达到sota</p><h2 id="小目标检测相关的工作"><a href="#小目标检测相关的工作" class="headerlink" title="小目标检测相关的工作"></a>小目标检测相关的工作</h2><p>文中列举的小目标相关的工作</p><ol><li>数据扩充，解决小目标数量不足的问题 (减少大目标的大小来扩充小目标数据)</li><li>DSSD，将反卷积应用在SSD的所有特征图上，得到按比例放大的特征图，但因所有特征图用了反卷积模块使得复杂度增加，速度减慢</li><li>R-SSD，通过池化和反卷积结合了不同尺度的特征，获得比DSSD更高的精度和速度</li></ol><div class="note orange no-icon flat"><div class="site-card-group"><a class="site-card" href="https://arxiv.org/pdf/1701.06659.pdf"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">DSSD</span></div></a><a class="site-card" href="https://arxiv.org/pdf/1705.09587.pdf"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">R-SSD</span></div></a></div></div><h2 id="论文提出的方法"><a href="#论文提出的方法" class="headerlink" title="论文提出的方法"></a>论文提出的方法</h2><p>文章是基于SSD来改进，提升其检测小目标的能力</p><p>SSD本身以VGG16作为主干网络，创建不同分辨率的特征图，每个特征通过一个额外的卷积层来匹配输出通道，思想主要是利用浅层特征图的高分辨率来检测较小的目标，而利用分辨率较低的深层特征来检测较大的目标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-1.png"></p><p>尽管如此，SSD在小目标检测的性能依旧非常低，在VOC2007上小目标的mAP只有20.7%，作者认为主要有两个原因，一是缺乏上下文信息，二是浅层特征缺乏语义信息，所以改进主要针对这两方面</p><h3 id="F-SSD：上下文和特征融合"><a href="#F-SSD：上下文和特征融合" class="headerlink" title="F-SSD：上下文和特征融合"></a>F-SSD：上下文和特征融合</h3><p>思路非常简单，为了给目标特征提供上下文，将其和更高层次的特征进行融合，模型如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-2.png"></p><p>因为特征的映射空间大小不同，所以融合方法如下图，在将特征融合之前，对上下文特征进行反卷积运算，使得其空间大小相同</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-3.png"></p><p>同时，作者将<strong>上下文特征通道设置为目标特征的一半</strong>，使得上下文信息量不会压到目标特征本身，文中采取的上下文信息和目标特征的融合方式是直接叠加</p><h3 id="A-SSD：添加注意力模块"><a href="#A-SSD：添加注意力模块" class="headerlink" title="A-SSD：添加注意力模块"></a>A-SSD：添加注意力模块</h3><p>模型主要是采用了残差注意模块，网络结构如下图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-4.png"></p><p>残差注意模块和组件内容如下所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-5.png"></p><div class="note orange no-icon flat"><div class="site-card-group"><a class="site-card" href="https://arxiv.org/pdf/1704.06904.pdf"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">残差注意力模块</span></div></a></div></div><h3 id="FA-SSD：两种方法融合"><a href="#FA-SSD：两种方法融合" class="headerlink" title="FA-SSD：两种方法融合"></a>FA-SSD：两种方法融合</h3><p>模型如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-6.png"></p><p>结果对比如下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FASSD-7.png"></p><hr><div class="note orange no-icon flat"><div class="site-card-group"><a class="site-card" href="https://arxiv.org/pdf/1912.06319.pdf"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">FASSD</span></div></a></div></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> 2021 </tag>
            
            <tag> 小目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmdetection训练自己的数据集</title>
      <link href="2021/06/22/mmdetection/"/>
      <url>2021/06/22/mmdetection/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的标注"><a href="#数据的标注" class="headerlink" title="数据的标注"></a>数据的标注</h2><p>在介绍mmdetection之前，先来讲讲如何制作一个coco格式的数据集</p><h3 id="via标注工具"><a href="#via标注工具" class="headerlink" title="via标注工具"></a>via标注工具</h3><p>标注数据集用的是via标注工具</p><p>VGG Image Annotator (VIA)是一款开源的图像标注工具, 由Visual Geometry Group开发</p><p>这里我上传了一份到gitpage方便在线使用</p><a class="btn-beautify button--animated outline orange larger" href="https://forever97.github.io/via/"   title="via标注工具"><i class="far fa-hand-point-right fa-fw"></i><span>via标注工具</span></a><p>打开via标注工具，首先导入图片，可以单张导入也可以批量导入</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-2.png" style="width:400px;"/></div></div><p>在左侧选择标注框来进行标注，因为我做的是目标检测，所以选择的是bbox</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-3.png" style="width:400px;"/></div></div><p>在标注的过程中，如果我们觉得数字labels影响精细标注了，则可以在view这里暂时隐藏掉label</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-4.png" style="width:400px;"/></div></div><p>用<kbd>ctrl</kbd>+鼠标滚轮可以放大缩小图片，可以更细致地标注内容</p><p>接下来我们给标注的内容添加类别，因为我制作的数据集只有一个类也就是tree，所以后期直接用python处理统一添加即可，如果有好几个类，则建议直接在via标注工具中添加类别</p><p>添加方式如下图 (Snipaste真好用)</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-5.png" style="width:400px;"/></div></div><p>最后讲一下保存和载入，因为我们是打了类别标注的，所以要整个工程一起存储方便下次导入继续标注，region/file attributes的导入与导出是把创建的类别导入进来，免得下次标注要重新创建，不过类别少的导师无所谓</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-6.png" style="width:400px;"/></div></div><p>因为可能是多人共同完成的标注，所以标注文件有时候会需要合并，则需要每个工程导出为一个json文件，然后将导出的内容一起导入，再统一导出即可 (工程文件不能同时导入多个)</p><div class="img-wrap"><div class="img-bg"><img class="img" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/mmdetection-7.png" style="width:400px;"/></div></div><p>这样子标注就完成了 (最后导出为coco格式)</p><h3 id="COCO数据集格式介绍"><a href="#COCO数据集格式介绍" class="headerlink" title="COCO数据集格式介绍"></a>COCO数据集格式介绍</h3><p>coco数据集本身是一个字典，里面包含五块内容，info，licenses，images，annotations以及categories</p><p>我们在训练时需要的部分是图片images，标注annotations以及类别categories</p><p>annotations的格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annotation&#123;</span><br><span class="line">    &quot;id&quot;: int,    </span><br><span class="line">    &quot;image_id&quot;: int,</span><br><span class="line">    &quot;category_id&quot;: int,</span><br><span class="line">    &quot;segmentation&quot;: RLE or [polygon],</span><br><span class="line">    &quot;area&quot;: float,</span><br><span class="line">    &quot;bbox&quot;: [x,y,width,height],</span><br><span class="line">    &quot;iscrowd&quot;: 0 or 1,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>id是标注的编号，要求同一份数据集里面不能重复，所以在做数据集合并的时候需要注意</p><p>image_id是图片在数据集中的编号，这里的image_id要求使用int，但是不知道为什么via标注导出的是个字符串，所以一会儿得要处理</p><p>catagory_id对应的是类别的id</p><p>image的格式没有特别需要注意的地方，同样也是id不能重复</p><p>catagory因为我只有一个类别所以处理的时候最后直接加上</p><h3 id="数据集处理"><a href="#数据集处理" class="headerlink" title="数据集处理"></a>数据集处理</h3><p>首先是标注文件的合并，因为有一堆信息 (比如image_id得是int) 要处理，所以我合并文件直接用python处理的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">json_list = os.listdir(<span class="string">&quot;annotations&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录json文件</span></span><br><span class="line">annotations_list = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">image = []</span><br><span class="line">annotations = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的json文件读入</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> json_list:</span><br><span class="line">    <span class="keyword">if</span> (file.endswith(<span class="string">&quot;.json&quot;</span>)):</span><br><span class="line">        annotations_list.append(file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编号统计，防止图片编号重复</span></span><br><span class="line">total_img = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> anno_name <span class="keyword">in</span> annotations_list:</span><br><span class="line">    img_cnt = <span class="number">0</span></span><br><span class="line">    anno = json.loads(<span class="built_in">open</span>(<span class="string">&quot;annotations/&quot;</span>+anno_name,encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> anno[<span class="string">&quot;images&quot;</span>]:</span><br><span class="line">        img[<span class="string">&quot;id&quot;</span>] += total_img</span><br><span class="line">        <span class="comment"># 处理完的img存入image列表</span></span><br><span class="line">        image.append(img)</span><br><span class="line">        img_cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> anno[<span class="string">&#x27;annotations&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 计算对应的图片编号</span></span><br><span class="line">        a[<span class="string">&#x27;image_id&#x27;</span>] = <span class="built_in">int</span>(a[<span class="string">&#x27;image_id&#x27;</span>])+total_img</span><br><span class="line">        a[<span class="string">&#x27;category_id&#x27;</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 处理完的annotation存入annotations列表</span></span><br><span class="line">        annotations.append(a)</span><br><span class="line">    total_img += img_cnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典对应的部分放入</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;images&#x27;</span>]=image</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;annotations&#x27;</span>]=annotations</span><br><span class="line"><span class="comment"># 类别直接写</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;categories&#x27;</span>]=[&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;supercategory&quot;</span>: <span class="string">&quot;category&quot;</span></span><br><span class="line">  &#125;]</span><br><span class="line">json.dump(<span class="built_in">dict</span>, <span class="built_in">open</span>(<span class="string">&#x27;total.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>), indent=<span class="number">4</span>, ensure_ascii=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后划分训练集和验证集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">anno = json.loads(<span class="built_in">open</span>(<span class="string">&quot;total.json&quot;</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(anno.keys())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集测试集比例为3:1</span></span><br><span class="line">train_percent=<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生一个随机的排列</span></span><br><span class="line"><span class="built_in">len</span> = <span class="built_in">len</span>(anno[<span class="string">&#x27;images&#x27;</span>])</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">img_name = []</span><br><span class="line"></span><br><span class="line">train_img = []</span><br><span class="line">val_img = []</span><br><span class="line"></span><br><span class="line">train_anno = []</span><br><span class="line">val_anno = []</span><br><span class="line"></span><br><span class="line">train_file = &#123;&#125;</span><br><span class="line">val_file = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片名字列表</span></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> anno[<span class="string">&#x27;images&#x27;</span>]:</span><br><span class="line">    img_name.append(img[<span class="string">&quot;file_name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算训练集大小</span></span><br><span class="line">tr = <span class="built_in">int</span>(<span class="built_in">len</span> * train_percent)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从排列中随机</span></span><br><span class="line">train = random.sample(<span class="built_in">list</span>, tr)</span><br><span class="line"></span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化字典，给分配到训练集中的图片名打上标记</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>):</span><br><span class="line">    dic[img_name[i]] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> train:</span><br><span class="line">    dic[img_name[i]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给图片id打上标记</span></span><br><span class="line">id_dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>):</span><br><span class="line">    id_dic[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据标记分配图片</span></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> anno[<span class="string">&quot;images&quot;</span>]:</span><br><span class="line">    <span class="keyword">if</span>(dic[img[<span class="string">&quot;file_name&quot;</span>]] == <span class="number">1</span>):</span><br><span class="line">        train_img.append(img)</span><br><span class="line">        id_dic[img[<span class="string">&quot;id&quot;</span>]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        val_img.append(img)</span><br><span class="line"></span><br><span class="line">train_anno_id = <span class="number">0</span></span><br><span class="line">val_anno_id = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据标记分配标注</span></span><br><span class="line"><span class="keyword">for</span> anno_item <span class="keyword">in</span> anno[<span class="string">&quot;annotations&quot;</span>]:</span><br><span class="line">    <span class="keyword">if</span>(id_dic[anno_item[<span class="string">&quot;image_id&quot;</span>]]==<span class="number">1</span>):</span><br><span class="line">        anno_item[<span class="string">&quot;id&quot;</span>] = train_anno_id</span><br><span class="line">        train_anno.append(anno_item)</span><br><span class="line">        train_anno_id += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        anno_item[<span class="string">&quot;id&quot;</span>] = val_anno_id</span><br><span class="line">        val_anno.append(anno_item)</span><br><span class="line">        val_anno_id += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别保存训练集和验证集</span></span><br><span class="line">train_file[<span class="string">&#x27;images&#x27;</span>] = train_img</span><br><span class="line">train_file[<span class="string">&#x27;annotations&#x27;</span>] = train_anno</span><br><span class="line">train_file[<span class="string">&#x27;categories&#x27;</span>]=[&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;supercategory&quot;</span>: <span class="string">&quot;category&quot;</span></span><br><span class="line">  &#125;]</span><br><span class="line">json.dump(train_file, <span class="built_in">open</span>(<span class="string">&#x27;train.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>), indent=<span class="number">4</span>, ensure_ascii=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将对应的图片pick出来</span></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> train_file[<span class="string">&quot;images&quot;</span>]:</span><br><span class="line">    shutil.copy(<span class="string">&quot;img/&quot;</span>+img[<span class="string">&quot;file_name&quot;</span>],<span class="string">&quot;train_img/&quot;</span>)</span><br><span class="line"></span><br><span class="line">val_file[<span class="string">&#x27;images&#x27;</span>] = val_img</span><br><span class="line">val_file[<span class="string">&#x27;annotations&#x27;</span>] = val_anno</span><br><span class="line">val_file[<span class="string">&#x27;categories&#x27;</span>]=[&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;tree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;supercategory&quot;</span>: <span class="string">&quot;category&quot;</span></span><br><span class="line">  &#125;]</span><br><span class="line">json.dump(val_file, <span class="built_in">open</span>(<span class="string">&#x27;val.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>), indent=<span class="number">4</span>, ensure_ascii=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> val_file[<span class="string">&quot;images&quot;</span>]:</span><br><span class="line">    shutil.copy(<span class="string">&quot;img/&quot;</span>+img[<span class="string">&quot;file_name&quot;</span>],<span class="string">&quot;val_img/&quot;</span>)</span><br></pre></td></tr></table></figure><p>至此，算是彻底完成了一个自定义的coco格式的数据集</p><h2 id="mmdetection的使用"><a href="#mmdetection的使用" class="headerlink" title="mmdetection的使用"></a>mmdetection的使用</h2><p>先在git上clone一个mmdetection到服务器上，或者直接下载上传到服务器</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/open-mmlab/mmdetection"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=open-mmlab&repo=mmdetection&theme=solarized-light&show_owner=true"/></a><p>然后到这个mmdetection文件夹下</p><p>我的安装列表如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip install torch&#x3D;&#x3D;1.6.0</span><br><span class="line"></span><br><span class="line">pip install torchvision&#x3D;&#x3D;0.7.0</span><br><span class="line"></span><br><span class="line">pip install -r requirements&#x2F;build.txt</span><br><span class="line"></span><br><span class="line">pip install -v -e .</span><br><span class="line"></span><br><span class="line">pip install ninja </span><br><span class="line"></span><br><span class="line">pip install mmcv-full -f https:&#x2F;&#x2F;download.openmmlab.com&#x2F;mmcv&#x2F;dist&#x2F;cu101&#x2F;torch1.6.0&#x2F;index.html</span><br></pre></td></tr></table></figure><p>注意要装mmcv-full，而不是mmcv，同时如果mmcv-full安装不了就看看有没有ninja，没有的话安装一个 </p><p>这些步骤都执行完之后按照官网的代码测试一下</p><p>然后在文件夹下创建一个data文件夹</p><p>内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">|---coco</span><br><span class="line">    |---annotations</span><br><span class="line">        |---instances_train2017.json</span><br><span class="line">        |---instances_val2017.json</span><br><span class="line">    |---val2017</span><br><span class="line">    |---train2017</span><br></pre></td></tr></table></figure><p>其中val2017和train2017是验证集和测试集的图片文件夹，instances_train2017.json和instances_val2017.json是训练集和验证集的标注文件 (当然这里可以用自己的名字然后去代码里面改，但是要改的东西更多)</p><p>接着我们来整一个模型配置文件</p><p>首先看一下<code>configs/_base_/models/</code>目录，这里面是各个模型对应的参数，我们先尝试改一个fasterRCNN，我们打开<code>faster_rcnn_r50_fpn.py</code></p><p>搜索num_classes，将类的数量改为自己数据集类的数量，不需要因为背景+1，因为mmdetection会自动处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># num_classes=80,</span></span><br><span class="line">num_classes=<span class="number">1</span>,</span><br></pre></td></tr></table></figure><p>然后修改coco数据集对应的类，在<code>mmdet/core/evaluation/class_names.py</code>中，找到coco数据集，进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coco_classes</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &#x27;person&#x27;, &#x27;bicycle&#x27;, &#x27;car&#x27;, &#x27;motorcycle&#x27;, &#x27;airplane&#x27;, &#x27;bus&#x27;, &#x27;train&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;truck&#x27;, &#x27;boat&#x27;, &#x27;traffic_light&#x27;, &#x27;fire_hydrant&#x27;, &#x27;stop_sign&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;parking_meter&#x27;, &#x27;bench&#x27;, &#x27;bird&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;horse&#x27;, &#x27;sheep&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;cow&#x27;, &#x27;elephant&#x27;, &#x27;bear&#x27;, &#x27;zebra&#x27;, &#x27;giraffe&#x27;, &#x27;backpack&#x27;, &#x27;umbrella&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;handbag&#x27;, &#x27;tie&#x27;, &#x27;suitcase&#x27;, &#x27;frisbee&#x27;, &#x27;skis&#x27;, &#x27;snowboard&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;sports_ball&#x27;, &#x27;kite&#x27;, &#x27;baseball_bat&#x27;, &#x27;baseball_glove&#x27;, &#x27;skateboard&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;surfboard&#x27;, &#x27;tennis_racket&#x27;, &#x27;bottle&#x27;, &#x27;wine_glass&#x27;, &#x27;cup&#x27;, &#x27;fork&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;knife&#x27;, &#x27;spoon&#x27;, &#x27;bowl&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;sandwich&#x27;, &#x27;orange&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;broccoli&#x27;, &#x27;carrot&#x27;, &#x27;hot_dog&#x27;, &#x27;pizza&#x27;, &#x27;donut&#x27;, &#x27;cake&#x27;, &#x27;chair&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;couch&#x27;, &#x27;potted_plant&#x27;, &#x27;bed&#x27;, &#x27;dining_table&#x27;, &#x27;toilet&#x27;, &#x27;tv&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;laptop&#x27;, &#x27;mouse&#x27;, &#x27;remote&#x27;, &#x27;keyboard&#x27;, &#x27;cell_phone&#x27;, &#x27;microwave&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;oven&#x27;, &#x27;toaster&#x27;, &#x27;sink&#x27;, &#x27;refrigerator&#x27;, &#x27;book&#x27;, &#x27;clock&#x27;, &#x27;vase&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;scissors&#x27;, &#x27;teddy_bear&#x27;, &#x27;hair_drier&#x27;, &#x27;toothbrush&#x27;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;tree&#x27;</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>在<code>mmdet/datasets/coco.py</code>中也要做对应的修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CLASSES = (&#x27;person&#x27;, &#x27;bicycle&#x27;, &#x27;car&#x27;, &#x27;motorcycle&#x27;, &#x27;airplane&#x27;, &#x27;bus&#x27;,</span></span><br><span class="line"><span class="string">          &#x27;train&#x27;, &#x27;truck&#x27;, &#x27;boat&#x27;, &#x27;traffic light&#x27;, &#x27;fire hydrant&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;stop sign&#x27;, &#x27;parking meter&#x27;, &#x27;bench&#x27;, &#x27;bird&#x27;, &#x27;cat&#x27;, &#x27;dog&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;horse&#x27;, &#x27;sheep&#x27;, &#x27;cow&#x27;, &#x27;elephant&#x27;, &#x27;bear&#x27;, &#x27;zebra&#x27;, &#x27;giraffe&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;backpack&#x27;, &#x27;umbrella&#x27;, &#x27;handbag&#x27;, &#x27;tie&#x27;, &#x27;suitcase&#x27;, &#x27;frisbee&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;skis&#x27;, &#x27;snowboard&#x27;, &#x27;sports ball&#x27;, &#x27;kite&#x27;, &#x27;baseball bat&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;baseball glove&#x27;, &#x27;skateboard&#x27;, &#x27;surfboard&#x27;, &#x27;tennis racket&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;bottle&#x27;, &#x27;wine glass&#x27;, &#x27;cup&#x27;, &#x27;fork&#x27;, &#x27;knife&#x27;, &#x27;spoon&#x27;, &#x27;bowl&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;sandwich&#x27;, &#x27;orange&#x27;, &#x27;broccoli&#x27;, &#x27;carrot&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;hot dog&#x27;, &#x27;pizza&#x27;, &#x27;donut&#x27;, &#x27;cake&#x27;, &#x27;chair&#x27;, &#x27;couch&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;potted plant&#x27;, &#x27;bed&#x27;, &#x27;dining table&#x27;, &#x27;toilet&#x27;, &#x27;tv&#x27;, &#x27;laptop&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;mouse&#x27;, &#x27;remote&#x27;, &#x27;keyboard&#x27;, &#x27;cell phone&#x27;, &#x27;microwave&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;oven&#x27;, &#x27;toaster&#x27;, &#x27;sink&#x27;, &#x27;refrigerator&#x27;, &#x27;book&#x27;, &#x27;clock&#x27;,</span></span><br><span class="line"><span class="string">            &#x27;vase&#x27;, &#x27;scissors&#x27;, &#x27;teddy bear&#x27;, &#x27;hair drier&#x27;, &#x27;toothbrush&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">CLASSES = (<span class="string">&#x27;tree&#x27;</span>,)</span><br></pre></td></tr></table></figure><p>完成，然后我们用<code>tool/train.py</code>来生成对应的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py configs&#x2F;faster_rcnn&#x2F;faster_rcnn_r50_fpn_1x_coco.py --work-dir record</span><br></pre></td></tr></table></figure><p><code>--work-dir</code>的意思是指定工作目录，一会儿会在这里生成配置文件，生成配置文件之后，我们可以中断掉，然后在工作目录中找到这个配置文件，做修改之后 (各种微调，比如学习率，训练次数，继续上次的训练文件等) 再运行这个配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools&#x2F;train.py record&#x2F;faster_rcnn_r50_fpn_1x_coco.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OD </tag>
            
            <tag> mmdetection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE3.0：组合式api的引入</title>
      <link href="2021/05/21/vue14/"/>
      <url>2021/05/21/vue14/</url>
      
        <content type="html"><![CDATA[<h2 id="VUE3-0初探"><a href="#VUE3-0初探" class="headerlink" title="VUE3.0初探"></a>VUE3.0初探</h2><p>首先直接创建一个项目，勾选上vuex，router和css预编译</p><p>创建完之后我们发现vue3和vue2的目录结构没有太大的区别，main.js中的内容稍微有一些变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).use(store).use(router).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>而在router/index.js中，之前选的是hash模式，所以显示的是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而这个哈希模式在代码的头部导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure><p>我们只要将导入的模块改为<code>createWebHistory</code>并且将<code>history</code>属性也改为这个就能直接切换成history模式</p><p>而store则基本没有什么变化</p><p>然后我们打开App.vue，发现template里面的内容是这样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>回想一下vue2，在有路由的时候，两者是包含在一个div里面的，因为vue2的模板中只能包含一个元素，但是vue3取消了这个设定</p><p><strong>基本上所有vue2中可以使用的语法在vue3中都可以使用</strong></p><h2 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h2><p>vue3相比于vue2最重要的一个改变就是组合式api的引入，之前vue的模式让我们将数据和方法或者计算属性放在不同的内容里(data，method，computed)，这就会导致一个问题：相关联的数据和方法并不在一块，有的时候甚至相距甚远，为代码阅读和维护造成一些困扰，当然vue2中的混入mixins可以一定程度上缓解这个问题，而vue3中针对这个问题，给出了组合式api作为解决方案</p><h3 id="setup组件选项"><a href="#setup组件选项" class="headerlink" title="setup组件选项"></a>setup组件选项</h3><p>vue3提供的setup组件选项会在创建组件之前执行，充当合成api的入口</p><p>而在setup中我们通常用ref函数来创建响应式变量 (类似于vue2中的data)</p><p>以下是一个使用的小例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;addCounter&quot;</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span>&#123;</span></span><br><span class="line">      counter.value++</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      addCounter,counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有几个注意点</p><ol><li>ref需要从vue解构 <code>import &#123; ref &#125; from &quot;vue&quot;</code></li><li>使用ref创建的变量时，在setup中需要用counter.value，而在模板中可以直接用</li><li>所有需要在模板中使用的方法或者函数需要return出来</li></ol><p>当然这个ref也可以创建字符串，数组等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = ref([])</span><br><span class="line"><span class="keyword">let</span> str = ref(<span class="string">&quot;tmp&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>在setup中还可以使用生命周期钩子</p><p>比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">      counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;渲染完毕&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter,counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个onMounted等价于组件选项mounted，实测onMounted运行时间要遭遇mounted</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">      counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;渲染完毕1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter,counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;渲染完毕2&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余生命周期钩子也可以类似地使用，beforeCreate和created除外，因为vue3认为这两个生命周期钩子和setup的职能重复了，就不需要套娃了，在这两个钩子函数中写的任何代码都应该直接写在setup中</p><p>需要注意的是这些生命周期要从vue中解构</p><h3 id="watch响应式更改"><a href="#watch响应式更改" class="headerlink" title="watch响应式更改"></a>watch响应式更改</h3><p>在setup中我们还可以使用watch，等价于组件选项watch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">      counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    watch(counter,<span class="function">(<span class="params">newvalue,oldvalue</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(oldvalue,newvalue)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter,counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch同样也需要从vue中解构</p><p>以上写法等价于vue2中的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">      counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter, counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  watch:&#123;</span><br><span class="line">    <span class="function"><span class="title">counter</span>(<span class="params">newvalue, oldvalue</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(oldvalue,newvalue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独立的计算属性"><a href="#独立的计算属性" class="headerlink" title="独立的计算属性"></a>独立的计算属性</h3><p>计算属性computed也存在对应的方法，同样也需要从vue中解构才能使用</p><p>直接看例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = ref(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      counter.value++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> doubleCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter,</span><br><span class="line">      counter,</span><br><span class="line">      doubleCounter,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>我们发现因为数据，方法，监听之类的在setup中都可以独立地创建和使用，因此相关联的数据可以很方便地放在一起</p><p>我们还可以将相关的数据封装在一个js中使得看起来更简洁一些</p><p>比如刚才的代码功能，我们可以新建一个<code>counterApi.js</code>文件，实现刚才在setup中写的内容并return，然后将封装函数export出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counterApi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> addCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter.value++;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> doubleCounter = computed(<span class="function">() =&gt;</span> counter.value * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addCounter,</span><br><span class="line">    counter,</span><br><span class="line">    doubleCounter,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterApi</span><br></pre></td></tr></table></figure><p>就可以在组件中这么去使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> counterApi <span class="keyword">from</span> <span class="string">&#x27;./counterApi&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; addCounter, counter, doubleCounter &#125; = counterApi();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      addCounter,</span><br><span class="line">      counter,</span><br><span class="line">      doubleCounter,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就允许我们更清晰地分块去撰写代码，比如这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; addCounter, counter, doubleCounter &#125; = counterApi();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; showImg, img &#125; = imgApi();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">  addCounter,</span><br><span class="line">  counter,</span><br><span class="line">  doubleCounter,</span><br><span class="line">  showImg,</span><br><span class="line">  img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm，说白了，其实这就是一个写得更爽一点的升级版的mixin</p><h3 id="setup的参数"><a href="#setup的参数" class="headerlink" title="setup的参数"></a>setup的参数</h3><h4 id="props参数"><a href="#props参数" class="headerlink" title="props参数"></a>props参数</h4><p>在vue2中我们如果需要在组件标签中传入属性，则需要使用组件选项props</p><p>比如我们写一个HelloWorld组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    msg: <span class="built_in">String</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在about页面去使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;你好&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;About&#x27;</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们就能把这个<code>你好</code>传到HelloWorld组件的props中</p><p>如果我们要对这个msg进行一定的操作，则可以在methods或者computed里面通过this.msg来使用这个参数，比方说我们写一个字符串翻转的函数然后显示出来，就可以对HelloWorld进行如下更改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">+    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    msg: <span class="built_in">String</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">+  computed:&#123;</span><br><span class="line"><span class="javascript">+    reverseMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span><br><span class="line">+  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果我们在使用vue3提供的setup时，内部是不允许使用this的，输出this会发现直接就是undefined，那么如果想要使用props，则需要通过参数引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    msg: <span class="built_in">String</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reverseMsg = ref(props.msg.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>));</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123; reverseMsg &#125;;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="props解构"><a href="#props解构" class="headerlink" title="props解构"></a>props解构</h5><p>props是一个响应式参数，所以不能够直接通过es6的方法来解构，需要通过toRefs来将数据解构出来，解构之后的数据是ref格式的，所以要直接使用数据，则需要通过<code>.value</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// toRefs也需要导入</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;HelloWorld&quot;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    msg: <span class="built_in">String</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> &#123; msg &#125; = toRefs(props);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 解构的msg是ref格式，需要用msg.value来获取其值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reverseMsg = ref(msg.value.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>));</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123; reverseMsg &#125;;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="context参数"><a href="#context参数" class="headerlink" title="context参数"></a>context参数</h4><p>setup还有第二个参数context</p><p>context中主要包含了三块内容，attrs, slots和emit</p><p>你可以这样去使用context</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接在参数里解构它 (根据需要将内容写在大括号里)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line">    <span class="built_in">console</span>.log(context.slots)</span><br><span class="line">    <span class="built_in">console</span>.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h5><p>context中的attrs用于获取上下文信息，即props未接收的非响应式对象</p><p>比方说，在刚才那个about页面，我们这样使用这个HelloWorld组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;你好&quot;</span> <span class="attr">msg2</span>=<span class="string">&quot;你好呀&quot;</span> <span class="attr">msg3</span>=<span class="string">&quot;nice to meet you&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>msg属性显然被props接收了，但是这个msg2和msg3并没有，而我们可以在attrs中得到这个msg2和msg3</p><p>我们输出这个attrs，可以看到</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue14-1.png"></p><p>也就是我们可以通过msg.attrs.msg2来得到这个<code>你好呀</code></p><p>所有被props遗弃的小朋友都被attrs接受了</p><h5 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h5><p>之前我们在使用vue2的时候子组件向父组件传值是使用this.$emit的</p><button onclick="window.location.href = 'https://forever97.top/2021/04/15/vue6/#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC' " style="background-color:orange; color: #fff; width:100px; height:30px">传送门</button><br/><p>但是刚也说过，在setup中this是被禁用的</p><p>所以我们直接用context中解构出的emit来实现传值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit &#125;</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(slots);</span><br><span class="line">  <span class="keyword">let</span> &#123; msg &#125; = toRefs(props);</span><br><span class="line">  <span class="keyword">let</span> reverseMsg = ref(msg.value.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">+  emit(<span class="string">&quot;childEvent&quot;</span>, <span class="string">&quot;往父组件发送的信息&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; reverseMsg &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> childFn = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123; childFn &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在组件标签中将childFn绑到childEvent事件上就可以通过emit触发</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">  &lt;HelloWorld</span><br><span class="line">    msg=&quot;你好&quot;</span><br><span class="line">    msg2=&quot;你好呀&quot;</span><br><span class="line">    msg3=&quot;nice to meet you&quot;</span><br><span class="line">    @childEvent=&quot;childFn&quot;</span><br><span class="line">    &gt;你好世界&lt;/HelloWorld</span><br><span class="line">  &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h3><p>我们通过ref可以创建一个响应式的变量，但是当这个变量是一个对象，里面的内容并非响应式，也就是说，如果我们有一个变量是一个书架对象，书架上有很多书，如果我们替换了某本书，是不会触发书架的改变，除非我们换了书架(对象地址改变)，而响应式对象的意思就是这个对象中任意属性的改变都会使得对象发生对应的更新</p><p>响应式对象的创建方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bookshelf = reactive(&#123;</span><br><span class="line">  book1: <span class="string">&quot;哈利波特与死亡圣器&quot;</span>,</span><br><span class="line">  book2: <span class="string">&quot;哈利波特与火焰杯&quot;</span>,</span><br><span class="line">  book3: <span class="string">&quot;哈利波特与魔法石&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="提供与注入"><a href="#提供与注入" class="headerlink" title="提供与注入"></a>提供与注入</h3><p>provide/inject可以使得后代组件更方便地使用父组件的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;provide&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    provide:&#123;</span><br><span class="line">        nation: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">        addr:<span class="string">&quot;地球&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;inject&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    inject:[<span class="string">&#x27;nation&#x27;</span>,<span class="string">&#x27;addr&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后代组件的意思是不仅子组件可以使用，子组件的子组件也可以这样获取父组件提供的信息，无论组件的深度有多深</p><p>在setup中也可以实现提供和注入，方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;provide&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// key value</span></span><br><span class="line">  provide(<span class="string">&quot;国籍&quot;</span>, <span class="string">&quot;中国&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;inject&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = inject(<span class="string">&quot;国籍&quot;</span>) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由api"><a href="#路由api" class="headerlink" title="路由api"></a>路由api</h3><p>直接看示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRouter,useRoute&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> router = useRouter()</span><br><span class="line">    <span class="keyword">const</span> route = unRoute()</span><br><span class="line">    <span class="comment">// 使用时直接@click即可</span></span><br><span class="line">    <span class="keyword">let</span> gohome = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(route)</span><br><span class="line">      router.push(<span class="string">&quot;/?username=123&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;gohome&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vuex使用"><a href="#vuex使用" class="headerlink" title="vuex使用"></a>vuex使用</h3><p>和路由类似，对应vuex，vue3则是使用useStore来避免了使用this的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useStore&#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> store = useStore()</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      description: computed(<span class="function">()=&gt;</span>store.state.description), </span><br><span class="line">      changeFn:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;setDes&#x27;</span>,<span class="string">&quot;发送的信息&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：混入</title>
      <link href="2021/05/16/vue13/"/>
      <url>2021/05/16/vue13/</url>
      
        <content type="html"><![CDATA[<p>vue混入比较简单，但是在vue2做大一点的项目的时候还是比较重要的技巧，所以还是记录一下</p><p>混入<code>mixins</code>可以在组件中导入别的js文件中export出来的东西</p><p>举个例子，比如说有个外卖的app，把食物商品相关的信息和方法都写在了food.js中，把配送相关的信息和方法都写在了trans.js中，那么我们就可以直接在需要用到这两部分内容的组件中混入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> food <span class="keyword">from</span> <span class="string">&#x27;@/mixin/food&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> trans <span class="keyword">from</span> <span class="string">&#x27;@/mixin/trans&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;Home&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      msg: <span class="string">&quot;hello&quot;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mixins: [food, trans]</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而在food.js或者trans.js中书写的格式和普通的组件中export的内容相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// food.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入等价于将这些js中的内容直接写在组件中，所以如果有同名字的数据，本质上是同一份，并且<strong>写在当前组件中的优先级比较高</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：过滤</title>
      <link href="2021/05/16/vue12/"/>
      <url>2021/05/16/vue12/</url>
      
        <content type="html"><![CDATA[<h2 id="过滤与方法"><a href="#过滤与方法" class="headerlink" title="过滤与方法"></a>过滤与方法</h2><p>首先我们写一个普通的方法，一会儿我们用过滤来实现可以比较一下差别</p><p>比如说我们要实现一个把数字转化成价格显示的功能，methods实现如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      ￥&#123;&#123;changePrice(price)&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      price: 12684000000,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    changePrice: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> strPrice = <span class="built_in">String</span>(price);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> strPrice.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而用过滤filters实现如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      ￥&#123;&#123;price|changePrice&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      price: 12684000000,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line"><span class="javascript">    changePrice: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> strPrice = <span class="built_in">String</span>(price);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> strPrice.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到过滤和方法中实现的函数其实是相同的，没有什么区别，只有在使用上的差别</p><p>过滤的方式<code>&#123;&#123;price|changePrice&#125;&#125;</code>更直观简洁 </p><h2 id="过滤的参数"><a href="#过滤的参数" class="headerlink" title="过滤的参数"></a>过滤的参数</h2><p>过滤的本质，是让表达式的第一个参数默认成为函数的第一个参数，所以其实有两个参数的函数也可以用过滤的方式来实现，比如说我们对给刚才的函数增加一个先加一个数字然后转化为价格的功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      price: 12684000000,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line"><span class="javascript">    changePrice: <span class="function"><span class="keyword">function</span> (<span class="params">price, addval</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> strPrice = <span class="built_in">String</span>(price + addval);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> strPrice.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用时，只要从第二个参数开始在括号内添加即可 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      ￥&#123;&#123;price|changePrice(100)&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="过滤的级联"><a href="#过滤的级联" class="headerlink" title="过滤的级联"></a>过滤的级联</h2><p>vue的filters支持级联，比如我们本来想要嵌套两个函数<code>&#123;&#123;changePrice(add(price,100))&#125;&#125;</code>，用filters只需要这么写<code>&#123;&#123;price|add(100)|changePrice&#125;&#125;</code></p><p>具体例子如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>￥&#123;&#123; price | add(100) |changePrice &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      price: 12684000000,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  filters: &#123;</span><br><span class="line"><span class="javascript">    changePrice: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> strPrice = <span class="built_in">String</span>(price);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> strPrice.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    add: <span class="function"><span class="keyword">function</span> (<span class="params">price, addval</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> price + addval;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>如果一个过滤器使用的特别频繁，我们可以在main.js中全局注册，在所有组件和页面中直接使用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">&quot;changePrice&quot;</span>, <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strPrice = <span class="built_in">String</span>(price);</span><br><span class="line">    <span class="keyword">return</span> strPrice.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&quot;$1,&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">&quot;add&quot;</span>, <span class="function">(<span class="params">price, addVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price + addVal</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegExp总结</title>
      <link href="2021/05/12/regexp/"/>
      <url>2021/05/12/regexp/</url>
      
        <content type="html"><![CDATA[<h2 id="RegExp简介"><a href="#RegExp简介" class="headerlink" title="RegExp简介"></a>RegExp简介</h2><p>正则表达式 (Regular Expression)，用于匹配特定模式字符串的模板串</p><p>先从最简单的创建和测试开始 (以下内容基于js语言)</p><h3 id="RegExp创建"><a href="#RegExp创建" class="headerlink" title="RegExp创建"></a>RegExp创建</h3><p>RegExp在js中有两种创建方式，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数创建法</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line"><span class="comment">// 字面量创建法</span></span><br><span class="line"><span class="keyword">let</span> regexp2 = <span class="regexp">/xxx/</span></span><br></pre></td></tr></table></figure><h3 id="RegExp测试"><a href="#RegExp测试" class="headerlink" title="RegExp测试"></a>RegExp测试</h3><p>正则表达式本身存在test方法，可以用来<strong>判断字符串参数和该表达式是否匹配</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/hello/</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br></pre></td></tr></table></figure><p>上述代码返回的就是true，表示测试字符串中包含了hello</p><h2 id="RegExp构成"><a href="#RegExp构成" class="headerlink" title="RegExp构成"></a>RegExp构成</h2><p>RegExp由普通字符和特殊字符组成，普通字符即描述自身的字符，而特殊字符赋予RegExp更多的功能，下面主要介绍各种特殊字符的功能</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>边界符指<code>^</code>符号和<code>$</code>符号</p><p><code>^</code>符号放在RegExp的开头，表示匹配字符串前缀，比如<code>\^hello\</code>表示匹配以<code>hello</code>为开头的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/^hello/</span></span><br><span class="line"><span class="comment">// 结果为true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br><span class="line"><span class="comment">// 结果为false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hhhelloworld&quot;</span>))</span><br></pre></td></tr></table></figure><p><code>$</code>符号放在RegExp的结尾，表示匹配字符串后缀，比如<code>\world$\</code>表示匹配以<code>world</code>为结尾的字符串，例子和<code>^</code>相似就不举了</p><p>当<code>^</code>和<code>$</code>同时使用的时候表示精准匹配，即只能成功匹配被两个符号包裹的部分</p><h3 id="字符选择"><a href="#字符选择" class="headerlink" title="字符选择"></a>字符选择</h3><p><code>[]</code>在RegExp中表示字符选择，被方括号包裹的字符是<code>或</code>的关系，在匹配的时候只要满足匹配其中一个即可</p><p>比如<code>\[abc]\</code>可以匹配包含abc三个字符中任意一个字符的字符串，下面我写了一个匹配hallo，hbllo或者hcllo的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/h[abc]llo/</span></span><br><span class="line"><span class="comment">// 返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br><span class="line"><span class="comment">// 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;halloworld&quot;</span>))</span><br></pre></td></tr></table></figure><p>在方括号中，可以使用<code>-</code>符号来表示字符组合，当可供选择的字符是连续的时候，就可以用<code>-</code>连接首尾字符来更方便地使用，举个例子会更容易理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/h[a-z1-9]llo/</span></span><br><span class="line"><span class="comment">// 以下匹配结果均为true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hblloworld&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;h9lloworld&quot;</span>))</span><br></pre></td></tr></table></figure><p>有时候我们还会碰到一些特殊情况，不想匹配的内容是少数，针对这个情况，RegExp还提供了取反，用<code>[^]</code>来表示取反</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/h[^a-z1-9]llo/</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hblloworld&quot;</span>))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hElloworld&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>RegExp中有多种量词符，列表如下</p><table><thead><tr><th>量词</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>重复0次或更多次</td></tr><tr><td>+</td><td>重复1次或更多次</td></tr><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/h&#123;2,5&#125;ello/</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;helloworld&quot;</span>))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hhelloworld&quot;</span>))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hhhhelloworld&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>元字符就是有特殊功能的字符，具体见下表，自己意会</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>单个字符，除了换行和行结束符</td></tr><tr><td>\w</td><td>字母字符</td></tr><tr><td>\W</td><td>非字母字符</td></tr><tr><td>\d</td><td>数字字符</td></tr><tr><td>\D</td><td>非数字字符</td></tr><tr><td>\s</td><td>查找空白字符</td></tr><tr><td>\S</td><td>查找非空白字符</td></tr><tr><td>\b</td><td>单词边界</td></tr><tr><td>\B</td><td>非单词边界</td></tr><tr><td>\0</td><td>NULL字符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\t</td><td>查找制表符</td></tr><tr><td>\v</td><td>查找垂直制表符</td></tr><tr><td>\xxx</td><td>查找以八进制数 xxxx 规定的字符</td></tr><tr><td>\xdd</td><td>查找以十六进制数 dd 规定的字符</td></tr><tr><td>\uxxxx</td><td>查找以十六进制 xxxx规定的 Unicode 字符</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>在正则表达式中所有有特殊含义的字符在匹配本身的时候都需要转义</p><p>比如说匹配左括号要用<code>\(</code></p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><code>|</code>在RegExp中表示选择，一般和表示优先级的小括号搭配使用，否则会因为<strong>出现歧义而导致可匹配范围的扩大</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(hello|world)/</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hellowrld&quot;</span>))</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hheloorld&quot;</span>))</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(<span class="string">&quot;hhhhElloworld&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="附加参数"><a href="#附加参数" class="headerlink" title="附加参数"></a>附加参数</h3><p>在匹配的时候我们可以对正则表达式附加参数</p><p>比如我们对于两种创建正则表达式的方式附加参数i的写法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数创建法</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;i&quot;</span>)</span><br><span class="line"><span class="comment">// 字面量创建法</span></span><br><span class="line"><span class="keyword">let</span> regexp2 = <span class="regexp">/xxx/i</span></span><br></pre></td></tr></table></figure><p>附加这个参数i表示忽略大小写，以下给出附加参数表</p><table><thead><tr><th>附加参数</th><th>含义</th></tr></thead><tbody><tr><td>i (ignoreCase)</td><td>忽略大小写匹配</td></tr><tr><td>m (multiline)</td><td>可以进行多行匹配</td></tr><tr><td>g (global)</td><td>全局匹配</td></tr><tr><td>u (Unicode)</td><td>用来正确处理大于\uFFF 的 Unicode 字符</td></tr><tr><td>y (sticky)</td><td>粘连</td></tr><tr><td>s (dotAll)</td><td>让’.’能匹配任意字符，包含\n\r</td></tr></tbody></table><p>最常使用的就是igs</p><h2 id="RegExp匹配"><a href="#RegExp匹配" class="headerlink" title="RegExp匹配"></a>RegExp匹配</h2><p>接下来是RegExp最重要的功能，匹配，之前的test测试只能判断一个字符串是否满足正则表达式，而匹配，则是在字符串中捕获需要的内容</p><p>匹配有两种方法，match和exec</p><h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>match是字符串带有的方法，具体用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/hello|world/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hellowrld&quot;</span> </span><br><span class="line"><span class="built_in">console</span>.log(str.match(regexp))</span><br></pre></td></tr></table></figure><p>会得到这样的一个数组</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-2.png"></p><p>在匹配中，我们用括号包裹我们需要捕获的内容，比如说我们要捕获aa和bb中间夹杂的字符串，则可以这么写 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*)bb/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aahellobbwrldhelloworldhello&quot;</span> </span><br><span class="line"><span class="built_in">console</span>.log(str.match(regexp))</span><br></pre></td></tr></table></figure><p>就可以得到这样一个数组，数组的第一个位置存放完整匹配的内容，而第二个位置存放我们希望捕获的内容</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-3.png"></p><p>当然我们可以有多个要求捕获的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*)bb(.*)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aahellobbwrldhelloworldhello&quot;</span> </span><br><span class="line"><span class="built_in">console</span>.log(str.match(regexp))</span><br></pre></td></tr></table></figure><p>得到数组如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-4.png"></p><h3 id="exec方法"><a href="#exec方法" class="headerlink" title="exec方法"></a>exec方法</h3><p>exec是正则表达式的方法，使用方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*)bb(.*)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aahellobbwrldhelloworldhello&quot;</span> </span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><h3 id="惰性匹配与贪婪匹配"><a href="#惰性匹配与贪婪匹配" class="headerlink" title="惰性匹配与贪婪匹配"></a>惰性匹配与贪婪匹配</h3><p>在不做限定的情况下，正则表达式的匹配是贪婪的，就是在满足条件的情况下匹配最远(长)的字符串，比如说我上边写的那个<code>/aa(.*)bb/</code>，当出现多个<code>bb</code>的时候，会匹配到最后一个<code>bb</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;aa(.*)bb&quot;</span>,<span class="string">&quot;i&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;AA1bb2aa3bb&quot;</span></span><br><span class="line"><span class="comment">// AA1bb2aa3bb</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><p>如果我们想要匹配到第一个<code>bb</code>，则需要采用惰性匹配规则，在要<strong>捕获</strong>的内容后边添加<code>?</code>字符，例子见下方代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;aa(.*?)bb&quot;</span>,<span class="string">&quot;i&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;AA1bb2aa3bb&quot;</span></span><br><span class="line"><span class="comment">// AA1bb</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>正则表达式中的分组我们在上文就已经提到过，即用<code>()</code>符号框住我们想要捕获的内容(会出现在捕获数组中)或者提升优先级</p><p>这里额外补充其两个功能：可以分组引用和分组具名化</p><h4 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h4><p>分组引用允许我们将分组捕获到的内容重复到其它地方，比如下方代码的意思就是在第二个分组匹配任意长度后匹配第一个分组捕获到的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*?)bb(.*\1)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><p><code>\1</code>表示第一个分组，<code>\2</code>表示第二个分组…</p><h4 id="分组具名化"><a href="#分组具名化" class="headerlink" title="分组具名化"></a>分组具名化</h4><p>分组具名化的意思就是，给分组取个名字方便我们使用，在分组中用<code>?&lt;名字&gt;</code>格式来具名化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(?&lt;第一部分&gt;.*?)bb(&lt;第二部分&gt;.*)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><p>可以得到一个group对象</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-5.png"></p><h3 id="全局捕获"><a href="#全局捕获" class="headerlink" title="全局捕获"></a>全局捕获</h3><p>我们给正则表达式添加附加参数g就表示全局匹配，下面来看看全局匹配的效果</p><p>先来看看match方法 (这里要采用惰性匹配，否则第一个直接匹配到了结尾)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*?)bb/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(regexp))</span><br></pre></td></tr></table></figure><p>我们发现得到了这样一个数组，数组里面是匹配到的内容</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-6.png"></p><p>但是<strong>失去了捕获功能</strong></p><p>再来看看exec</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*?)bb/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-7.png"></p><p>捕获功能还是，但是…好像没有全局匹配的样子</p><p>exec是属于正则表达式的方法，正则表达式有一个属性lastIndex，表示当前正则下一次匹配的起始索引位置，而全局匹配参数g会在每次exec方法调用后更改lastIndex</p><p>比方说，我们多调用几次，并输出这个lastIndex</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(.*?)bb/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.lastIndex, regexp.exec(str))</span><br><span class="line"><span class="built_in">console</span>.log(regexp.lastIndex, regexp.exec(str))</span><br><span class="line"><span class="built_in">console</span>.log(regexp.lastIndex, regexp.exec(str))</span><br><span class="line"><span class="built_in">console</span>.log(regexp.lastIndex, regexp.exec(str))</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/regexp-8.png"></p><p>我们会发现它会一截一截匹配过去，直到找不到为止，然后重头开始匹配</p><p>所以我们可以通过在循环中使用exec来完成全局捕获，大概像下面的代码这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultArr = []</span><br><span class="line"><span class="keyword">while</span>(result = reg.exec(str))&#123;</span><br><span class="line">    resultArr.push(&#123;</span><br><span class="line">        info1: result[<span class="number">1</span>],</span><br><span class="line">        info2: result[<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><p>我们可以为匹配附加条件，来满足一些特殊的要求</p><h4 id="只匹配不捕获"><a href="#只匹配不捕获" class="headerlink" title="只匹配不捕获"></a>只匹配不捕获</h4><p>在分组开头加上<code>?:</code>表示这个分组只匹配不捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/aa(?:)bb/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str))</span><br></pre></td></tr></table></figure><h4 id="正向预查"><a href="#正向预查" class="headerlink" title="正向预查"></a>正向预查</h4><p>正向预查符号为<code>?=</code>，<code>/aa(?=bb)/</code>表示匹配后面紧跟着bb的aa</p><p>比如我们想捕获<code>1b</code>字符串前面一个字符我们可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(.)(?=1b)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="反向预查"><a href="#反向预查" class="headerlink" title="反向预查"></a>反向预查</h4><p><code>/(?&lt;=aa)bb/</code>表示匹配前面紧贴着aa的bb</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(?&lt;=1b)(.)/</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aa1bb21aa3bb4&quot;</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.exec(str)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p><code>(?!)</code>类似正向预查，只是除括号内内容外均可匹配，等同于找到所有后面不是xxx的内容</p><p><code>(?&lt;!)</code>同理，类似反向预备</p><h2 id="RegExp与字符串处理的结合"><a href="#RegExp与字符串处理的结合" class="headerlink" title="RegExp与字符串处理的结合"></a>RegExp与字符串处理的结合</h2><h3 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h3><p>使用方法如下，可以按照正则表达式匹配到的内容分割</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(regexp)</span><br></pre></td></tr></table></figure><h3 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h3><p><code>str.replace(reg, str1)</code>可以将匹配到正则表达式的字符串内容替换为str1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;2021-05-16&#x27;</span></span><br><span class="line">str = str.replace(<span class="regexp">/-/g</span>,<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure><p>当然上述的str1还可以换成函数，参数为捕获到的内容，返回值为替换后的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;2021-05-16&quot;</span></span><br><span class="line">str = str.replace(<span class="regexp">/\d/g</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(args[<span class="number">0</span>])+<span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3132-16-27</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>先写到这里，空了再补充例子</p>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex：Vue的状态管理模式</title>
      <link href="2021/05/04/vuex/"/>
      <url>2021/05/04/vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="Devtools安装"><a href="#Devtools安装" class="headerlink" title="Devtools安装"></a>Devtools安装</h2><p>在使用vuex之前，我们先来安装一个vue开发工具，vue.js devtools，这是vue的官方调试工具，vuex也集成在其中</p><p>谷歌浏览器 -&gt; 更多工具 -&gt; 扩展程序 -&gt; 打开谷歌网上应用店 -&gt; 搜索vue.js devtools -&gt; 添加到chrome</p><p>以上步骤需要科学上网</p><p>添加完这个插件之后，创建一个vue项目，勾选上vuex，我们就可以在调试控制台中看到这个插件的效果了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vuex-2.png"></p><p>可以在调试控制台的导航栏选择vue，然后选择vuex，当然现在这里看不到什么东西，因为我们没有添加什么状态管理</p><p>vue.js devtools在谷歌商店里有两个，安装人多那个更好看，功能也更多一点，建议选那个</p><h2 id="Vuex简单使用"><a href="#Vuex简单使用" class="headerlink" title="Vuex简单使用"></a>Vuex简单使用</h2><p>创建完vue工程后，我们可以看到勾选了vuex之后，src文件夹里面多了一个store文件夹，里面有个js文件，内含代码如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中state是用来存放数据的地方，mutations和actions用于存放管理数据的方法，分别用于管理同步修改和异步修改，modules则是用来将store划分模块，每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块来避免单一状态树变得过于臃肿</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>我们先来简单地使用一下state，在里面创建一个msg</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        msg: <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们就能在devtools里面看到这个</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vuex-4.png"></p><p>在其它的组件里面我们可以很方便地使用这个公共数据 (通过$store.state)</p><p>比如我们在home页面中写入如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;$store.state.msg&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就可以直接使用这个数据</p><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>getters是vuex中的计算属性 (和vue中的computed相同)，我们来做一个简单的使用测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        msg: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">        scores: [<span class="number">12</span>, <span class="number">59</span>, <span class="number">89</span>, <span class="number">92</span>, <span class="number">42</span>, <span class="number">99</span>, <span class="number">91</span>, <span class="number">76</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        highScore:<span class="function"><span class="keyword">function</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state.scores.filter(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;=<span class="number">80</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件中可以通过<code>$store.getters.highScore</code>来使用它</p><h3 id="映射辅助函数"><a href="#映射辅助函数" class="headerlink" title="映射辅助函数"></a>映射辅助函数</h3><p>前面我们举了使用state和getters的两个例子，可以看到，想要在组件中使用vuex管理的内容要写的属性名特别的长 (比如<code>$store.getters.highScore</code>)</p><p>这里我们可以利用mapState来做映射使得使用更方便，比如说我们要使用<code>$store.state.msg</code>和<code>$store.state.scores</code>，可以这么写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;msg&#125;&#125;&#123;&#123;scores&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;Home&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    computed: mapState([<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;scores&#x27;</span>])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以跟其它的计算属性一起使用 (析构来去掉外边的括号)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;scores&#x27;</span>]),</span><br><span class="line">    three: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.one + <span class="built_in">this</span>.two</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望把传过来的msg变量改个名字，则可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        msg123: <span class="function"><span class="keyword">function</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state.msg</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 简写</span></span><br><span class="line">        msg111: <span class="function"><span class="params">state</span>=&gt;</span>state.msg</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，对于getters也有mapGetters</p><p>使用方法不能说是毫无关系，只能说是一摸一样了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">// 采用原名</span></span><br><span class="line">    ...mapGetters([<span class="string">&#x27;lowerScore&#x27;</span>, <span class="string">&#x27;higherScore&#x27;</span>])</span><br><span class="line">    <span class="comment">// 自命名</span></span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">        lsscore: <span class="string">&#x27;lowerScore&#x27;</span>,</span><br><span class="line">        hscore: <span class="string">&#x27;higherScore&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>vuex的store中的状态只能通过<strong>提交mutation</strong>的方式更改，mutation中的方法默认接受state作为第一个参数</p><p>举个例子，我们想要通过点击一个按钮修改scores中的值</p><p>我们在store中写一个change函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    change:<span class="function"><span class="keyword">function</span>(<span class="params">state, pos</span>)</span>&#123;</span><br><span class="line">        state.scores[pos] = <span class="number">0</span></span><br><span class="line">        state.scores.shift()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在组件中通过commit来传参和执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    click:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&quot;change&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，映射可以让mutations的使用也更为简单，使用方法和之前的非常相似，需要引入mapMutations</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        click: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以直接使用这个click</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">click(2)</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>我们之前提到过Actions可以异步修改数据，但是实际上，它提交的是mutation，而不是直接修改状态，但是它允许任何异步操作，一般用于做ajax请求等，在组件中用<code>this.$store.dispatch</code>来提交，action也可以使用映射，需要引入<code>mapActions</code>，使用方法同mapMutations</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>modules就是一个为了让状态树看起来不那么臃肿的功能，比如我可以嵌套两个子module</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后分别去写那两个modules，功能和之前简绍的vuex的store内容相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用时通过<code>$store.state.a</code>和<code>$store.state.b</code>来获取两个store分块的信息</p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Less使用小记</title>
      <link href="2021/04/28/less/"/>
      <url>2021/04/28/less/</url>
      
        <content type="html"><![CDATA[<h2 id="简单使用方式"><a href="#简单使用方式" class="headerlink" title="简单使用方式"></a>简单使用方式</h2><p>首先介绍一下less，less是一种css预编译语言，说白了就是，写起来更方便，编译一下变成了可以正常使用的css的一种语言</p><p>ok，直接开始，现在全局装一个less</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less -g</span><br></pre></td></tr></table></figure><p>然后可以创建一个.less为后缀的文件直接开始写，编译指令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc styles.less styles.css</span><br></pre></td></tr></table></figure><p>用写好的<code>styles.less</code>文件，编译生成<code>styles.css</code></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>less允许使用变量，比css中的var要方便一些，以下展示一个例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="number">75px</span>;</span><br><span class="line"><span class="variable">@width:</span> <span class="variable">@height</span>*<span class="number">2</span>;</span><br><span class="line"><span class="variable">@themeColor:</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">@themeColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量定义允许加减乘除运算，编译之后就能直接生成css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>混合允许直接copy一个类的属性，比如我们在上面这个例子下面继续写如下代码</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.spc-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.button</span>();</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以多生成一个类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.spc-btn</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，copy所有的属性之后自己可以继续加属性，使用的时候最好不要重写相同属性，否则css文件会出现冗余</p><p>按照以下方式来写更好一些</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望在生成css的时候没有btn这个类，则可以按照如下方式来写，在仅用于继承属性的类名后加一个括号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>()&#123;</span><br><span class="line">    <span class="attribute">width</span>: @width;</span><br><span class="line">    <span class="attribute">height</span>: @height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span>&#123;</span><br><span class="line">    .btn();</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">orange</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red-btn</span>&#123;</span><br><span class="line">    .btn();</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如果希望直接对模板属性进行更改覆盖，则可以使用函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>(<span class="variable">@bgColor</span>:pink)&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">@height</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">@bgColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>(orange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会生成多余的同名属性，还可以使用默认值</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>在原先的css中，我们如果需要改某个标签或类内的元素属性，需要写多级css选择来精确地赋予属性，less则是通过嵌套来更方便地书写</p><p>比如我们想在刚才那个orange-btn标签中写一个a标签，那么我们可以用less这么写</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.orange-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后生成的css如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.orange-btn</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在嵌套中<code>&amp;</code>符号表示当前选择器的父级，我们可以用如下方式给<strong>a标签</strong>添加更多效果</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.orange-btn</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">            <span class="attribute">color</span>: orange;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">            <span class="attribute">color</span>: black;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的css如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.orange-btn</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.orange-btn</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套的内容，先在本身寻找变量和混合，如果无法找到，则从父级作用域继承</strong></p><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>当用@规则进行嵌套时，会发生冒泡，这个说明很抽象，直接举个例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.spc-button</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="keyword">@media</span>(<span class="attribute">min-width</span>:<span class="number">768px</span>)&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span>(<span class="attribute">min-width</span>:<span class="number">1280px</span>)&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后可以生成一个响应式的按钮，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.spc-button</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">1280px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.spc-button</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>直接上例子，类似于宏定义，<code>~&#39;anything&#39;</code>形式可以按照原样输出</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@min768:</span> <span class="string">~&quot;(min-width: 768px)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.spc-button</span>&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>();</span><br><span class="line">    <span class="keyword">@media</span> <span class="variable">@min768</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span>(<span class="attribute">min-width</span>:<span class="number">1280px</span>)&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入与注释"><a href="#导入与注释" class="headerlink" title="导入与注释"></a>导入与注释</h2><p>导入 (css和less均可)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;library&quot;</span>; </span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;typo.css&quot;</span>;</span><br></pre></td></tr></table></figure><p>注释 (支持行注释和块注释)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">块注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><div class="tag link"><a class="link-card" title="less函数手册" href="https://less.bootcss.com/functions/"><div class="left"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/less-1.png"/></div><div class="right"><p class="text">less函数手册</p><p class="url">https://less.bootcss.com/functions/</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> 🌺CSS花市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：路由 and more</title>
      <link href="2021/04/26/vue11/"/>
      <url>2021/04/26/vue11/</url>
      
        <content type="html"><![CDATA[<p>之前已经了解了VUE中路由的原理和使用，现在来解锁更多的路由使用方式</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由的意思就是用同一个组件接受不同的信息来展示不同的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in hotmodel&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.productId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/wap/product/&#x27;+item.productId&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/wap/product/:id&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;product&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Product.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在子组件内可以通过<code>$route.params.id</code>来获取这个参数</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>路由中还可以增加子路由，格式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">&quot;/course&quot;</span>,</span><br><span class="line">    name:<span class="string">&quot;course&quot;</span>,</span><br><span class="line">    component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../views/Course.vue&quot;</span>),</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">&quot;java&quot;</span>,</span><br><span class="line">            component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../components/Java.vue&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">&quot;python&quot;</span>,</span><br><span class="line">            component:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;../components/Python.vue&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>路由的导航可以不用router-link，而是用js来路由</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fn&quot;</span>&gt;</span>跳转到java页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line">        <span class="comment">// push得到的新页面允许后退到当前页面</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/course/java&#x27;</span>)</span><br><span class="line">        <span class="comment">// replace替换页面，不可后退到当前页面</span></span><br><span class="line">        <span class="comment">// this.$router.replace(&#x27;/course/java&#x27;)</span></span><br><span class="line">        <span class="comment">// 页面后退</span></span><br><span class="line">        <span class="comment">// this.$router.back()</span></span><br><span class="line">        <span class="comment">// 页面前进</span></span><br><span class="line">        <span class="comment">// this.$router.foward()</span></span><br><span class="line">        <span class="comment">// go方式</span></span><br><span class="line">        <span class="comment">// 前进两个页面</span></span><br><span class="line">        <span class="comment">// this.$router.go(2)</span></span><br><span class="line">        <span class="comment">// 后退三个页面</span></span><br><span class="line">        <span class="comment">// this.$router.go(-3)</span></span><br><span class="line">        <span class="comment">// 根据名字跳转 (就是写在js里面的名字)</span></span><br><span class="line">        <span class="comment">// this.$router.push(&#123;name:&quot;java&quot;&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过params传递参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$router.push(&#123;name:&#x27;java&#x27;,params&#123;id:&#x27;123&#x27;&#125;&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过query传递参数: 地址会多出?search=搜索内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$router.push(&#123;name:&#x27;java&#x27;,query&#123;search:&#x27;搜索内容&#x27;&#125;&#125;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>用于同级展示多个视图，每个视图用一个组件来渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view one&quot;</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view menu&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view three&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">    name:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">    components:&#123;</span><br><span class="line">        defaults:<span class="function">()=&gt;</span><span class="keyword">import</span>(../components/Menu.vue),</span><br><span class="line">        header:<span class="function">()=&gt;</span><span class="keyword">import</span>(../components/Newsheader.vue)</span><br><span class="line">        content:<span class="function">()=&gt;</span><span class="keyword">import</span>(../components/Newscontent.vue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中如果router-view没有name属性，则默认为default，特别注意上述js代码中是<code>components</code></p><h2 id="重定向与别名"><a href="#重定向与别名" class="headerlink" title="重定向与别名"></a>重定向与别名</h2><p>重定向的意思就是，用户访问<code>/a</code>的时候，URL会被替换为<code>/b</code>，匹配路由为<code>/b</code>，就比如你的导航页面被劫持了，打开浏览器的首页被重定向到了一个奇奇怪怪的导航页面，而别名的意思就是URL没有替换，但是同样都可以访问到<code>/a</code>，就是URL是<code>/b</code>的时候，显示的也是<code>/a</code>的页面内容</p><p>以下是三种重定向(redirect)方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据后缀地址重定向</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;/course&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;course&quot;</span>,</span><br><span class="line">    redirect: <span class="string">&quot;/course/java&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据页面名重定向</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;/course&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;course&quot;</span>,</span><br><span class="line">    redirect: &#123;<span class="attr">name</span>:<span class="string">&quot;java&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数重定向</span></span><br><span class="line">&#123;</span><br><span class="line">    path:<span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    redirect:<span class="function">()=&gt;</span><span class="string">`/user/<span class="subst">$&#123;<span class="built_in">localStorage</span>.userType&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名(alias)的使用方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">    alias:<span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由传参解耦"><a href="#路由传参解耦" class="headerlink" title="路由传参解耦"></a>路由传参解耦</h2><p>我们可以在router/main.js中配置props，在组件中引入props然后使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">&#x27;vip&#x27;</span>,</span><br><span class="line">    name:<span class="string">&#x27;vip&#x27;</span>,</span><br><span class="line">    component:<span class="function">() =&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../components/Vip.vue&#x27;</span>),</span><br><span class="line">    props:&#123;</span><br><span class="line">        description:<span class="string">&quot;当前的数据是vip用户的数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- vip组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>VIP组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;description&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&#x27;description&#x27;</span>],</span></span><br><span class="line">    mounted () &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>直接写在router/index.js中，用于控制全部的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次路由跳转会进入该函数</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;当前页面是&quot;</span>, <span class="keyword">from</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;即将访问的页面是&quot;</span>, to)</span><br><span class="line">    <span class="comment">// 当执行了next()之后才能显示出路由跳转的页面</span></span><br><span class="line">    <span class="comment">// next()</span></span><br><span class="line">    <span class="keyword">if</span>(to.name==<span class="string">&quot;admin&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">localStorage</span>.isLogin==<span class="string">&quot;true&quot;</span>)&#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 跳转到login页面</span></span><br><span class="line">            next(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h3><p>类似前置守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由单独守卫"><a href="#路由单独守卫" class="headerlink" title="路由单独守卫"></a>路由单独守卫</h3><p>写在每个路由里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">    component: Foo,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件守卫"><a href="#组件守卫" class="headerlink" title="组件守卫"></a>组件守卫</h2><p>组件守卫就是组件内部的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在路由跳转时,如果会访问到当前组件,则会触发该守卫</span></span><br><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    next(confirm(<span class="string">&#x27;Enter Home?&#x27;</span>));</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在路由跳转时,如果离开当前组件,则会触发该守卫</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    next(confirm(<span class="string">&#x27;Leave Home?&#x27;</span>));</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在当前路径下,当路由的参数发生变化时，才会触发该路由守卫</span></span><br><span class="line"><span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(to.params.path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>路由元信息meta可以自由配置，配置方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/main.js</span></span><br><span class="line">components:&#123;&#125;=&gt;<span class="keyword">import</span>()，</span><br><span class="line">meta:&#123;<span class="attr">requestAuth</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>可以利用路由元信息在beforeEach里判断meta.requestAuth而不用对每个页面特判</p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：路由</title>
      <link href="2021/04/24/vue10/"/>
      <url>2021/04/24/vue10/</url>
      
        <content type="html"><![CDATA[<h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><p>朴素地说，路由就是根据不同的url地址来获取资源以显示不同的页面</p><p>传统的后端路由就是当URL发生跳转的时候，会重新访问服务器，服务器会解析URL，通过用户请求的url导航到具体的html页面，每次的重新请求响应较慢，会导致用户体验的下降</p><p>前端路由则是在URL地址改变时，不再向服务器请求页面，而是通过ajax向服务器请求数据，URL变化能够在无页面刷新的情况下实现UI更新，为用户提供更好的体验</p><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>我们直接来使用一下vue-router，感受一下前端路由</p><p>在vuecli中创建新项目，注意勾选上vue-router，选完router之后会让你选择是history模式还是hash模式，Y是history模式，n则是hash模式</p><p>我们先来创建一个hash模式，创建完毕之后将项目运行起来就可以看到自带的demo，demo包含了两个页面，Home和About，点击顶部的导航栏可以切换</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue10-1.png"></p><p>这里呢，就是实现了一个前端路由，home页面和about页面切换的时候没有页面刷新，而是丝滑地变换了UI，而url则是在<code>http://localhost:8080/#/</code>和<code>http://localhost:8080/#/about</code>之间切换</p><p>然后我们来看一下项目文件</p><p>我们可以在views这个文件夹里找到Home和About两个页面，就是两个普通的组件</p><p>比起之前的项目，多了一个文件夹router，里面有一个index.js，我将里面的核心代码摘录如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>App.vue中的template内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以使用方法很简单，就是在router/index.js中将路由映射加上去，然后在template中用router-link标签控制做切换控制，router-view标签负责显示对应内容</p><p>我们根据这个原理尝试新增一个页内路由，在views中新加一个页面Add.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a page for Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在router.js中增加一个映射</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Test&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/Add.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>并在App.vue的导航中增加test链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/test&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就可以成功地新增一个页面</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue10-2.png"></p><p>history模式和hash模式的区别在于，history模式的地址是没有#符号的，比如hash模式是<code>http://localhost:8080/#/about</code>，而在history模式中则是<code>http://localhost:8080/about</code></p><p>而服务器在处理url时，是忽略#后面的内容的，因此hash模式是可以直接使用的，而history模式则需要后端的配合(不刷新页面)</p><p>此外，hash模式和history模式在vuecli代码上的唯一区别就是history模式在router/index.js这个文件里面多了一行代码</p><p>hash模式是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    base: process.env.BASE_URL,routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而history模式是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    base: process.env.BASE_URL, routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建的history模式，只要将这句话注释了，就和hash模式一样了</p><h2 id="自己实现前端路由功能"><a href="#自己实现前端路由功能" class="headerlink" title="自己实现前端路由功能"></a>自己实现前端路由功能</h2><p>知道#不会引起页面刷新这个原理之后自己实现前端路由就十分地简单，站在vue这个巨人的肩膀上就更简单了</p><p>基本思路就是利用带#的url后缀使得页面不会自动刷新，利用动态组件功能来根据url后缀改变页面显示内容，#以及之后的内容也就是所谓的哈希值会被记录在location.hash中，我们可以监听hashchange事件来获取url后缀</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span> | </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/test&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;page&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">&quot;./components/Home.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> about <span class="keyword">from</span> <span class="string">&quot;./components/About.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./components/Add.vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            page: <span class="literal">null</span>,</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 挂载后开始监听hashchange事件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> pages = &#123;</span></span><br><span class="line">            home,</span><br><span class="line">            about,</span><br><span class="line">            test,</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听hashchange</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 截取有用信息</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> str = location.hash.slice(<span class="number">2</span>, location.hash.length);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(this) 如果是箭头函数的话这里可以直接用this</span></span></span><br><span class="line">            that.page = pages[str];</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="comment">// 没有hashchange时 (直接访问对应地址时)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> str = location.hash.slice(<span class="number">2</span>, location.hash.length);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.page = pages[str];</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        home,</span><br><span class="line">        about,</span><br><span class="line">        test,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：过渡动画</title>
      <link href="2021/04/21/vue9/"/>
      <url>2021/04/21/vue9/</url>
      
        <content type="html"><![CDATA[<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><p>关于vue的过渡使用，先从一个最简单的例子开始说起</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;About&quot;</span>,</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">&quot;helloworld&quot;</span>,</span></span><br><span class="line"><span class="javascript">            show: <span class="literal">true</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.fade-enter-active</span>,</span></span><br><span class="line"><span class="css"><span class="selector-class">.fade-leave-active</span> &#123;</span></span><br><span class="line">  transition: opacity 2s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.fade-enter</span>, </span></span><br><span class="line"><span class="css"><span class="selector-class">.fade-leave-to</span> &#123;</span></span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在以上例子中实现了p标签的淡入和淡出</p><p>在VUE中，过渡的使用非常简单，首先用<code>transition</code>标签把需要添加过渡的元素框起来，在标签中用<code>name</code>属性来标识动画，然后在css中用<code>v-xxxx</code>格式来制定class切换，这里v指的是过渡的<code>name</code>，xxxx则是固定类名后缀</p><div class="note orange no-icon flat"><p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <transition>，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter</p></div><p>vue的过渡有六种类名后缀，官方的图例很好地说明了这些后缀的含义</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue9-1.png"></p><p><code>v-enter</code>和<code>v-enter-to</code>是进入过渡的始末状态，<code>v-leave</code>和<code>v-leave-to</code>是离开过渡的始末状态，而<code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线</p><p>过渡缓和曲线见如下代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, </span><br><span class="line"><span class="selector-class">.slide-fade-leave-to</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>直接看例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bounce-leave-active</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    100% &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画和过渡的使用方法非常相似，区别在于动画中<code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除，而过渡中<code>v-enter</code>在元素被插入之后的下一帧移除</p><h2 id="自定义过渡类名与animate-css库"><a href="#自定义过渡类名与animate-css库" class="headerlink" title="自定义过渡类名与animate.css库"></a>自定义过渡类名与animate.css库</h2><p>我们可以在标签中使用如下六个属性来自定义过渡类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. enter-class</span><br><span class="line">2. enter-active-class</span><br><span class="line">3. enter-to-class </span><br><span class="line">4. leave-class</span><br><span class="line">5. leave-active-class</span><br><span class="line">6. leave-to-class </span><br></pre></td></tr></table></figure><p>结合animate.css库可以更方便地使用过渡动画，使用示例如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        &lt;link</span><br><span class="line">            href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span><br><span class="line">            rel=&quot;stylesheet&quot;</span><br><span class="line">            type=&quot;text/css&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span>Toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            &lt;transition</span><br><span class="line">            name=&quot;custom-classes-transition&quot;</span><br><span class="line">            enter-active-class=&quot;animated tada&quot;</span><br><span class="line">            leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class="line">            &gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="过渡生命周期"><a href="#过渡生命周期" class="headerlink" title="过渡生命周期"></a>过渡生命周期</h2><p>原理同vue实例生命周期</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  v-on:enter=&quot;enter&quot;</span><br><span class="line">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class="line">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line"></span><br><span class="line">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  v-on:leave=&quot;leave&quot;</span><br><span class="line">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class="line">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h2><p>vue的过渡默认进入和离开同时生效，有时候这并不能满足需求，因此，vue还提供了过渡模式</p><p>in-out：新元素先进行过渡，完成之后当前元素过渡离开</p><p>out-in：当前元素先进行过渡，完成之后新元素过渡进入</p><p>使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... the buttons ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上这些应该可以满足基本需求了，有更复杂的过渡动画需求(比如列表，网格之类的)可以参考<a href="https://cn.vuejs.org/v2/guide/transitions.html">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：插槽</title>
      <link href="2021/04/19/vue8/"/>
      <url>2021/04/19/vue8/</url>
      
        <content type="html"><![CDATA[<h2 id="插槽的简单使用"><a href="#插槽的简单使用" class="headerlink" title="插槽的简单使用"></a>插槽的简单使用</h2><p>slot插槽是vue2.6加入的内容，允许以一种特殊的方式来合成组件，这里以一个简单的例子来说明</p><p>比如我们在vuecli中创建一个项目并修改HelloWorld.vue的代码，用slot标签包裹起来的就是我们的插槽，而直接写在里面的内容就是插槽默认的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>下面是个插槽<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>插槽模板<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在使用组件的时候，在组件的起始标签和终止标签之间包裹的部分会替换插槽中的内容</p><p>比如这么使用组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面上就会显示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue8-1.png"></p><p>如果我们不在起始标签和结束标签之间写任何东西，则会显示插槽内原本的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">HelloWorld</span>&gt;</span><span class="tag">&lt;/<span class="name">HelloWorld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue8-2.png"></p><p>而如果我们不使用插槽slot，则起止标签中间包裹的任何内容都不会显示</p><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>在实际使用中，我们会有一个组件要用到多个插槽的需求，这里需要用到具名插槽，通俗的说就是给插槽取名区别开来，直接看例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>不同类型的名人<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>帅哥<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span> = <span class="string">&quot;handsome&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>有钱<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span> = <span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">subCom</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:handsome</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>吴彦祖<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:money</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>马云<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>马化腾<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">subCom</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而没有被包裹在带有<code>v-slot</code>的<code>template</code>标签中的内容都会被视为默认插槽的内容</p><p>当然我们也可以把它写出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>爱因斯坦<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插槽的作用域"><a href="#插槽的作用域" class="headerlink" title="插槽的作用域"></a>插槽的作用域</h2><p>子组件data中的内容是没办法直接在父组件的插槽中使用的，因为插槽中的内容是在父组件渲染的，我们需要将子组件的数据作为插槽的一个属性绑定，才可以在父组件中使用它</p><p>实现方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:username</span>=<span class="string">&quot;username&quot;</span> <span class="attr">:sex</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">subcom</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 写法一 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotprops&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;slotprops.username&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 写法二 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;&#123;username, sex&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">subcom</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然如果插槽是具名的，则需要替换上面标签中的default为对应的名字</p><h2 id="更多trick"><a href="#更多trick" class="headerlink" title="更多trick"></a>更多trick</h2><blockquote><p>动态插槽</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[这里填插槽变量名，可以在<span class="attr">data</span>中控制]&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>具名插槽语法糖</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">money</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：实例的生命周期</title>
      <link href="2021/04/17/vue7/"/>
      <url>2021/04/17/vue7/</url>
      
        <content type="html"><![CDATA[<h2 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h2><p>VUE实例从创建，运行到销毁这整个过程被称为VUE的生命周期，在生命周期中会经历生命周期事件，又可以称为生命周期钩子或者生命周期函数，这些函数是在VUE生命周期的特定时间触发的方法，使得使用者可以在生命周期中特定的阶段完成对应需求</p><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>先放一张VUE官方的生命周期函数图，然后咱慢慢解释</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue7-1.png"></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>实例创建期间包含两个生命周期函数<code>beforeCreate</code>和<code>created</code></p><p><code>beforeCreate</code>函数表示实例还未创建阶段，methods和data都没有初始化，无法被调用，<code>created</code>函数表示实例已在内存中创建，但是还没有开始编译模板，没有绑定到dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&quot;helloworld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeCreat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beforeCreat&quot;</span>)</span><br><span class="line">        <span class="comment">// 数据还未初始化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>._data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;created&quot;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>._data)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">        <span class="comment">// 还未绑定到dom</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载期间包含两个生命周期函数，<code>beforeMount</code>和<code>mounted</code></p><p><code>beforeMount</code>函数表示实例还未挂载，此时已经完成了模板的编译，但还未从内存挂载到页面，页面上模板中的表达式之类的还是字符串的形式 (能得到this.$el，但是this.$el.innerHTML还是原始值)</p><p><code>mounted</code>函数表示实例已挂载到了页面指定的容器上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&quot;helloworld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beforeMount&quot;</span>);</span><br><span class="line">        <span class="comment">// $el.innerHTML为原始值，直接输出会报错</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;mount&quot;</span>);</span><br><span class="line">        <span class="comment">// 可以获取$el.innerHTML</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>当数据data发生变化有两个生命周期函数<code>beforeUpdate</code>和<code>updated</code></p><p><code>beforeUpdate</code>函数表示数据更新但是还没有渲染到页面的时候，这时候调用data中的数据都是<strong>更新后的数据</strong>，但是页面中的dom还没有刷新 (this.$el.innerHTML还是更新前的值)，<code>beforeUpdate</code>方法自带两个参数，可以获取更新前后的数据</p><p><code>updated</code>则意味着页面上的数据和更新后的数据同步了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&quot;helloworld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeUpdate</span>(<span class="params">oldVal, newVal</span>)</span> &#123;        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beforeUpdated&quot;</span>)  </span><br><span class="line">        <span class="comment">// 更新之前的值      </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML)                </span><br><span class="line">        <span class="built_in">console</span>.log(oldVal, newVal)</span><br><span class="line">    &#125;,      </span><br><span class="line">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;updated&quot;</span>)   </span><br><span class="line">        <span class="comment">// 更新之后的值       </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML)       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>销毁阶段也包含了两个生命周期函数：<code>beforeDestroy</code>以及<code>destroyed</code></p><p><code>beforeDestroy</code>函数在Vue实例销毁前调用，所有data和methods都还可以正常使用，<code>destroyed</code>函数则在Vue实例完全销毁后调用，完全销毁指实例中所有内容解绑，事件监听移除，以及所有子实例销毁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&quot;helloworld&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;beforeDestory&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;destoryed&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.innerHTML);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：组件化开发</title>
      <link href="2021/04/15/vue6/"/>
      <url>2021/04/15/vue6/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-CLI的安装"><a href="#Vue-CLI的安装" class="headerlink" title="Vue CLI的安装"></a>Vue CLI的安装</h2><p>学习VUE组件化开发之前，先了解一下VUE CLI，工欲善其事必先利其器嘛</p><p>官网地址</p><div class="site-card-group"><a class="site-card" href="https://cli.vuejs.org/zh/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vuecli.png"/></div><div class="info"><span class="title">Vue CLI</span></div></a></div><p>首先需要一个node.js环境，然后安装Vue CLI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line"># OR</span><br><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure><p>之后就可以通过指令来创建vue项目了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create project</span><br></pre></td></tr></table></figure><p>VUE CLI还支持可视化创建项目，实测巨卡无比，这里就不展开介绍了</p><p>输入创建项目命令之后，就可以创建工程，根据需求勾选对应选项</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue6-1.png"></p><p>创建完毕之后，进入对应的文件夹，然后运行serve，就可以在页面上看到这个项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>创建好的项目目录结构如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue6-2.png"></p><p>其中node_modules文件夹放的是插件之类的东西，public文件夹里放的项目中要用到的资源，比如css之类的，src中放的主要是我们要写的代码，其中components中放的是<strong>组件</strong>，一会儿来讲，<code>App.vue</code>文件是项目的主体，可以看做是<code>index.html</code>之类的东西，而main.js则负责将App.vue实例化并渲染到页面上</p><h2 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h2><p>App.vue本身就是一个组件，可以看到它分为三个部分，<code>template</code>标签包裹的html部分，<code>script</code>部分包裹的js部分以及<code>style</code>标签包裹的css部分</p><p>现在让我们把原有的示例代码删除，自己来写一个简单的组件熟悉一下</p><p>首先是<code>template</code>部分，和html几乎是一样的，只是外面多了一个<code>template</code>标签，这是一个固定的格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>script</code>部分的格式和之前的vue对象稍有不同，其中data是函数的形式，格式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS部分则和普通的css写法相同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">h1&#123;</span><br><span class="line">    color: orange;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="子组件的调用"><a href="#子组件的调用" class="headerlink" title="子组件的调用"></a>子组件的调用</h2><p>我们可以在components里面创建组件，组件内的写法和之前是一样的</p><p>组件的引入需要在父组件中先import，然后在components中写入，然后可以在template中像使用标签一样去使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// import引入</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&quot;./components/header&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Body <span class="keyword">from</span> <span class="string">&quot;./components/body&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&quot;./components/footer&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">            msg: <span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 注册</span></span></span><br><span class="line">    components:&#123;</span><br><span class="line">        Header,</span><br><span class="line">        Body,</span><br><span class="line">        Footer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要一提的是上面components里面的写法是简写，实际上每一项应该是<code>Header:Header</code>这样的格式，当命名和引入名相同时可以简写为一个</p><p>引入完之后就可以在template中直接使用了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Header</span>&gt;</span><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Body</span>&gt;</span><span class="tag">&lt;/<span class="name">Body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Footer</span>&gt;</span><span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果有组件特别的常用，我们可以全局注册，这样就不需要在多个页面反复导入和注册，全局注册在<code>main.js</code>里面导入和注册，Footer组件的全局注册方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">&#x27;./components/Footer&#x27;</span></span><br><span class="line">Vue.component(<span class="string">&#x27;Footer&#x27;</span>,Footer)</span><br></pre></td></tr></table></figure><h2 id="组件中的数据传递"><a href="#组件中的数据传递" class="headerlink" title="组件中的数据传递"></a>组件中的数据传递</h2><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>vue中父组件给子组件传值需要父组件在标签内设置参数，且需要子组件设置参数表<code>props</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件的template中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-com</span> <span class="attr">v-for</span>=<span class="string">&quot;star in stars&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;star.id&quot;</span> <span class="attr">:star</span>=<span class="string">&quot;star&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;star.name&quot;</span> <span class="attr">:gender</span>=<span class="string">&quot;star.gender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 传入的数据可以是值或者直接是一个对象</span></span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;star&quot;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到子组件props中的变量名其实就是父组件的绑定名，父组件将自己组件中的变量绑定到子组件props中的变量名上，传递给子组件使用，子组件就可以直接地使用这些变量，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="传参设置"><a href="#传参设置" class="headerlink" title="传参设置"></a>传参设置</h4><p>在组件接受参数的时候还可以设定传参类型，比如设定必须传入数字，字符串等等，实现格式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line">    props:&#123;</span><br><span class="line"><span class="javascript">        id: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">        name: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        star: <span class="built_in">Object</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以设置多种格式，设置默认值<code>default</code>，设置<code>required</code>要求值必须被传入，或是使用<code>validator</code>对传入的值进行校验，使用示例如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line"><span class="javascript">        id: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">        name: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        star: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 可以设置多种格式</span></span></span><br><span class="line"><span class="javascript">        age: [<span class="built_in">Number</span>, <span class="built_in">String</span>],</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 可以设置默认值</span></span></span><br><span class="line">        nickname:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>: <span class="string">&quot;无昵称&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 设定该数据必须被传入</span></span></span><br><span class="line">        tel:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">            required: <span class="literal">true</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 对传入参数进行校验</span></span></span><br><span class="line">        number:&#123;</span><br><span class="line"><span class="javascript">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(value &gt; <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.error(<span class="string">&quot;number值不能为负&quot;</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>子组件给父组件传值，本质上是通过通知的方式使得父组件改变自己的值</p><p>需要在父组件内绑定一个方法，然后子组件使用<code>$emit</code>触发事件向父组件的函数传值，通知父组件更改值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件中绑定事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-com</span> @<span class="attr">changeNum</span>=<span class="string">&quot;changeFn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-com</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中使用methods</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    changeFn: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在子组件内通知父组件改变属性</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&quot;changeNum&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子组件之间的互相传值"><a href="#子组件之间的互相传值" class="headerlink" title="子组件之间的互相传值"></a>子组件之间的互相传值</h3><h4 id="父组件作为媒介"><a href="#父组件作为媒介" class="headerlink" title="父组件作为媒介"></a>父组件作为媒介</h4><p>子组件之间数据传递最朴素的方法，就是通过父组件，将数据定义在父组件，子组件A使用<code>$emit</code>来更改父组件的值，然后通过父组件传递给子组件B</p><h4 id="中央总线方法"><a href="#中央总线方法" class="headerlink" title="中央总线方法"></a>中央总线方法</h4><p>创建一个事件总线<code>eventBus.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> eventBus =<span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br></pre></td></tr></table></figure><p>组件中接受和发送数据的代码示例如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;../eventBus&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msgB: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当组件渲染后自动执行</span></span><br><span class="line">    mounted () &#123;</span><br><span class="line">        <span class="comment">// 监听事件childB (B组件里面用eventBus.$emit触发事件childB)</span></span><br><span class="line">        eventBus.$on(<span class="string">&#x27;childB&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.msgB = data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发送消息给B组件</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 触发事件childA (B组件中eventBus监听事件childA)</span></span><br><span class="line">        sendB: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            eventBus.$emit(<span class="string">&#x27;childA&#x27;</span>, <span class="string">&quot;hello B,我是A组件&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为两个组件都导入了eventBus实例，用eventBus在子组件触发事件，同时在另一个子组件监听对应的事件，就可以完成子组件间的信息传递</p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：事件与表单</title>
      <link href="2021/04/15/vue5/"/>
      <url>2021/04/15/vue5/</url>
      
        <content type="html"><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>VUE中事件绑定用的是<code>v-on:</code>，可以简写为<code>@</code></p><p>我们可以直接在标签里监听事件同时执行JS代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;cnt += 1&quot;</span>&gt;</span>cnt++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在<code>methods</code>中写入事件然后在标签中使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;show&quot;</span>&gt;</span> &#123;&#123;msg&#125;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">&quot;click&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            app.msg = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>VUE还支持内联语句调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;show(&#x27;hello&#x27;)&quot;</span>&gt;</span> &#123;&#123;msg&#125;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;show(&#x27;goodbye&#x27;)&quot;</span>&gt;</span> &#123;&#123;msg&#125;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">&quot;click&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">            app.msg = str</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们发现当用这种传参方法之后，js原生事件的event属性就没有了，vue提供了<code>$event</code>参数来满足使用event属性的需求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span> = <span class="string">&quot;item in names&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;fn(item, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>VUE还支持对事件进行修饰</p><p>比如原生js中阻止事件冒泡用的<code>evt.stopPropagation()</code></p><p>在VUE中只要简单地使用<code>.stop</code>即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span> = <span class="string">&quot;item in names&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;fn(item, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以添加修饰符阻止默认行为，对应原生js的<code>evt.preventDefault()</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;fn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>修饰符</th><th>功能</th></tr></thead><tbody><tr><td>.stop</td><td>阻止事件冒泡</td></tr><tr><td>.prevent</td><td>阻止浏览器默认行为</td></tr><tr><td>.capture</td><td>添加事件监听器时使用事件捕获模式</td></tr><tr><td>.self</td><td>只当在event.target是当前元素自身时触发处理函数</td></tr><tr><td>.once</td><td>只有第一次触发生效</td></tr><tr><td>.passive</td><td>滚动事件的默认行为 (即滚动行为) 将会立即触发，优化移动端体验</td></tr></tbody></table><p>在监听按键的时候还有按键修饰符，如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按键还有一个特殊的修饰符.exact，允许精确地控制触发，官方例子如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>几乎所有html原生表单内容都是可以用<code>v-model</code>绑定的，具体要使用的时候可以查api，我这里稍微使用了一下做了个小demo</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;其他&quot;</span>&gt;</span>其他<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="symbol">&amp;emsp;</span>意向职位(可多选，按住ctrl)：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;job&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;job&quot;</span> <span class="attr">multiple</span>=<span class="string">&quot;multiple&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;前端工程师&quot;</span>&gt;</span>前端工程师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;后端工程师&quot;</span>&gt;</span>后端工程师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;算法工程师&quot;</span>&gt;</span>算法工程师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;软件测试&quot;</span>&gt;</span>软件测试<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;UI设计&quot;</span>&gt;</span>UI设计<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="symbol">&amp;emsp;</span>联系方式：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号码&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>教育经历：<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请填入教育经历&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;education&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>项目经历：<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请填入项目经历&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;experience&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>个人简介：<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请填入个人简介&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;description&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 性别：&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 联系方式：&#123;&#123;tel&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 意向职位：&#123;&#123;job&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 教育经历：&#123;&#123;education&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 项目经历：&#123;&#123;experience&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 个人简介：&#123;&#123;description&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> options = &#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                name: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                description: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                education: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                experience:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">                sex: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line">                job: [],</span><br><span class="line"><span class="javascript">                tel: <span class="string">&quot;&quot;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(options)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：条件渲染与列表渲染</title>
      <link href="2021/04/12/vue4/"/>
      <url>2021/04/12/vue4/</url>
      
        <content type="html"><![CDATA[<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><code>v-if</code>，<code>v-else-if</code>，<code>v-else</code>在之前的简单使用中已经做过相应的介绍了，这里用一个非常简单的例子做一个使用说明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;sex==&#x27;男&#x27;&quot;</span>&gt;</span>您好，先生<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;sex==&#x27;女&#x27;&quot;</span>&gt;</span>您好，女士<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>您好，来宾<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            sex: <span class="string">&quot;史莱姆&quot;</span></span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用模板进行条件渲染"><a href="#使用模板进行条件渲染" class="headerlink" title="使用模板进行条件渲染"></a>使用模板进行条件渲染</h3><p>可以看出，如果我们要进行条件渲染，则必须要将指令加在标签内，但是如果我们希望多个标签同时出现，又不希望嵌套，则可以使用模板template</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;sex==&#x27;男&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>以下内容仅男士可见<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>其实也没啥内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面渲染结果中是不会出现template的，仅作为一个不可见的包裹元素来使用</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>除了<code>v-if</code>系列之外，Vue.js还提供了一种条件渲染指令<code>v-show</code>，和<code>v-if</code>的使用方法十分相似</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;sex==&#x27;男&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>以下内容仅男士可见<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>其实也没啥内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是<code>v-show</code>和<code>v-if</code>在渲染方式上是存在区别的，当<code>v-if</code>判断失效的时候，相应的元素并不会被渲染出来，直到判断为真才会去渲染对应的元素，而<code>v-show</code>不管元素是否生效，都会去渲染它，用<code>display</code>属性来决定元素是否显示，比方说，上面的html代码在data中的sex为”女”时渲染得到的html代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您好，女士<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>以下内容仅男士可见<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>其实也没啥内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当需要该dom元素可见时，只要改变<code>display</code>属性即可</p><p>所以相比之下，<code>v-if</code>的切换开销大，而<code>v-show</code>的初始渲染开销大，当网页需要频繁切换时应使用<code>v-show</code>来渲染，否则<code>v-if</code>更佳</p><h3 id="用key来管理元素"><a href="#用key来管理元素" class="headerlink" title="用key来管理元素"></a>用key来管理元素</h3><p>Vue的实现会高效的渲染元素，通常会复用已有的元素而非从头开始渲染</p><p>比方说如下的例子，点击按钮之后</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输入区域的内容并没有变化，但是label确实发生了变化，说明按钮生效了</p><p>本质上，因为两个模板的元素是相同的，Vue并没有重新去渲染一个新的，仅仅是替换了<code>label</code>的<code>innerHTML</code>以及<code>input</code>的<code>placeholder</code>而已</p><p>如果我们不希望vue去复用元素，我们得告诉vue两个元素是完全独立的，为此，vue为我们提供了一个key属性，你只要给不希望被复用的元素key属性即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样点击按钮的时候输入区域的内容就不会被保留，因为dom被重新生成了</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="基于数组渲染列表"><a href="#基于数组渲染列表" class="headerlink" title="基于数组渲染列表"></a>基于数组渲染列表</h3><p>之前在简单使用中初步了解了<code>v-for</code>，我们知道用<code>v-for</code>可以很方便地遍历data中的数组，如下所示是一个简单的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            items: [<span class="string">&quot;item1&quot;</span>,<span class="string">&quot;item2&quot;</span>,<span class="string">&quot;item3&quot;</span>,<span class="string">&quot;item4&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>v-for</code>还可以拥有第二个参数，用来表示下标</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;,&#123;&#123;index&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h3 id="数组的更新检测"><a href="#数组的更新检测" class="headerlink" title="数组的更新检测"></a>数组的更新检测</h3><p>对于刚才用数据渲染列表的例子，我们在控制台输入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.items[0]&#x3D;&quot;item0&quot;</span><br></pre></td></tr></table></figure><p>可以在控制台看到items[0]被修改了，但是页面上却并没有什么变化，因为<strong>vue是不监听索引值的</strong>，但是vue封装了很多数组的变更方法，这些方法是可以被监听到的，包括</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>还包括了数组替换的方法：filter()、concat() 和 slice()</p><p>注意这里的数组替换并不会使得VUE重新渲染整个列表，VUE会最大范围地重用DOM元素，因此这个替换是一个比较高效的操作</p><p>如果，一定要用索引值去修改，也不是没有办法，可以使用<code>$set</code>方法，使用方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.$set(app.items,<span class="number">0</span>,<span class="string">&quot;item0&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于对象渲染列表"><a href="#基于对象渲染列表" class="headerlink" title="基于对象渲染列表"></a>基于对象渲染列表</h3><p>当用<code>v-for</code>来遍历对象内容时可以有三个参数：属性值，属性名，以及索引值，示例如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(val, key, id) in items&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;val&#125;&#125;,&#123;&#123;key&#125;&#125;,&#123;&#123;id&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            items: &#123;</span><br><span class="line">                item1: <span class="string">&quot;item-1&quot;</span>,</span><br><span class="line">                item2: <span class="string">&quot;item-2&quot;</span>,</span><br><span class="line">                item3: <span class="string">&quot;item-3&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="用key来管理数组元素"><a href="#用key来管理数组元素" class="headerlink" title="用key来管理数组元素"></a>用key来管理数组元素</h3><p>我们知道，为了让元素不被复用，需要绑定<code>key</code>来使元素独立</p><p>但是在数组的遍历中，我们不能将key直接绑定在索引值上，这种操作会因为VUE的复用策略产生一些神奇的问题</p><p>举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> &#123;&#123; item &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>删除item1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            items: [<span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>, <span class="string">&quot;item3&quot;</span>]</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.items.shift()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在item1的checkbox上打个勾</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue4-2.png"/><p>然后点击按钮删除item1，就会发现item1虽然被删除了，但是item2前面的checkbox也有一个勾</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vue4-3.png"/><p>这是因为vue在更新数据的过程中，发现虚拟dom前两项的key和当前dom是相同的，于是选择复用，只是更改了dom中的文本</p><p>所以，绑定key的时候最好要选择独一无二的变量来渲染，比如可以修改为如下方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> &#123;&#123; item.val &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>删除item1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            items: [</span><br><span class="line"><span class="javascript">                &#123; <span class="attr">val</span>: <span class="string">&quot;item1&quot;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">val</span>: <span class="string">&quot;item2&quot;</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">val</span>: <span class="string">&quot;item3&quot;</span>, <span class="attr">id</span>: <span class="number">3</span> &#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.items.shift()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就不会有复用的问题了</p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：类与内联样式</title>
      <link href="2021/04/11/vue3/"/>
      <url>2021/04/11/vue3/</url>
      
        <content type="html"><![CDATA[<p>Vue.js对于类和内联样式做了专门的加强，使得操作元素的类列表和内联样式这样的常见需求变得更为方便</p><h2 id="动态切换类"><a href="#动态切换类" class="headerlink" title="动态切换类"></a>动态切换类</h2><p>我们希望有些类的效果在固定情况下触发，这样的功能在原生js中一般是通过对classList进行增删来实现的，而VUE则允许通过一个布尔变量来控制类是否生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">&quot;button&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:true&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就表示active这个类是可用的</p><p>如果有多个类，则可以用逗号逗开放入对象中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">&quot;button&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:true, good:true&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为是布尔变量，因此我们可以在data中设置一个变量来控制类是否使用，同时，我们可以绑定一个方法来改变这个变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">&quot;button&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive, good:true&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;toggleActive&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app= <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        isActive:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        toggleActive:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们给按钮设置两个style</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.good</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，第二个类一直生效，而第一个类可以跟着点击事件切换其生效状态</p><h2 id="数组形式控制类"><a href="#数组形式控制类" class="headerlink" title="数组形式控制类"></a>数组形式控制类</h2><p>刚才的例子也可以用数组形式来写，代码如下所示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">    type = &quot;button&quot;</span><br><span class="line">    :class=&quot;[&#x27;good&#x27;, isActive1]&quot;</span><br><span class="line">    @click=&quot;toggleFn&quot;</span><br><span class="line">&gt;click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以直接在数组中放入一个字符串变量，通过改变这个变量的值来控制类</p><p>如下所示，我们首先给这个变量设置一个初始值，在点击事件中对该变量进行值的改变即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isActive1: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toggleFn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isActive1 == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.isActive1 = <span class="string">&quot;active&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.isActive1 = <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="混合形式控制类"><a href="#混合形式控制类" class="headerlink" title="混合形式控制类"></a>混合形式控制类</h2><p>除此之外，Vue.js支持更复杂的数组和对象混合的形式来控制类，并且class和绑定的class也可以一起使用，Vue.js会帮你自动拼接，使用例子如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 数组和对象混合</span><br><span class="line">&lt;button</span><br><span class="line">:class=&quot;[&#x27;good&#x27;,&#123;active:isAcitve&#125;]&quot;</span><br><span class="line">&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// class与绑定的class一起使用</span><br><span class="line">&lt;button</span><br><span class="line">class = &quot;abcd bcd&quot;</span><br><span class="line">:class=&quot;[&#x27;good&#x27;,&#123;active:isAcitve&#125;]&quot;</span><br><span class="line">&gt;按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字符串形式控制类"><a href="#字符串形式控制类" class="headerlink" title="字符串形式控制类"></a>字符串形式控制类</h2><p>最为原始的方式就是用字符串的形式来控制类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:class</span> = <span class="string">&quot;str&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定data中的变量str，之后我们对这个字符串进行拼接，删除等操作就可以实现类的控制了，不过就比上述方法复杂多了</p><h2 id="内联样式的控制"><a href="#内联样式的控制" class="headerlink" title="内联样式的控制"></a>内联样式的控制</h2><p>内联样式的控制和类的控制非常相似</p><p>首先同样可以通过对象来控制，css属性支持在引号内使用原属性名或者直接用驼峰命名法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html标签中</span></span><br><span class="line">:style = styleObj</span><br><span class="line"><span class="comment">// vue对象中</span></span><br><span class="line">data:&#123;</span><br><span class="line">    styleObj:&#123;</span><br><span class="line">        <span class="comment">// 驼峰命名法</span></span><br><span class="line">        <span class="string">&#x27;background-color&#x27;</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="comment">// 引号法</span></span><br><span class="line">        borderRadius: 2px</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是，两种不同的属性使用方法对应的是不同的属性修改方法，比如使用了驼峰命名法的属性无法用引号法对应的方法来修改属性，两种属性的对应修改方法见下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引号法属性的修改</span></span><br><span class="line">styleObj[<span class="string">&#x27;background-color&#x27;</span>] = xxxx</span><br><span class="line"><span class="comment">// 驼峰命名法属性的修改</span></span><br><span class="line">styleObj.borderRadius = xxx</span><br></pre></td></tr></table></figure><p>除了对象控制之外，style也支持混合模式和字符串模式，混合模式格式见下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:style=<span class="string">&quot;[styleObj, sizeObj]&quot;</span></span><br></pre></td></tr></table></figure><p>可以通过这个方式直接拼接两个对象中的css属性</p>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：计算属性与监听</title>
      <link href="2021/04/10/vue2/"/>
      <url>2021/04/10/vue2/</url>
      
        <content type="html"><![CDATA[<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>VUE的模板语法非常的方便，我们可以轻松地调用和计算数据，但是如果最终结果和依赖数据之间的关系复杂，直接使用模板语法使得代码易读性极具下降，这里我们借用一下官网的例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们想要在多个地方使用翻转后的字符串，那么这个冗长的代码就会出现在多个地方，这并不是我们所希望看到的</p><p>你可以会说可以使用函数，这确实是一个可行的途径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    revMsg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在每个位置我们都需要去调用这个函数，并且即使原字符串没有改变，还是要在函数内进行一次计算，为了节省计算时间，我们希望保存一个值，当原字符串变动的时候才调用函数计算更新这个值，ok，VUE提供了这个功能 —— 计算属性</p><p>计算属性可以缓存数据，会自动随着依赖数据改变而改变，当依赖数据没变化时，直接调用计算属性不会重复计算，而是直接得到缓存的值</p><p>计算属性的写法和methods完全一样，只是放在参数data对象的computed对象中，调用的时候直接写计算对象的名字即可，不需要像函数一样加括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    revMsg: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重依赖"><a href="#多重依赖" class="headerlink" title="多重依赖"></a>多重依赖</h3><p>计算属性是允许多重依赖的，当其中一个依赖数据发生变化时，就会重新计算刷新缓存，举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        xing: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">        ming: <span class="string">&quot;三&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        xingming: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.xing + <span class="built_in">this</span>.ming</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(options)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;xing&quot;</span>/&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;ming&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>姓名：&#123;&#123;xingming&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们修改姓或者名时，姓名这个计算属性就会刷新</p><h3 id="计算属性的修改"><a href="#计算属性的修改" class="headerlink" title="计算属性的修改"></a>计算属性的修改</h3><p>有时候我们会有直接修改计算属性的需求，比如让用户直接输入姓名，然后系统拆解为姓和名，修改一下HTML做个试验</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;xing&quot;</span>/&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;ming&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>姓名：&#123;&#123;xingming&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;xingming&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们尝试在input中直接修改<code>xingming</code>这个计算属性的时候会发现控制台有个报错</p><div class="tip error"><p>vue.js:634 [Vue warn]: Computed property “xingming” was assigned to but it has no setter.(found in <Anonymous>)</p></div><p>意思是存在计算属性<code>xingming</code>，但是没有setter</p><p>计算属性中有两个自带的方法，get和set，之前的写法默认是只有get，也就是只允许获取，不允许修改，如果想要计算属性可以修改，我们需要写一个set方法</p><p>实现方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    xingming: &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.xing + <span class="built_in">this</span>.ming</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val) &#123;</span><br><span class="line">                <span class="comment">// 默认拆分第一个字符为姓</span></span><br><span class="line">                <span class="built_in">this</span>.xing = val[<span class="number">0</span>]</span><br><span class="line">                <span class="comment">// slice(st,en) 提取字符串片段</span></span><br><span class="line">                <span class="built_in">this</span>.ming = val.slice(<span class="number">1</span>, val.length)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若字符串为空，则不能拆分，否则会变成undefined</span></span><br><span class="line">                <span class="built_in">this</span>.xing = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="built_in">this</span>.ming = <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们修改<code>xingming</code>这个计算属性，就可以发现依赖属性<code>xing</code>和<code>ming</code>也跟着变动了</p><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><p>计算属性可以监听到依赖属性的变化，来改变属性值，也可以监听计算属性的变化来更新依赖属性，除此之外，VUE还提供了一个更通用的方法watch，来监听数据的变化，如果属性值发生变化，就执行对应的函数</p><p>举个简单的例子，我们在刚才那段代码的姓名显示dom上绑定一个style，然后监听<code>xing</code>属性的变化来改变它的style</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;xing&quot;</span> /&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;ming&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 绑定style --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">:style</span> = <span class="string">&quot;styleObj&quot;</span>&gt;</span>姓名：&#123;&#123;xingming&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;xingming&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        xing: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">        ming: <span class="string">&quot;三&quot;</span>,</span><br><span class="line">        styleObj: &#123;</span><br><span class="line">            background: <span class="string">&quot;skyblue&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        xingming: &#123;</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.xing + <span class="built_in">this</span>.ming</span><br><span class="line">            &#125;,</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (val) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.xing = val[<span class="number">0</span>]</span><br><span class="line">                    <span class="built_in">this</span>.ming = val.slice(<span class="number">1</span>, val.length)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.xing = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="built_in">this</span>.ming = <span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        xing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> red = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">let</span> blue = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">let</span> green = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">            <span class="built_in">this</span>.styleObj.background</span><br><span class="line">                = <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>,<span class="subst">$&#123;green&#125;</span>,<span class="subst">$&#123;blue&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>)`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现每次改变<code>xing</code>变量，都可以触发dom背景颜色的变化，<strong>包括<code>xingming</code>这个计算属性的变化带动的<code>xing</code>变量的变化</strong></p><p>但是计算属性监听是无法达到理想的效果的，我尝试监听了一下<code>xingming</code>这个计算属性，发现只能监听到<code>xing</code>的变化，<code>ming</code>的变化无法被监听到，也就是说只能watch变量</p><p>watch中的函数还有两个自带的参数 <code>newValue</code>, <code>oldValue</code>，记录了原值和修改后的值，我们可以通过如下方法来使用这两个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    xing: <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;oldValue&#125;</span>-&gt;<span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">let</span> red = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">        <span class="keyword">let</span> blue = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">        <span class="keyword">let</span> green = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)</span><br><span class="line">        <span class="built_in">this</span>.styleObj.background</span><br><span class="line">            = <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>,<span class="subst">$&#123;green&#125;</span>,<span class="subst">$&#123;blue&#125;</span>,<span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学习笔记：简单了解与使用</title>
      <link href="2021/04/06/vue1/"/>
      <url>2021/04/06/vue1/</url>
      
        <content type="html"><![CDATA[<h2 id="VUE的引入"><a href="#VUE的引入" class="headerlink" title="VUE的引入"></a>VUE的引入</h2><p>VUE的使用和jQuery一样，我们可以直接通过下载文件后引入也可以直接通过cdn引入，cdn地址如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>开发版和生产版的区别是，开发版包含了带有帮助的命令行警告，而生产版则优化了尺寸和速度，没有命令行警告</p><h2 id="VUE对象"><a href="#VUE对象" class="headerlink" title="VUE对象"></a>VUE对象</h2><p>当我们把vue.js引入后我们就可以实例化Vue对象了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>, </span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">&quot;hello world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实例化Vue对象一般传入一个带有el和data参数的对象，我们可以像上述代码这样写，也可以先创建一个对象，然后传参，如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>, </span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">&quot;hello world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(options)</span><br></pre></td></tr></table></figure><p>这里解释一下两个参数，el用于绑定dom，确定vue对象的挂载区域，也就是我们这个Vue对象绑定了id为app的dom，使得这个dom可以使用数据data中的内容，data就是一个可以添加任何数据的对象</p><h2 id="VUE简单使用"><a href="#VUE简单使用" class="headerlink" title="VUE简单使用"></a>VUE简单使用</h2><p>上面介绍了Vue对象中的参数，现在我们来使用以下这个Vue对象，首先最简单的，我们让Vue的data数据渲染到页面上</p><p>我们只要在html标签中按照如下方式写入数据，就可以渲染到页面上，马上就可以看到我们写在Vue中的msg信息，也就是”hello world”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VUE的这种编程方式被称为<strong>声明式编程</strong>，区别于原生js的<strong>命令式编程</strong>开发模式，通过使用VUE对象来对数据进行管理</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>刚才我们知道了html内容使用的规则是在两个大括号中添加数据，那么在属性中该如何使用数据 (比如图片的地址等需要放在标签内使用的内容)</p><p>在标签中使用数据的方式是用<code>v-bind</code>指令来实现，它可以往元素的属性中绑定数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;picUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用中，<code>v-bind</code>是可以省略的，也就是可以直接像如下代码一样直接写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;picUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两种写法是等价的</p><h3 id="循环加载数据"><a href="#循环加载数据" class="headerlink" title="循环加载数据"></a>循环加载数据</h3><p>当从data中获取数据，数据量大且具有重复性的时候就有了对循环读取数据功能的需求，比如读取歌单，名单并渲染等，这里就要用到Vue的循环命令<code>v-for</code></p><p>比如data中有一个artists数组，里面是多个player，那么我们可以用<code>v-for</code>来循环得到每个歌手的名字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;player in artists&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;player.name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>对于条件判断语句，Vue也有独特的命令<code>v-if</code>,<code>v-else-if</code>以及<code>v-else</code></p><p>比如我们要根据读取的数据做一个条件判断来在app中显示相应的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;age&gt;18&quot;</span>&gt;</span>游戏防沉迷：游玩时间10小时<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-else-if</span>=<span class="string">&quot;age&gt;12&quot;</span>&gt;</span>游戏防沉迷：游玩时间5小时<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-else</span>&gt;</span>游戏防沉迷：游玩时间2小时<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结合<code>v-for</code>和<code>v-if</code>我们就可以对数据进行带条件判断地展示</p><h3 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h3><p>Vue中通过<code>v-on</code>来绑定事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click = <span class="string">&quot;show&quot;</span>&gt; &#123;&#123;msg&#125;&#125; &lt;/button&gt;</span><br></pre></td></tr></table></figure><p>Vue中还有对应的语法糖，用<code>@</code>来代替<code>v-on:</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click = <span class="string">&quot;show&quot;</span>&gt; &#123;&#123;msg&#125;&#125; &lt;/button&gt;</span><br></pre></td></tr></table></figure><p>这里用到的方法show，也可以在Vue对象中作为参数传入，除了el和data之外，Vue还支持methods参数，用来存放方法，示例如下，这样子我们就可以简单实现点击改变按钮内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">&quot;click&quot;</span>,</span><br><span class="line">        age: <span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            app.msg = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>如果我们希望修改data中的值，就可以通过数据绑定命令<code>v-model</code>来实现，就比如我们希望去修改data中的年龄，从而改变防沉迷游玩时间，那么我们就可以这么实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们修改input中的数字，就能改变data中对应的age值，这里的数据绑定是<strong>双向绑定</strong>，所以我们一开始也能在这个输入区域，看到data中age的初始值12</p><p><code>v-bind</code>是model到view的单向绑定，<code>v-model</code>是model和view的双向绑定</p><h3 id="只填充一次数据"><a href="#只填充一次数据" class="headerlink" title="只填充一次数据"></a>只填充一次数据</h3><p>如果我们希望用Vue中的data来填充数据，但是不希望随着data中值的改变而发生变化，则Vue中也提供了这样的功能，用<code>v-once</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-once&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="插入HTML变量"><a href="#插入HTML变量" class="headerlink" title="插入HTML变量"></a>插入HTML变量</h3><p>有时我们会有插入HTML内容的需求，比如直接插入一个图片的dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        content:<span class="string">&quot;&lt;img src=&#x27;...&#x27;&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果要使用data里面这个content，我们发现直接用变量的方式插入并不可行，比如说如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样并不能将图片显示出来，而是将html代码显示在了页面了，如果希望使用这个html代码，则需要用<code>v-html</code>命令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>Vue还支持动态修改属性的名字，比如有些属性在特殊条件下才会使用，那么就可以在特定条件下改变属性名字，比如下列例子中一开始attr变量值为data-src，并不会使得图片显示，当将其值改为src时，图片就可以正常显示，该功能在vue2.6加入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:</span>[<span class="attr">attr</span>]=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    url:<span class="string">&quot;...&quot;</span></span><br><span class="line">    attr:<span class="string">&quot;data-src&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 🌙VUE梦工厂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery学习记录</title>
      <link href="2021/04/04/jQuery/"/>
      <url>2021/04/04/jQuery/</url>
      
        <content type="html"><![CDATA[<p>jQuery是js的一个插件，可以从官网下载，直接引入就可以使用，其设计宗旨是”Write Less，Do More”，其本质上是一个类似语法糖的东西，集成了js中很多常用的方法和选择器，使得代码写起来更简单</p><div class="site-card-group"><a class="site-card" href="https://jquery.com/download/#Download_jQuery"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/jQuery-1.png"/></div><div class="info"><span class="title">jQuery</span><span class="desc">jQuery官网地址</span></div></a></div><p>下载完之后我们就可以直接引入它，包含.min是压缩后的，内存更小，未压缩的可以作为源码阅读查错</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-3.6.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然如果不想下载也可以使用谷歌或者微软的CDN</p><h2 id="jQuery常用功能"><a href="#jQuery常用功能" class="headerlink" title="jQuery常用功能"></a>jQuery常用功能</h2><p>下面记录几种常用功能的jQuery使用方法</p><h3 id="DOM对象的获取"><a href="#DOM对象的获取" class="headerlink" title="DOM对象的获取"></a>DOM对象的获取</h3><p>相比于使用js原本获取DOM对象的语句，jQuery简单了很多，只用一个<code>$</code>符号表示DOM对象选取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> block = $(<span class="string">&quot;.block&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们知道如果获取一个DOM，则一般在js中使用<code>document.querySeletor(&quot;.block&quot;)</code>，但是如果要获取同属于这个类的所有dom就要使用<code>document.querySelectorAll(&quot;.block&quot;)</code></p><p>而jQuery中则会直接返回一个对象数组，返回所有满足条件的对象，比如如果有两个class为block的dom，则可以用<code>block[0]</code>和<code>block[1]</code>来分别使用这两个dom</p><h3 id="CSS样式设置"><a href="#CSS样式设置" class="headerlink" title="CSS样式设置"></a>CSS样式设置</h3><p>在jQuery中设置css样式，只要简单调用css方法即可，比如我要将所有block的背景颜色变为红色，只需要写如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block.css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>)</span><br></pre></td></tr></table></figure><p>css函数支持多条属性的添加，需要用一个花括号包裹，然后在里面写css属性，格式如下，注意这里原本带有小横杠的属性名字用驼峰命名法代替</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block.css(&#123;<span class="attr">color</span>:<span class="string">&quot;#fff&quot;</span>, <span class="attr">fontSize</span>:<span class="string">&quot;30px&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>jQuery还有一个方便的特性是链式操作，即对对象修改之后会作为返回值返回，比如刚才我们两次对css的修改可以简单地并在一起处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block.css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>)</span><br><span class="line">     .css(&#123;<span class="attr">color</span>:<span class="string">&quot;#fff&quot;</span>, <span class="attr">fontSize</span>:<span class="string">&quot;30px&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="类名的增删"><a href="#类名的增删" class="headerlink" title="类名的增删"></a>类名的增删</h3><p>这个本质上也就是对js原生的方式的简写，代码示例如下，这样就能给所有block添加类，并将第一个block的类去掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.block&quot;</span>).addClass(<span class="string">&quot;spcBlock&quot;</span>)</span><br><span class="line">$(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).removeClass(<span class="string">&quot;spcBlock&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="属性的修改与查询"><a href="#属性的修改与查询" class="headerlink" title="属性的修改与查询"></a>属性的修改与查询</h3><p>属性的修改则是使用封装的attr函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).attr(<span class="string">&quot;data-id&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>当然如果我们不填attr函数的第二个参数，那就相当于是直接查询对应的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).attr(<span class="string">&quot;data-id&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="HTML内容的修改"><a href="#HTML内容的修改" class="headerlink" title="HTML内容的修改"></a>HTML内容的修改</h3><p>在JS里面我们经常对标签包裹的HTML内容进行修改，jQuery对这个方法也进行了封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).html(<span class="string">&quot;方块修改&quot;</span>)</span><br></pre></td></tr></table></figure><p>同样，这个函数也可以用来查询html，括号内不填参数即可</p><h3 id="事件添加"><a href="#事件添加" class="headerlink" title="事件添加"></a>事件添加</h3><p>两种方式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.block&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">&#x27;.block&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="简易jQuery的实现"><a href="#简易jQuery的实现" class="headerlink" title="简易jQuery的实现"></a>简易jQuery的实现</h2><p>所以，jQuery就是一个封装好的使用更方便的一个框架，或者说插件</p><p>现在我们来尝试自己封装一个简易的jQuery，实现以上的功能</p><p>创建一个jquery-simple.js，然后引入，开始实现上述功能，之前的测试代码如下所示，我们的目标就是使得这些代码能够成功运行，那么功能就算实现了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span>方块1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span>方块2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> block = $(<span class="string">&quot;.block&quot;</span>)</span></span><br><span class="line"><span class="javascript">    block.css(<span class="string">&quot;background-color&quot;</span>, <span class="string">&quot;red&quot;</span>)</span></span><br><span class="line"><span class="javascript">        .css(&#123; <span class="attr">color</span>: <span class="string">&quot;#fff&quot;</span>, <span class="attr">fontSize</span>: <span class="string">&quot;30px&quot;</span> &#125;)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block&quot;</span>).addClass(<span class="string">&quot;spcBlock&quot;</span>)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).removeClass(<span class="string">&quot;spcBlock&quot;</span>)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).attr(<span class="string">&quot;data-id&quot;</span>, <span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).attr(<span class="string">&quot;data-id&quot;</span>))</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block:nth-of-type(1)&quot;</span>).html(<span class="string">&quot;方块修改&quot;</span>)</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.block&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOM的获取"><a href="#DOM的获取" class="headerlink" title="DOM的获取"></a>DOM的获取</h3><p>首先我们需要实现可以用$符号来进行dom的查询并返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">    <span class="comment">// 解构</span></span><br><span class="line">    elements = [...elements] </span><br><span class="line">    <span class="keyword">return</span> elements</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里我们对<code>elements</code>进行数组解构，因为<code>querySelectorAll</code>的返回值是一个nodelist，不好使用<code>forEach</code>，不太方便我们接下来的封装操作</p><p>接下来就是对elements方法的添加，我们将方法添加到elements的原型对象上，因为css方法的参数稍微复杂一点，我们最后来封装，先将其它简单的功能封装一下</p><h3 id="类名的增删-1"><a href="#类名的增删-1" class="headerlink" title="类名的增删"></a>类名的增删</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">elements.__proto__.addClass = <span class="function"><span class="keyword">function</span> (<span class="params">classname</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.classList.add(classname))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">elements.__proto__.removeClass = <span class="function"><span class="keyword">function</span> (<span class="params">classname</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.classList.remove(classname))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性和HTML的修改和查找"><a href="#属性和HTML的修改和查找" class="headerlink" title="属性和HTML的修改和查找"></a>属性和HTML的修改和查找</h3><p>属性和HTML的修改和查找的实现非常相似，同样都可以通过判断arguments的长度来确定对应的功能，然后相应地实现即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line">elements.__proto__.attr = <span class="function"><span class="keyword">function</span> (<span class="params">attr, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对每个dom添加属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.setAttribute(attr, value))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回第一个dom的属性值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>].getAttribute(attr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HTML内容</span></span><br><span class="line">elements.__proto__.html = <span class="function"><span class="keyword">function</span> (<span class="params">htmlValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.innerHTML = htmlValue)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>].innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件的添加"><a href="#事件的添加" class="headerlink" title="事件的添加"></a>事件的添加</h3><p>事件添加和属性添加其实本质上是相同的，只是将属性替换成了回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elements.__proto__.click = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.addEventListener(<span class="string">&#x27;click&#x27;</span>,callback))</span><br><span class="line">&#125;</span><br><span class="line">elements.__proto__.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventName,callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.addEventListener(eventName,callback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css添加"><a href="#css添加" class="headerlink" title="css添加"></a>css添加</h3><p>最后处理一下稍微复杂一些的css添加函数</p><p>css添加有两种，一种是只有两个字符串作为参数，另一种是将css对象作为参数，我们根据这两种情况分别处理即可，具体方式见如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">elements.__proto__.css = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>)&#123;</span><br><span class="line">        elements.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.style[<span class="built_in">arguments</span>[<span class="number">0</span>]] = <span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        elements.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> params = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)&#123;</span><br><span class="line">                item.style[key] = params[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码总览"><a href="#代码总览" class="headerlink" title="代码总览"></a>代码总览</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">    elements = [...elements]</span><br><span class="line">    <span class="comment">// 类名</span></span><br><span class="line">    elements.__proto__.addClass = <span class="function"><span class="keyword">function</span> (<span class="params">classname</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.classList.add(classname))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements.__proto__.removeClass = <span class="function"><span class="keyword">function</span> (<span class="params">classname</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.classList.remove(classname))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    elements.__proto__.attr = <span class="function"><span class="keyword">function</span> (<span class="params">attr, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.setAttribute(attr, value))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elements[<span class="number">0</span>].getAttribute(attr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HTML内容</span></span><br><span class="line">    elements.__proto__.html = <span class="function"><span class="keyword">function</span> (<span class="params">htmlValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.innerHTML = htmlValue)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elements[<span class="number">0</span>].innerHTML</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事件添加</span></span><br><span class="line">    elements.__proto__.click = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.addEventListener(<span class="string">&#x27;click&#x27;</span>,callback))</span><br><span class="line">    &#125;</span><br><span class="line">    elements.__proto__.on = <span class="function"><span class="keyword">function</span>(<span class="params">eventName,callback</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.addEventListener(eventName,callback))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// css修改</span></span><br><span class="line">    elements.__proto__.css = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">2</span>)&#123;</span><br><span class="line">            elements.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.style[<span class="built_in">arguments</span>[<span class="number">0</span>]]=<span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length==<span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            elements.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> params = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)&#123;</span><br><span class="line">                    item.style[key] = params[key]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，50来行代码我们就完成了一个简易的jQuery，封装的时候特别要注意的一点就是方法的返回值，也就是上述代码中频繁出现的<code>return this</code>，在元素修改后需要将其返回出去，这样才能实现jQuery链式操作特性</p><p>就写到这吧，晚安</p>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遥感图像树木检测综述</title>
      <link href="2021/03/22/treeDetection/"/>
      <url>2021/03/22/treeDetection/</url>
      
        <content type="html"><![CDATA[<p>最近要开题，对遥感图像树木检测内容做个整理，包括遥感图像，目标检测，树木检测的一些传统方法和近期文章</p><h2 id="树木检测传统方法"><a href="#树木检测传统方法" class="headerlink" title="树木检测传统方法"></a>树木检测传统方法</h2><p>树木检测的传统方法感觉更偏向于针对特定问题的奇技淫巧，各种优化换个地儿就不行了，泛化性不高</p><h3 id="区域生长法"><a href="#区域生长法" class="headerlink" title="区域生长法"></a>区域生长法</h3><p>区域生长法，又名种子填充法，顾名思义，就是在图像中不停地去选定种子点，向周围寻找像素层面上接近的像素块或者区域，形成新的更大的区域，直到不能再继续扩展后停止。区域生长法有三个重要的部分，种子点的选定，生长规则的确定，以及扩展的终止条件。</p><p>种子点的选定通常采用人工选择的起始像素点或者局部最大值法</p><p>局部最大值法主要分为固定窗口和动态窗口两类</p><p><strong>固定窗口局部最大值</strong></p><details green open><summary> 🌲 Image modelling of forest changes associated with acid mine drainage </summary>              <div class='content'>              <div class="note green no-icon flat"><p><strong>图像预处理</strong></p><ol><li>图像平滑处理 (高斯滤波)</li><li>树冠边缘增强处理</li></ol></div><p>滑动窗口大小固定为$3\times3$，检测图中像素的局部最大值作为候选顶点，根据树冠间距来过滤异常点，得到最终的种子点</p>              </div>            </details><p><strong>动态窗口局部最大值</strong></p><details green open><summary> 🌲 TIDA: An algorithm for the delineation of tree crowns in high spatial resolution remotely sensed imagery </summary>              <div class='content'>              <p>在滑动窗口的局部最大值上记录<strong>频数</strong>，在窗口上下左右方向进行扩展，扩展窗口中若出现局部最大值，则频数加一，最后频数越高，该点为树冠顶点的概率就越高</p><p>需要设置<strong>全局频数阈值</strong>来筛选得到最终的树冠顶点集，因为全局阈值条件苛刻，该方法泛用性不高</p>              </div>            </details><details green open><summary> 🌲 Automated tree crown detection and delineation in high-resolution digital camera imagery of coniferous forest regeneration </summary>              <div class='content'>              <p>分析局部样条，使用样条数据中的最大变化率点来估计树冠边界，边界敏感，对于具有明显轮廓信息的树木检测效果较好，具体使用中实验参数过多，极度依赖于专家的先验知识</p>              </div>            </details><h3 id="分水岭法"><a href="#分水岭法" class="headerlink" title="分水岭法"></a>分水岭法</h3><p>分水岭法是一种基于形态学的图像处理方法，基本思想是将数字图像看做地质测量学中的地形图，将像素点的灰度值作为该点的高度，高点为分水岭，低点为山谷，当模拟降水时，随着水量的增加，山谷区域的水的高度会超过分水岭的高度，合并为一个区域。分水岭法是用于在确定树冠中心点的情况下描绘树冠轮廓，需要结合局部最大值来使用</p><details green open><summary> 🌲 Individual Tree-Crown Delineation and Treetop Detection in High-Spatial-Resolution Aerial Imagery </summary>              <div class='content'>              <p>采用最小有效尺度下的拉普拉斯高斯边缘检测方法，然后进行标记控制的分水岭分割</p><p>标记控制：假定树梢为局部极大值，用导出的树冠创建标记图像来指导分水岭分割</p>              </div>            </details><details green open><summary> 🌲 On the use of binary partition trees for the tree crown segmentation of tropical rainforest hyperspectral images </summary>              <div class='content'>              <p>提出一种基于二叉分割树(BPT)算法的高光谱图像分割方法</p><p>构造BPT之前采用分水岭变换和均值漂移聚类等多种超像素方法来降低空间维数</p>              </div>            </details><h3 id="模板匹配法"><a href="#模板匹配法" class="headerlink" title="模板匹配法"></a>模板匹配法</h3><p>将图像内容和模板库中的模板进行相似度计算，滑动窗口内图像与模板树木近似度高于设定阈值时默认窗口内是一棵树</p><details green open><summary> 🌲 Automatic Stem Mapping in Three Dimensions by Template Matching from Aerial Photographs </summary>              <div class='content'>              <p>模板匹配算法，用于在树叶脱落情况下生成三维森林树干图，介绍了一种人工生成模板的完备算法</p>              </div>            </details><hr><h2 id="目标检测方法"><a href="#目标检测方法" class="headerlink" title="目标检测方法"></a>目标检测方法</h2><p>目标检测的通用方法的各种变型就相当多了，稍微记录总结一下看过的一些特别常用的主流方法，论文相对比较好找，不贴论文题目了 (贴起来好长，排版巨丑)</p><style>    .smallblock{        background-color: #fff;        border: 2px solid orange;        padding: 10px;        margin: 10px 0;        border-radius: 10px;    }    .blocktitle{        font-size: 16px;        color: darkorange;    }</style><h3 id="R-CNN系列"><a href="#R-CNN系列" class="headerlink" title="R-CNN系列"></a>R-CNN系列</h3><details red open><summary> 🍊 R-CNN </summary>              <div class='content'>              <p>Selective Search得到候选框，归一化候选框(先以padding=16扩充，然后进行拉伸)</p><p>在ILSVRC2012数据集上预训练，然后将1000路分类层替换为随机的N+1路分类层</p><p>对每个类别训练一个SVM分类器 (CNN容易过拟合，需要大量样本，宽松标注，SVM支持少量样本训练，阈值可以放低，因为CNN部分宽松标注分类精度低，所以需要接SVM)</p><p>极大值抑制去除多余的框</p>              </div>            </details><details red open><summary> 🍊 SPP-net </summary>              <div class='content'>              <p>SPP-net算是R-CNN的改良版，核心思想是从feature map中提取ROI特征，而不是先提取候选框特征再扔进CNN里面做卷积操作</p><p>SPP-net用空间金字塔池化方法得到大小固定的输出 (特征图不能直接拉伸的问题得到解决)</p>              </div>            </details><details red open><summary> 🍊 Fast R-CNN </summary>              <div class='content'>              <p>沿用了SPPnet将整张图作为CNN输入来提取特征的方法，但是用ROI池化层代替了SPPLayer (将ROI窗口划分为固定数量的小块，每个小块输出对应网格单元计算结果，以得到固定大小的输出)</p><p>分类和回归放在一起训练</p>              </div>            </details><details red open><summary> 🍊 Faster R-CNN </summary>              <div class='content'>              <p>用RPN来替代耗时巨大的Selective Search，RPN本质上就是在图上打满手工锚框，替代搜索 (9个基础框，然后平移)</p>              </div>            </details><details red open><summary> 🍊 Mask R-CNN </summary>              <div class='content'>              <p>采用特征金字塔FPN，首先自底向上提取语义信息，然后依次进行上采样将浅层定位细节与上采样的高层语义结合 (逐元素相加)，最后用3*3卷积做融合 (消除上采样的重叠效应)</p><p>用ROI-Align替代ROI-Pooling，解决Missalignment问题</p>              </div>            </details><details red open><summary> 🍊 Cascade R-CNN </summary>              <div class='content'>              <p>既然单一IoU阈值没法适配所有的情况，那就多整几个<br>—— Cascade R-CNN</p><p>多个RCNN回归级联适配了更多阈值的proposals</p>              </div>            </details><h3 id="YOLO系列"><a href="#YOLO系列" class="headerlink" title="YOLO系列"></a>YOLO系列</h3><details red open><summary> 🍌 YOLOv1 </summary>              <div class='content'>              <p>核心思想：将输入的图像划分成S×S的格子，如果检测物体的中心在某个格子内，那个这个格子就负责检测这个物体</p><p>所以最多只能预测S×S个物体</p>              </div>            </details><details red open><summary> 🍌 YOLOv2 </summary>              <div class='content'>              <div class="smallblock"><p><strong>更精准</strong> 批标准化BN代替Dropout，从高分辨率迁移学习，采用带锚框的卷积 (YOLO中为每个格子预测类别，YOLOv2为每个锚框预测类和对象)，聚类提取锚框尺寸，偏移公式优化，细粒度检测</p></div><div class="smallblock"><p><strong>更快</strong> 不再使用VGGnet而是提出了Darknet-19 (19conv+5maxpooling)</p></div><div class="smallblock"><p><strong>更强</strong> 构建WordTree，识别9000种类物体</p></div>              </div>            </details><details red open><summary> 🍌 YOLOv3 </summary>              <div class='content'>              <p>用sigmoid替换softmax，可以实现多标签预测</p><p>结合多卷积层特征，可以多尺度预测</p><p>网络引入ResNet结构</p>              </div>            </details><h3 id="SSD系列"><a href="#SSD系列" class="headerlink" title="SSD系列"></a>SSD系列</h3><details red open><summary> 🍎 SSD </summary>              <div class='content'>              <div class="smallblock"><p><strong>核心思想</strong>：浅层特征图包含着位置信息，对于目标定位非常重要，深层的特征图包含大量的语义信息，对图像目标的分类具有重要的意义</p></div><div class="smallblock"><p><strong>具体做法</strong>：用不断下采样得到的特征图<strong>分别</strong>进行检测</p></div>              </div>            </details><details red open><summary> 🍎 DSSD </summary>              <div class='content'>              <p>利用反卷积将特征图进行上采样，与原始的特征图进行融合，得到的特征图分别进行检测</p><p>解决了SSD中因为浅层语义信息不够而导致的小目标检测不佳的问题 </p>              </div>            </details><details red open><summary> 🍎 RfbNet </summary>              <div class='content'>              <p>利用inception与空洞卷积相结合得到感受野模块(rfb)，将rfb应用于ssd算法的特征图的头部，对处理后的特征图进行预测</p>              </div>            </details><h3 id="Free-Anchor方法"><a href="#Free-Anchor方法" class="headerlink" title="Free-Anchor方法"></a>Free-Anchor方法</h3><p>该部分了解较少，最近还要看些paper和code</p><details red open><summary> 🍍 CenterNet </summary>              <div class='content'>              <p>将目标当做点，锚框 $\to$ 锚点，选取热力图上前百个峰值点作为中心点，因为没有锚框，所以不需要手动设置IOU，每个目标只有一个正锚点，不需要做NMS</p>              </div>            </details><h2 id="遥感检测方法"><a href="#遥感检测方法" class="headerlink" title="遥感检测方法"></a>遥感检测方法</h2><details yellow open><summary> 🏙️ Building Detection from Satellite Imagery using Ensemble of Size-Specific Detectors </summary>              <div class='content'>              <p>遥感建筑物检测</p><p>多任务模型，学习多个探测器，每个探测器用于特定大小的建筑物</p><p>隐式利用上下文，同时训练道路提取任务和建筑检测任务</p>              </div>            </details><details yellow open><summary> 🚘 R^3-Net: A Deep Network for Multioriented Vehicle Detection in Aerial Images and Videos </summary>              <div class='content'>              <p>多目标车辆检测</p><p>可旋转区域残差网络，生成可旋转的矩形目标框 (可旋转区域建议网络R-RPN处理feature-map得到R-Rois，然后用可旋转检测网络R-DN来进行分类和回归)</p>              </div>            </details><details yellow open><summary> 🚢 HSF-Net: Multiscale Deep Feature Embedding for Ship Detection in Optical Remote Sensing Imagery </summary>              <div class='content'>              <p>舰船遥感图像检测</p><p>采用分层选择滤波层，将不同尺度的特征映射到同一尺度空间，解决不同尺度舰船检测的问题</p>              </div>            </details><details yellow open><summary> 🚢 Position Detection and Direction Prediction for Arbitrary-Oriented Ships via Multiscale Rotation Region Convolutional Neural Network </summary>              <div class='content'>              <p>舰船遥感图像检测</p><p>Dense FPN + ROI + 旋转bbox回归 + 船头方向预测 + 旋转NMS评价</p>              </div>            </details><details yellow open><summary> ✈️ Weakly Supervised Learning Based on Coupled Convolutional Neural Networks for Aircraft Detection </summary>              <div class='content'>              <p>CNN提取对象的高级特征和层次特征表示</p><p>迭代弱监督学习框架，从原始图像中自动挖掘和扩充训练数据集</p><p>耦合RPN和定位网络，提取建议并同时定位飞机</p>              </div>            </details><details yellow open><summary> 📷 Multiscale Visual Attention Networks for Object Detection in VHR Remote Sensing Images </summary>              <div class='content'>              <p>解决目标旋转缩放，背景杂乱的问题</p><p>提取多尺度特征，对每个尺度特征学习一个注意力网络，高亮目标区域，抑制噪声，热图 (目标框内为1，框外为0) 点乘特征图</p>              </div>            </details><details yellow open><summary> 📷 Object Detection in Very High-Resolution Aerial Images Using One-Stage Densely Connected Feature Pyramid Network </summary>              <div class='content'>              <p>用密集连接的FPN解决多尺度问题</p>              </div>            </details><details yellow open><summary> 📷 DOTA: A Large-Scale Dataset for Object Detection in Aerial Images </summary>              <div class='content'>              <p>提出DOTA遥感数据库，有矩形和多边形的标注，允许倾斜</p>              </div>            </details><details yellow open><summary> 🚶 Clustered Object Detection in Aerial Images </summary>              <div class='content'>              <p>无人机图像行人检测 (目标像素少，难以和背景区分，分布稀疏，不均匀，检测效率低)</p><p>提出ClusDet集群检测网络 (集群提议子网络CPNet减少目标检测块的数量，尺度估计子网络ScaleNet提高小目标检测精度，检测网络DetecNet集群proposal隐式利用上下文信息提高检测准确率)</p>              </div>            </details><details yellow open><summary> 📷 Deep Adaptive Proposal Network for Object Detection in Optical Remote Sensing Images </summary>              <div class='content'>              <p><strong>问题</strong>：遥感中目标稀疏稠密情况是复杂的，相同区域生成策略效果不佳</p><p>提出深度自适应建议网络DAPNet，用类别先验网络CPN生成类别数量，给RPN一个类别数量的先验，mAP提升4.4%</p>              </div>            </details><details yellow open><summary> 📷 Object Detection in Remote Sensing Images Based on a Scene-Contextual Feature Pyramid Network </summary>              <div class='content'>              <p>FPN提取ROI的特征图，将整幅图的特征图和ROI的特征进行融合，得到上下文信息，分别经过分类得到结果</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLT：遥感图像多尺度检测</title>
      <link href="2021/03/18/YOLT/"/>
      <url>2021/03/18/YOLT/</url>
      
        <content type="html"><![CDATA[<p>本文是对YOLT算法论文的总结和解读，论文主要是根据遥感卫星图的特点对YOLOv2的算法进行了改进，针对遥感卫星图目标检测的几个难点提出了解决方案</p><h2 id="卫星遥感图像目标检测难点"><a href="#卫星遥感图像目标检测难点" class="headerlink" title="卫星遥感图像目标检测难点"></a>卫星遥感图像目标检测难点</h2><p>文中主要总结了遥感图像目标检测中的四个难点</p><div class="note orange no-icon flat"><ol><li>目标对象小而密集 </li><li>旋转不变性问题</li><li>训练数据缺乏</li><li>分辨率问题</li></ol></div><p>在遥感图像中，我们所感兴趣的目标往往是非常小且密集聚集的(比如树木，停车场的汽车之类的)，而不像ImageNet数据集中那种典型的大而突出的物体</p><p>其次，遥感图像意味着从头顶观看，看到的对象可以有任何的方向，比如我们可以360度地去看一棵树的枝丫，但是在ImageNet数据集中的树都是竖直的能看到整棵树的</p><p>对于卫星遥感来说，还有一个问题就是，图像是巨大的，不能简单地降采样到常用的大多数算法需要的输入大小</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLT-2.png"></p><p>下表是常用算法的输入大小和卫星遥感图像的大小</p><table><thead><tr><th>类别</th><th>大小</th></tr></thead><tbody><tr><td><strong>Faster R-CNN</strong></td><td>$1000 \times 600$</td></tr><tr><td><strong>SSD</strong></td><td>$300 \times 300$ 或 $512 \times 512$</td></tr><tr><td><strong>YOLO</strong></td><td>$416 \times 416$ 或 $544 \times 544$</td></tr><tr><td><strong>卫星遥感图像</strong></td><td>$16000 \times 16000$</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="YOLO2的问题与YOLT的改进"><a href="#YOLO2的问题与YOLT的改进" class="headerlink" title="YOLO2的问题与YOLT的改进"></a>YOLO2的问题与YOLT的改进</h2><p>文中作者用一张图来清晰地表示YOLT的针对性改进</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLT-3.png"></p><p>图的左边是YOLO2的问题，右边是YOLT的改进</p><p>首先是YOLO2的泛化性问题，用YOLO2作者的话来说就是难以泛化物体至非常规状态 (遥感情况下360转圈)，这个问题的解决方案就是扩充训练数据，缩放以及旋转</p><p>其次就是难点中提到的小目标检测问题，解决方案是构建一个最终网格更紧密的网络模型，对小目标上采样以及使用不同尺度的检测器，这些做法同样解决了YOLO2中多次下采样的问题</p><p>最后是尺度问题，解决方案有，图像切块以及不同尺度检测器结合</p><h2 id="图像切块方法"><a href="#图像切块方法" class="headerlink" title="图像切块方法"></a>图像切块方法</h2><p>作者将任意大小的测试图像分割成了可管理的切割块，用模型运行每个切割块，分块操作通过滑窗来实现，默认重叠15%</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLT-4.png"></p><p>而在检测中，最后一步将这些块缝合到最终图像中，15%的重叠确保所有的区域被检测，但同时会导致切口边界上的重叠检测，文中采用了非最大值抑制应用于全局矩阵，减轻重叠检测</p><h2 id="多尺度检测器"><a href="#多尺度检测器" class="headerlink" title="多尺度检测器"></a>多尺度检测器</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLT-5.png"></p><p>通用模型在不同尺度的目标上效果是较差的，比如上图的机场飞机检测就会出现目标的误检，所以文中基于不同尺度图像训练两个检测模型，通过融合不同模型的结果达到最优效果</p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>模型如下，采用22层的16倍下采样结构，用跳链来提高小目标的保真度，在最后一个卷积层上连接一个52*52层，以扩展特征图的细粒度特征</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLT-6.png"></p><hr><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1805.09512"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> one-stage </tag>
            
            <tag> 遥感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas实现简单刮刮乐效果</title>
      <link href="2021/03/15/lottery/"/>
      <url>2021/03/15/lottery/</url>
      
        <content type="html"><![CDATA[<p>本文主要是使用canvas实现刮刮乐的效果</p><p>最终效果见如下链接</p><div class="site-card-group"><a class="site-card" href="https://forever97.github.io/Web-Learning/lottery/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/lottery.png"/></div><div class="info"><span class="title">刮刮乐</span></div></a></div><br/><h2 id="Canvas图像合成属性"><a href="#Canvas图像合成属性" class="headerlink" title="Canvas图像合成属性"></a>Canvas图像合成属性</h2><p>在实现刮刮乐之前首先介绍一下canvas一个非常厉害的属性，图像合成globalCompositeOperation</p><p>这个属性是设置在画笔上的，设置方式为<code>ctx.globalCompositeOperation = [属性值] </code></p><p>我们称原来画板上的图像为原图像，新画的为目标图像，属性值和效果如下表</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>source-over</td><td>默认值，目标图像覆盖原图像</td></tr><tr><td>source-atop</td><td>目标图像外的原图像不可见</td></tr><tr><td>source-in</td><td>只显示与原图像交集部分的目标图像，原图像透明</td></tr><tr><td>source-out</td><td>只显示不与原图像相交的部分的目标图像，原图像透明</td></tr><tr><td>destination-over</td><td>原图像覆盖目标图像</td></tr><tr><td>destination-atop</td><td>原图像外的目标图像不可见</td></tr><tr><td>destination-in</td><td>只显示与目标图像交集部分的原图像，目标图像透明</td></tr><tr><td>destination-out</td><td>只显示不与目标图像相交的部分的原图像，目标图像透明</td></tr><tr><td></td><td></td></tr></tbody></table><p>可以看出source开头的都是目标图像显示为主，destination都是原图像显示为主</p><p>这里想要实现刮刮乐功能，其实就是利用了destination-out属性值，用一张灰色的原图当成刮刮乐需要刮除的层，当我们开始刮的时候本质上就是在原图上画目标图像，让原图只显示不与目标图像相交的部分，即刮过(画了目标图像)的原图区域透明</p><h2 id="刮刮乐实现"><a href="#刮刮乐实现" class="headerlink" title="刮刮乐实现"></a>刮刮乐实现</h2><p>按照刚才分析的，我们需要现在画布上画一个灰色的刮卡区域，这个图层可以画在某个显示文字或者图片的div之上，这样子挂完之后就可以显示对应的文字了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath()</span><br><span class="line">ctx.globalCompositeOperation = <span class="string">&quot;source-over&quot;</span></span><br><span class="line">ctx.fillStyle = <span class="string">&quot;grey&quot;</span></span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">100</span>)</span><br><span class="line">ctx.stroke()</span><br><span class="line">ctx.closePath()</span><br></pre></td></tr></table></figure><p>接下来实现一下刮卡的功能，我们以鼠标在画板上的位置为中心来不停地画一个小圆圈，来模拟手指刮卡的过程，具体实现过程见下方代码及注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能否刮卡</span></span><br><span class="line"><span class="keyword">var</span> canDarw = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 鼠标点击激活刮卡功能</span></span><br><span class="line">c1.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canDraw = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鼠标松开或者移出关闭刮卡功能</span></span><br><span class="line">c1.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canDraw = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">c1.onmouseout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canDraw = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听鼠标移动画圆</span></span><br><span class="line">c1.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canDraw) &#123;</span><br><span class="line">        ctx.beginPath()</span><br><span class="line">        <span class="keyword">var</span> x = evt.pageX - c1.offsetLeft;</span><br><span class="line">        <span class="keyword">var</span> y = evt.pageY - c1.offsetTop;</span><br><span class="line">        ctx.globalCompositeOperation = <span class="string">&quot;destination-out&quot;</span></span><br><span class="line">        ctx.arc(x, y, <span class="number">20</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">        ctx.fill()</span><br><span class="line">        ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手机端的手指触控同理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手指触控</span></span><br><span class="line">c1.ontouchstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    canDraw = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">c1.ontouchend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    canDraw = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">c1.addEventListener(<span class="string">&quot;touchmove&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([evt])</span><br><span class="line">    <span class="keyword">if</span> (canDraw) &#123;</span><br><span class="line">        ctx.beginPath()</span><br><span class="line">        <span class="keyword">var</span> x = evt.touches[<span class="number">0</span>].pageX - c1.offsetLeft;</span><br><span class="line">        <span class="keyword">var</span> y = evt.touches[<span class="number">0</span>].pageY - c1.offsetTop;</span><br><span class="line">        ctx.globalCompositeOperation = <span class="string">&quot;destination-out&quot;</span></span><br><span class="line">        ctx.arc(x, y, <span class="number">20</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">        ctx.fill()</span><br><span class="line">        ctx.closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>刮层下文字的显示就比较简单的，想要起到抽奖的效果只要每次随机roll一个数字，把对应数组中的内容替换到刮层下的dom元素中，roll数字可以用随机数(0到1)乘上数组长度，然后下取整作为抽取数字即可</p>]]></content>
      
      
      <categories>
          
          <category> 🎵Canvas乐坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas视频播放器</title>
      <link href="2021/03/15/watermark/"/>
      <url>2021/03/15/watermark/</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas实现视频播放器"><a href="#Canvas实现视频播放器" class="headerlink" title="Canvas实现视频播放器"></a>Canvas实现视频播放器</h2><p>我们先用Canvas来实现一个基础的具有播放和暂停功能的播放器</p><p>首先，Canvas是不能画一个视频的，这是一个画画的工具，他只能一幅一幅图去画，因此用Canvas实现一个播放器本质上就是将视频中的帧每隔一段时间就画出来</p><p>我们先画一个和视频等大的canvas画布，并把视频播放器本身消除掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;video/1.mp4&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;450&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">style</span>=<span class="string">&quot;background-color: black;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;450&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们需要先把播放和暂停的功能给到canvas上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视频，画布对象，创建画笔</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#c1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在画布上输入文字</span></span><br><span class="line">ctx.font = <span class="string">&quot;bold 50px 微软雅黑&quot;</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;#ddd&quot;</span></span><br><span class="line">ctx.fillText(<span class="string">&quot;💿点击播放&quot;</span>, <span class="number">280</span>, <span class="number">220</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// canvas点击事件监听</span></span><br><span class="line">canvas.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (video.paused) &#123;</span><br><span class="line">        video.play()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        video.pause()</span><br><span class="line">        <span class="comment">// 暂停时显示💿暂停</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(intervalId)</span><br><span class="line">        ctx.font = <span class="string">&quot;bold 50px 微软雅黑&quot;</span>;</span><br><span class="line">        ctx.fillStyle = <span class="string">&quot;#ddd&quot;</span></span><br><span class="line">        ctx.fillText(<span class="string">&quot;💿暂停&quot;</span>, <span class="number">280</span>, <span class="number">220</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们通过点击画布就可以实现视频的播放和暂停，但注意是视频本身的播放，而并不是画布，画布上除了播放和暂停依然是空无一物，接下来我们要在画布上将播放中的视频帧画出来</p><p>我们希望一秒播放60帧，计算一下大概16到17秒就要播放一帧，我们设置一个时间间隔函数让画布定期把视频帧画出来，这样播放器的基本功能就实现了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听video播放</span></span><br><span class="line">video.onplay = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">450</span>)</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频水印的添加"><a href="#视频水印的添加" class="headerlink" title="视频水印的添加"></a>视频水印的添加</h2><p>视频水印本质上就是在画布画出来的那一帧上继续画张图，我们随便找一张图，将它载入 (新建一个img对象，修改src)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">&quot;img.png&quot;</span></span><br></pre></td></tr></table></figure><p>这个图片应该要在每一帧画完之后画上</p><p>同时，希望水印动起来 (增加别人去水印的难度2333)，于是我选择每两百帧把水印换个位置再画上去，所以只需要修改一下video的播放监听函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">video.onplay = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">450</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">0</span>) ctx.drawImage(img, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">1</span>) ctx.drawImage(img, <span class="number">400</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">2</span>) ctx.drawImage(img, <span class="number">400</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">3</span>) ctx.drawImage(img, <span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子就能实现水印功能</p><h2 id="视频弹幕发送"><a href="#视频弹幕发送" class="headerlink" title="视频弹幕发送"></a>视频弹幕发送</h2><p>弹幕的发送和水印的原理差不多，就是让文字在每一帧逐渐从最右边移动到最左边</p><p>我们需要一个数组将所有发送的弹幕都保存下来，然后让他们从右边飘到左边去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取发送按钮dom</span></span><br><span class="line"><span class="keyword">var</span> sendBtn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#sendBtn&#x27;</span>)</span><br><span class="line"><span class="comment">// 弹幕输入框dom</span></span><br><span class="line"><span class="keyword">var</span> dmInput = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#dmInput&#x27;</span>);</span><br><span class="line"><span class="comment">// 弹幕数组</span></span><br><span class="line"><span class="keyword">var</span> danmulist = [];</span><br></pre></td></tr></table></figure><p>当点击发送弹幕时，我们需要做的就是获取弹幕输入框中的内容，去生成一个弹幕并压入数组，生成的时候初始位置在最后边，同时竖直方向上选取一个随机位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sendBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(sendBtn)</span><br><span class="line">    <span class="keyword">var</span> danmu = &#123;</span><br><span class="line">        value:dmInput.value,</span><br><span class="line">        x:<span class="number">800</span>,</span><br><span class="line">        y:<span class="built_in">Math</span>.random()*<span class="number">450</span></span><br><span class="line">    &#125;</span><br><span class="line">    danmulist.push(danmu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弹幕在视频上的移动则需要小修一下之前画帧的函数，在每一帧画出之后，让弹幕列表中的每条弹幕往左移动一丢丢，然后打印在画布上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">video.onplay = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">450</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">0</span>) ctx.drawImage(img, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">1</span>) ctx.drawImage(img, <span class="number">400</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">2</span>) ctx.drawImage(img, <span class="number">400</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor(cnt / <span class="number">100</span>) % <span class="number">4</span> == <span class="number">3</span>) ctx.drawImage(img, <span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="comment">// 弹幕发送</span></span><br><span class="line">        ctx.font = <span class="string">&quot;30px 微软雅黑&quot;</span>;</span><br><span class="line">        ctx.fillStyle = <span class="string">&quot;#fff&quot;</span></span><br><span class="line">        danmulist.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,i</span>)</span>&#123;</span><br><span class="line">            item.x--;</span><br><span class="line">            ctx.fillText(item.value,item.x,item.y)</span><br><span class="line">            ctx.strokeText(item.value,item.x,item.y)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以愉快地发送弹幕了 (虽然是本地的)</p>]]></content>
      
      
      <categories>
          
          <category> 🎵Canvas乐坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小玩具：派大星轮播图</title>
      <link href="2021/03/05/jsSwiper/"/>
      <url>2021/03/05/jsSwiper/</url>
      
        <content type="html"><![CDATA[<p>本文主要是实现轮播图并将其封装为一个插件</p><p>最终效果见如下链接</p><div class="site-card-group"><a class="site-card" href="https://forever97.github.io/Web-Learning/swiper/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/jsSwiper-1.png"/></div><div class="info"><span class="title">PatrickStar</span><span class="desc">派大星轮播图</span></div></a></div><br/><div class="note orange no-icon flat"><ol><li>每张图对应底下的小圆点，点击小圆点会高亮并跳转到对应图片</li><li>左右两侧的按钮可以返回上一张图片或者进入下一张图片</li><li>当鼠标离开轮播图区域时，进入自动轮播模式</li></ol></div><h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><p>以下是轮播图的html框架，轮播图框中包含三部分内容，图片列表，前进后退按钮以及圆点列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;preBtn&quot;</span>&gt;</span> &lt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nxtBtn&quot;</span>&gt;</span> &gt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;imgList&quot;</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgItem active&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/3.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/4.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/5.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;imgItem&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circleList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle choose&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><p>然后我们来设置CSS部分</p><p>首先设置轮播框的css，我们选用金色作为其外框，定位选择relative，方便内部小圆点和前进后退按钮的absolute定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.swiper</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border</span>: gold solid <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后画上两个按钮，我们在html中设置<code>&lt;</code>和<code>&gt;</code>作为两个按钮的符号</p><p>按钮用父元素<code>swiper</code>的长宽和自身长宽的一半来计算定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.preBtn</span>,</span><br><span class="line"><span class="selector-class">.nxtBtn</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">97</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">0.6</span>);</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 消除文字选中效果 */</span></span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.preBtn</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">25px</span>);</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nxtBtn</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">25px</span>);</span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">35px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把圆点列表也定位上去，<code>choose</code>类用来给小圆点附加高亮状态，以下是我第一次实现时候的css代码，在五张图片的时候能够完成需求，但是图片数量变化的时候泛用性就不太好，我们在下文再来修改它</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circleList</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">270px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">97</span>, <span class="number">63</span>, <span class="number">0</span>, <span class="number">0.6</span>);</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.choose</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">115</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们将图片列表也定义上，这里在实现的时候也是有瑕疵的，用了固定高度和宽度，不太好封装</p><p>我们用active这个类给图片附加显示状态，不显示的图片设置为透明，为了让图片切换更加丝滑，我们给opacity这个属性设置1s的过渡时间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.imgList</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.imgItem</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: opacity <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样css部分就基本完成了</p><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><p>首先我们获取所有的图片和小圆点，两个按钮的dom，<strong>同时设置一个index表示当前选中的小圆点(图片)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imgsArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.imgItem&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> circleArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.circle&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.preBtn&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> nxtBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.nxtBtn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>对于图片的小圆点的切换，其实就是将原来的index的图片和圆点取消选中状态，给新的index的图片和圆点添加选中状态，所以这个取消和选中会在代码中反复使用，我们用两个函数来实现这个功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> remove=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    imgsArr[index].classList.remove(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">    circleArr[index].classList.remove(<span class="string">&quot;choose&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    imgsArr[index].classList.add(<span class="string">&quot;active&quot;</span>)</span><br><span class="line">    circleArr[index].classList.add(<span class="string">&quot;choose&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么nxt和pre按钮点击事件的实现就会变得非常简单，以nxt按钮为例，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nxtBtn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </span><br><span class="line">    remove()</span><br><span class="line">    index = (index + <span class="number">1</span>) % imgsArr.length</span><br><span class="line">    add()            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来实现小圆点点击的功能，同样可以利用这个remove和add</p><p>如果对每个小圆点添加点击事件的监听效率非常的低，因为点击事件可以向上冒泡，所以我们选择监听圆点列表，将事件<strong>委托</strong>给父级元素，通过target来判断点击了哪个小圆点，对图片和圆点状态做对应的切换即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> circleList = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.circleList&quot;</span>)</span><br><span class="line">circleList.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(evt.target.className == <span class="string">&quot;circle&quot;</span>)&#123;</span><br><span class="line">        remove()</span><br><span class="line">        index = <span class="built_in">parseInt</span>(evt.target.dataset.id)</span><br><span class="line">        add()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后来实现一个自动播放功能，我们用一个定时器来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    nxtBtn.click()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>我们希望在鼠标移入的时候停止自动播放，移出的时候开始自动播放</p><p>给swiper区域添加上对应的事件即可，鼠标移入时清除计时器，移开则重新设置计时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swiper = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.swiper&quot;</span>)</span><br><span class="line">swiper.onmouseenter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalId)</span><br><span class="line">&#125;</span><br><span class="line">swiper.onmouseleave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    intervalId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        nxtBtn.click()</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样轮播图功能就大致实现了</p><p>我们发现在点击按钮的时候，如果点击过快，图片切换效果并不好，因此我们设置一个图片切换的时间间隔，让图片不至于过快速切换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用以限制按钮生效的频率</span></span><br><span class="line"><span class="keyword">var</span> canClick = <span class="literal">true</span>;</span><br><span class="line">nxtBtn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(canClick)&#123;</span><br><span class="line">        canClick = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            canClick = <span class="literal">true</span></span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">        remove()</span><br><span class="line">        index = (index + <span class="number">1</span>) % imgsArr.length</span><br><span class="line">        add()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="制成插件"><a href="#制成插件" class="headerlink" title="制成插件"></a>制成插件</h2><p>对于经常使用的东西，我们可以将其制成插件，比如将轮播图功能制成一个插件，之后只要传入参数和图片就能生成一个新的轮播图</p><p>将轮播图制成插件需要能够根据不同的图片数量生成对应的圆点个数和图片dom数，同时原来html的元素要直接在js中生成</p><p>首先我们设置一下传入的参数，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swiper = <span class="keyword">new</span> Swiper(&#123;</span><br><span class="line">    name: <span class="string">&quot;#swiper&quot;</span>,</span><br><span class="line">    color: <span class="string">&quot;gold&quot;</span>,</span><br><span class="line">    imgs: [<span class="string">&#x27;img/1.png&#x27;</span>, <span class="string">&#x27;img/2.png&#x27;</span>, <span class="string">&#x27;img/3.png&#x27;</span>, <span class="string">&#x27;img/4.png&#x27;</span>, <span class="string">&#x27;img/5.png&#x27;</span>],</span><br><span class="line">    height: <span class="number">300</span>,</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们希望往Swiper函数中传入名字，边框颜色，图片和边框的长宽来生成个性化的轮播图</p><p>然后我们开始写这个Swiper函数，也就是我们的插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Swiper</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要在Swiper里面生成dom元素 (也就是原来在html中写的内容)</p><p>先将swiper框设置出来，并用参数中的长宽和颜色修改css属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swiper = <span class="built_in">document</span>.querySelector(options.name)</span><br><span class="line">swiper.classList.add(<span class="string">&#x27;swiper&#x27;</span>)</span><br><span class="line">swiper.style.height = options.height + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">swiper.style.width = options.width + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">swiper.style.borderColor = options.color</span><br></pre></td></tr></table></figure><p>然后我们设置图片列表和圆点列表的dom，之后根据图片数量往里面添加元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置circleList和imgList</span></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> imgList = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> circleList = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">imgList.className = <span class="string">&quot;imgList&quot;</span></span><br><span class="line">circleList.className = <span class="string">&quot;circleList&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dom添加到swiper</span></span><br><span class="line">swiper.appendChild(imgList)</span><br><span class="line">swiper.appendChild(circleList)</span><br></pre></td></tr></table></figure><p>添加图片dom和圆点部分如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每张图片生成对应dom和小圆点</span></span><br><span class="line">options.imgs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> imgItem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    imgItem.src = item</span><br><span class="line">    imgItem.className = i == index ? <span class="string">&#x27;imgItem active&#x27;</span> : <span class="string">&#x27;imgItem&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> circle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    circle.className = i == index ? <span class="string">&quot;circle choose&quot;</span> : <span class="string">&quot;circle&quot;</span></span><br><span class="line">    circle.setAttribute(<span class="string">&#x27;data-id&#x27;</span>, i)</span><br><span class="line">    imgList.appendChild(imgItem)</span><br><span class="line">    circleList.appendChild(circle)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后设置按钮</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按钮</span></span><br><span class="line"><span class="keyword">var</span> preBtn = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">preBtn.className = <span class="string">&quot;preBtn&quot;</span></span><br><span class="line">preBtn.innerText = <span class="string">&quot;&lt;&quot;</span></span><br><span class="line"><span class="keyword">var</span> nxtBtn = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">nxtBtn.className = <span class="string">&quot;nxtBtn&quot;</span></span><br><span class="line">nxtBtn.innerText = <span class="string">&quot;&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将按钮添加到swiper</span></span><br><span class="line">swiper.appendChild(nxtBtn)</span><br><span class="line">swiper.appendChild(preBtn)</span><br></pre></td></tr></table></figure><p>之后的操作就和之前js实现的部分一致，参照上文js实现部分即可</p><p>然后是将css添加到插件中来，我们可以要求插件使用者将css引入html文档，当然更方便的是将css直接添加到js中，我们只要生成一个style dom，添加到body元素中即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">&quot;style&quot;</span>)</span><br><span class="line"><span class="comment">// 两个反引号</span></span><br><span class="line">style.innerHTML = <span class="string">`[填入style部分]`</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(style)</span><br></pre></td></tr></table></figure><p>这里我们用两个反引号 (键盘右上角那个) 来引入样式，可以将多行放入两个反引号之中，直接从css中复制过来即可</p><p>这里的css需要做一下修改，更好地适配</p><p>首先是圆点列表的css属性，为了让图片数量变化的时候圆点列表能够不出问题，我们改变一下圆点排布方式</p><p>首先<code>float：left</code>肯定是不行的，因为这得设置圆点开始的位置，当圆点数量增加或者减少时看起来会特别奇怪，<code>float：right</code>则会使得圆点的编号是从右向左的，处理起来十分麻烦，所以我们放弃浮动布局，采用弹性布局，用<code>flex-end</code>来使得小圆点靠右侧</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circleList</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">98%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时将<code>imgList</code>和<code>imgItem</code>长宽改为100%，使得其能随着swiper参数的变化而变化</p><p>最后我们来检验一下我们的插件，插入七张图，边框颜色设置为<code>pink</code></p><p>就可以看到插件的效果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/jsSwiper-2.png"></p><p>宽高和边框颜色都如我们所料变化了</p><div class="tip success"><p>插件完成</p></div><p>我已将插件上传至github，有学习或使用需要可以下载，有任何问题欢迎评论</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/forever97/Swiper"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=forever97&repo=Swiper&theme=buefy&show_owner=true"/></a>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小玩具：海绵宝宝放大镜</title>
      <link href="2021/03/04/jsSpongeBob/"/>
      <url>2021/03/04/jsSpongeBob/</url>
      
        <content type="html"><![CDATA[<p>我们经常在淘宝类似的网站可以看到一个图片放大镜的功能，鼠标移动到一张商品图片上会有一个小遮罩，同时这个被遮罩的部分会在旁边放大显示，本文粗略地实现一下这个功能，作为JS的入门练习</p><p>最终效果见如下链接</p><div class="site-card-group"><a class="site-card" href="https://forever97.github.io/Web-Learning/spongeBob/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/jsSpongeBob-1.png"/></div><div class="info"><span class="title">SpongeBob</span><span class="desc">海绵宝宝放大镜</span></div></a></div><h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><p>首先我们设置一个常规的图片css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img.png);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">300px</span> <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: center center;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到一会儿需要有一个遮罩小块在这张图片上相对滑动，所以先将<code>position</code>属性设置为<code>relative</code></p><p>预想放大后的图片是和原图并在同一排，将<code>display</code>调整为行内块</p><p>然后我们将小块放上去，设置一个橙色的小方块，根据海绵宝宝脸部大小设置合适的长宽，设置定位属性为<code>absolute</code>以相对img定位，因为我们希望的是当鼠标移入图片的时候有个小方块遮罩跟随，因此先将小方块的<code>display</code>设置成<code>none</code>，当鼠标移入的时候再将其调整为block</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">157</span>, <span class="number">0</span>, <span class="number">0.603</span>);</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，设置放大后图片的位置和属性，同样先设置为<code>display: none</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid orange;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img.png);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">600px</span> <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将显示的部分长宽设置为遮罩块的两倍，同时图片的大小也需要是原来图片的两倍</p><h2 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h2><p>首先获取图片，遮罩，放大显示框的dom元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.img&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> mask = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.mask&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> big = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.big&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于遮罩块和放大区域的出现和消失只要监听鼠标移入图片区域和移出的事件即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    mask.style.display = <span class="string">&quot;block&quot;</span></span><br><span class="line">    big.style.display = <span class="string">&quot;inline-block&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">img.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    mask.style.display = <span class="string">&quot;none&quot;</span></span><br><span class="line">    big.style.display = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们监听鼠标的移动并根据鼠标位置调整遮罩块的位置以及放大区域的内容</p><p>具体的算法思路是</p><ol><li>获取鼠标的位置 (evt.pageX, evt.pageY)</li><li>计算遮罩的左上角位置 (利用遮罩的长宽)</li><li>计算放大区域图片背景的移动位置 (利用放大区域背景和原图的大小关系)</li></ol><p>具体代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">img.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 计算鼠标在盒子内的坐标</span></span><br><span class="line">    <span class="keyword">let</span> x = evt.pageX - <span class="built_in">this</span>.offsetLeft</span><br><span class="line">    <span class="keyword">let</span> y = evt.pageY - <span class="built_in">this</span>.offsetTop</span><br><span class="line">    <span class="comment">// 计算遮罩的左上角坐标值</span></span><br><span class="line">    <span class="keyword">let</span> maskX = x - mask.offsetWidth / <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> maskY = y - mask.offsetHeight / <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> widthMax = img.offsetWidth - mask.offsetWidth</span><br><span class="line">    <span class="keyword">var</span> heightMax = img.offsetHeight - mask.offsetHeight</span><br><span class="line">    <span class="comment">// 边界处理</span></span><br><span class="line">    maskX = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(<span class="number">0</span>,maskX),widthMax)</span><br><span class="line">    maskY = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(<span class="number">0</span>,maskY),heightMax)</span><br><span class="line">    mask.style.left = maskX + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    mask.style.top = maskY + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="comment">// 放大区域图片背景的左上角位置计算</span></span><br><span class="line">    big.style.backgroundPosition= -maskX*<span class="number">2</span> + <span class="string">&quot;px&quot;</span> + <span class="string">&quot; &quot;</span> + -maskY*<span class="number">2</span> +<span class="string">&quot;px&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>evt.pageX和evt.pageY可以获取鼠标在页面中的位置</p><p>offset参数是用于获取dom对象的偏移值的，如果父级元素(祖先元素)有定位属性，则<code>offsetTop</code>和<code>offsetLeft</code>是相对于父级元素的偏移，否则是相对于<code>body</code>元素的偏移，<code>offsetWidth</code>和<code>offsetHeight</code>则可以得到盒子的宽度和高度(包含padding，边框和内容)</p><p>利用这些信息，我们可以计算出鼠标相对于图片左上角的偏移，也就是我们需要的遮罩块的中心点的偏移，因为遮罩块的位置计算需要左上角坐标，因此还需要减去遮罩块长宽的一半</p><p>做完这一些，我们发现当遮罩块移动的时候可能会超出图片，因此我们还需要做一个边界处理，计算一下遮罩块最多可以移动的位置，做一个极大极小处理，这样子可以保证遮罩块在图片内，不会超出</p><p>而放大区域的处理就比较简单了，因为设置了放大区域的背景图片长宽是原图的两倍，所以遮罩块移动的距离就是放大区域背景图片移动距离的$\frac{1}{2}$，我们设置其两倍移动距离即可 (即左上角位置是-2*(x,y))</p><div class="tip success"><p>海绵宝宝放大镜完成</p></div>]]></content>
      
      
      <categories>
          
          <category> 🧸JS玩具屋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局方式</title>
      <link href="2021/02/26/cssLayout/"/>
      <url>2021/02/26/cssLayout/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS传统布局方式"><a href="#CSS传统布局方式" class="headerlink" title="CSS传统布局方式"></a>CSS传统布局方式</h2><p>用CSS来控制网页布局本质上就是用CSS来合理地摆放盒子，传统布局方式有三种机制：标准文档流，浮动布局和定位</p><h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><p>当没有任何的CSS来控制页面布局的时候，页面中的盒子就属于标准文档流，顾名思义，就是按照写文档的方式排列，从左到右，从上到下，<strong>块级元素</strong>独占一行，而<strong>行内元素</strong>会排列在行内，当触及父元素边缘时会自动换行</p><p>文档流是一种最基础的布局，避免了在无CSS情况下(CSS加载失败)盒子堆积在浏览器的左上角的情况，减轻了开发者的布局方式指定负担</p><p>而使用CSS的意义就是，做到标准文档流所不能做到的事情</p><h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><p>浮动布局的意思就是，让盒子漂浮在标准流的上面 (脱离文档流)</p><p>浮动的使用方式是 <code>css选择器&#123;float: 属性值&#125;</code></p><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>默认，不浮动</td></tr><tr><td><strong>left</strong></td><td>向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>向<strong>右</strong>浮动</td></tr></tbody></table><p>我们来看一个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.box1 {    width: 100px;    height: 100px;    background-color: pink;    float: left;}.box2 {    width: 200px;    height: 200px;    background-color: lightyellow;}</style><div class="box1"></div><div class="box2"></div><div class="box4"></div><br><p>可以发现浮动元素粉色的盒子漂浮在了正常文档流的上面，不占据文档流的位置，位置则让给了这个黄色的盒子</p><p>如果我们让这个黄色的盒子也浮起来，就可以得到一个<strong>紧密贴着</strong>排成一行的两个盒子 (正常的文档流的行内元素会有一个font的间距)，浮动会改变盒子的display属性，转换为了类似行内块的东西，但是元素之间没有空白缝隙 </p><style>.box3 {    width: 200px;    height: 200px;    background-color: lightyellow;    float: left;}.box4{    clear: both;}</style><div class="box1"></div><div class="box3"></div><div class="box4"></div><br><h4 id="浮动清除"><a href="#浮动清除" class="headerlink" title="浮动清除"></a>浮动清除</h4><p>使用浮动布局最常做的一件事就是<strong>清除浮动</strong></p><p>为什么要清除浮动呢，首先来看一个例子</p><p>当我在写这篇博客的时候，对于上述两个盒子的例子，在没有清除浮动的时候，文档的显示是这样的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cssLayout-2.png"></p><p>本应该希望出现在box下方的文字内容移了上来，这是因为浮动一开始就是用于实现图片文字环绕的，所以呈现出这样的效果</p><p>但是如果我们不希望浮动元素下方的内容受到浮动元素的影响，那么我们就需要<strong>清除浮动</strong></p><p>浮动还会带来一个影响就是<strong>父元素塌陷</strong>，有时候我们在写css的时候，并没有设置父元素的高度，而是希望用子元素把父元素<strong>撑开</strong>，那么当子元素浮动，脱离文档流之后，就失去了支撑父元素的能力，如果我们希望子元素依旧拥有把父元素撑开的能力，那么就需要清除浮动</p><p>所谓的清除浮动，指的就是清除<strong>浮动元素带来的影响</strong></p><p>下面介绍几种常见的清除浮动的方法：</p><ul><li>新建一个div元素来清除浮动</li></ul><p>比如刚才的例子，我们建立一个box4，加在最后面</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box4</span>&#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候下面的文字就能够按照我们所希望的在浮动元素下方正常显示</p><ul><li>用伪元素清除浮动</li></ul><p>用伪元素来清除浮动本质上和新建div是相同的，只是给希望清除浮动的父元素自动添加一个子节点，更加方便一些</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置一个类clear，给其设置一个after伪元素，对于需要清除浮动的父元素，我们只要给其添加一个类clear即可</p><ul><li>BFC清除浮动</li></ul><p>这个之前总结过，让元素形成BFC，上下文无关即可</p><div class="site-card-group"><a class="site-card" href="/2021/1/22/bfc/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BFC-1.png"/></div><div class="info"><span class="title">BFC详解</span></div></a></div><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位的作用是使得盒子可以根据<strong>参照点</strong>进行偏移，不同定位的方法本质上是选取不同的参照点</p><p>在定位position中用top，bottom， left，right来表示和参照点的距离，定位的默认值是static，静态定位，就是按照正常的文档流定位的意思</p><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位relative可以使得盒子相对于自己原来的位置进行定位</p><p>比如我们设置三个box，让中间的box相对自己原来的位置往下移动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-class">.box5</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box6</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box7</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure><p>就可以得到如下的效果</p><style>.boxall{    display: inline-block;    width: 320px;    height: 220px;}.box5 {    display: inline-block;    width: 100px;    height: 100px;    background-color: lightyellow;}.box6 {    display: inline-block;    width: 100px;    height: 100px;    background-color: lightgreen;    position: relative;    top: 100px;}.box7 {    display: inline-block;    width: 100px;    height: 100px;    background-color: lightblue;}</style><div class="boxall">    <div class="box5"></div>    <div class="box6"></div>    <div class="box7"></div></div><p>我们可以看到，即使绿色的盒子腾出了位置，蓝色的盒子也不会往左边靠，因为相对定位是不脱离文档流的，相对定位的元素其实还待在原来的位置上，只是<strong>看上去</strong>换了位置，对之后的元素也没有任何的影响</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位的参照点是<strong>最近的已定位的祖先元素</strong>，如果我们希望实现相对父元素定位，则父元素必须有定位值，否则元素会参照浏览器进行定位</p><p>绝对定位absolute是<strong>脱离文档流</strong>的，完全不占据任何位置，想相对参照点怎么放就怎么放</p><p>举个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box8</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box9</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.box8 {    display: inline-block;    width: 200px;    height: 200px;    background-color: lightyellow;    position: relative;}.box9 {    display: inline-block;    width: 100px;    height: 100px;    background-color: lightgreen;    position: absolute;    top: 50px;    left: 50px;}</style><div class="box8">    <div class="box9"></div></div><p>定位有一个重要的口诀叫”子绝父相”，意思就是子元素绝对定位则父元素一般需要相对定位，这样才能使得子元素相对于父元素定位，同时如果父元素也是绝对定位，则会影响到下方的元素 (整体上移)</p><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p>固定定位fixed的参照点是<strong>浏览器的可视窗口</strong>，也就是说，不会随着页面的上下滚动而移动，就比如博客右下角的看板娘以及回到首部这些功能都是由fixed来实现的，固定定位是脱离文档流的，和父元素没有任何关系，单独使用</p><h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>粘性定位sticky是一种比较特殊的定位方式，他可以先跟随文档流随着页面的滚动一起移动，当移动到特定的位置的时候，粘在那里不再移动，达到fixed一样的效果</p><div class="tip warning"><p>如果需要更复杂的定位效果，则可以使用js监听滚动事件来实现</p></div><h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><p>弹性布局 (flex) 是一种<strong>一维</strong>的布局方式，通过给父元素添加flex属性，能够使得父元素成为弹性容器，子元素则成为容器中的弹性项 (flex item)</p><p>因为是一维布局，父元素设置为弹性布局后，子元素的 float、clear 和 vertical-align 属性将失效</p><p>我们来简单地使用一下弹性布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">border</span>: orange solid <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><style>.container{    display: flex;    border: brown solid 2px;}.item{    width: 100px;    height: 100px;    background-color: orange;    margin: 5px;}</style><div class="container">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><h3 id="弹性布局的主轴方向"><a href="#弹性布局的主轴方向" class="headerlink" title="弹性布局的主轴方向"></a>弹性布局的主轴方向</h3><p>我们在上文的例子中可以看到弹性项在容器中能够<strong>横向</strong>顺序排列，因为在弹性布局中<strong>主轴</strong>默认是横向的 (row)</p><p>当然我们也可以用flex-direction属性来改变主轴的方向，使得弹性项在容器中纵向顺序排列</p><p>我们为container增添如下属性，就可以使得弹性容器的方向变为纵向 (column)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.plus</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><style>.plus{    flex-direction: column;    width: 120px;}</style><div class="container plus">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><p>flex-direction还有row-reverse和column-reverse两种属性值，可以改变弹性项的方向</p><p>比如为容器添加如下类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.direction</span>&#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能够使得元素倒过来排布，达到类似<code>float:right</code>的效果</p><style>.direction{    flex-direction: row-reverse;}</style><div class="container direction">    <div class="item">1</div>    <div class="item">2</div>    <div class="item">3</div></div><br><h3 id="主轴内容的排列方式"><a href="#主轴内容的排列方式" class="headerlink" title="主轴内容的排列方式"></a>主轴内容的排列方式</h3><p><code>justify-content</code>属性可以更改主轴内容的排列方式</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td><strong>flex-start</strong></td><td>默认值，从侧轴头部开始排列</td></tr><tr><td><strong>flex-end</strong></td><td>从侧轴尾部开始排列</td></tr><tr><td><strong>center</strong></td><td>水平居中</td></tr><tr><td><strong>space-between</strong></td><td>两侧弹性项贴边，剩余空间平分</td></tr><tr><td><strong>space-around</strong></td><td>平分剩余空间，两侧空间为间距一半</td></tr><tr><td></td><td></td></tr></tbody></table><p>我们来测试一下效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.start</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.end</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.between</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.around</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.start{    justify-content: flex-start;}.end{    justify-content: flex-end;}.center{    justify-content: center;}.between{    justify-content: space-between;}.around{    justify-content: space-around;}</style><div class="container start">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><div class="container end">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><div class="container center">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><div class="container around">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><div class="container between">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><h3 id="换行设置"><a href="#换行设置" class="headerlink" title="换行设置"></a>换行设置</h3><p>弹性布局默认是不换行的，如果弹性项超出了容器宽度，则会被强行压缩，比如我们给容器添加一个宽度类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.w</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器里橙色的小方块就会被压缩</p><style>.w{    width: 220px;}</style><div class="container w">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><p>如果我们希望超出去的部分换行，我们可以通过设置换行属性值 (flex-wrap), 默认值不换行 (no-wrap)，当我们将其改成换行的时候就能使得超出部分换行 (wrap)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.wrap{    flex-wrap: wrap;}</style><div class="container w wrap">    <div class="item"></div>    <div class="item"></div>    <div class="item"></div></div><br><h3 id="侧轴元素的排列方式"><a href="#侧轴元素的排列方式" class="headerlink" title="侧轴元素的排列方式"></a>侧轴元素的排列方式</h3><h4 id="单行情况的排列方式"><a href="#单行情况的排列方式" class="headerlink" title="单行情况的排列方式"></a>单行情况的排列方式</h4><p><code>align-items</code>属性可以设置单行情况下，侧轴方向的排列方式，设置一维元素靠侧轴方向的头尾或者居中，或是元素拉伸 (换行情况下无效)</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td><strong>flex-start</strong></td><td>默认值，从侧轴头部开始排列</td></tr><tr><td><strong>flex-end</strong></td><td>从侧轴尾部开始排列</td></tr><tr><td><strong>center</strong></td><td>居中显示</td></tr><tr><td><strong>stretch</strong></td><td>元素拉伸</td></tr><tr><td></td><td></td></tr></tbody></table><p>因为侧轴方向只有一行，所以只能设置头尾，居中或者元素拉伸 (拉伸会受到min-width/max-width/height的限制)</p><h4 id="多行情况的排列方式"><a href="#多行情况的排列方式" class="headerlink" title="多行情况的排列方式"></a>多行情况的排列方式</h4><p>多行 (即设置了换行wrap的情况下), 需要使用<code>align-content</code>来设置排列方式，设置的属性如下</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td><strong>flex-start</strong></td><td>默认值，从侧轴头部开始排列</td></tr><tr><td><strong>flex-end</strong></td><td>从侧轴尾部开始排列</td></tr><tr><td><strong>center</strong></td><td>居中显示</td></tr><tr><td><strong>stretch</strong></td><td>元素拉伸</td></tr><tr><td><strong>space-around</strong></td><td>侧轴平分剩余空间</td></tr><tr><td><strong>space-between</strong></td><td>侧轴平分剩余空间，侧轴头尾贴边</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="弹性项设置"><a href="#弹性项设置" class="headerlink" title="弹性项设置"></a>弹性项设置</h3><h4 id="子项份额设置"><a href="#子项份额设置" class="headerlink" title="子项份额设置"></a>子项份额设置</h4><p>给弹性项设置<code>flex</code>属性可以配置份额</p><p>比如我们设置一下item的flex属性为1，2，3，就可以使得盒子按照比例1：2：3分配剩余空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.item1{    background-color: orange;    height: 100px;    flex: 1;}.item2{    background-color: pink;    height: 100px;    flex: 2;}.item3{    background-color: skyblue;    height: 100px;    flex: 3;}</style><div class="container">    <div class="item1"></div>    <div class="item2"></div>    <div class="item3"></div></div><br><h4 id="子项自身在侧轴的排列方式"><a href="#子项自身在侧轴的排列方式" class="headerlink" title="子项自身在侧轴的排列方式"></a>子项自身在侧轴的排列方式</h4><p>在子项设置<code>align-self</code>属性，可以使得弹性项自己在<strong>侧轴</strong>上的排列方式，可以脱离弹性容器的侧轴排列的限制</p><p>举个例子，比如说我们希望单独一个元素排列方式不同，则可以在子项上设置自身的排列方式</p><p>我们给最后一个子项设置一个侧轴属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-spc</span>&#123;</span><br><span class="line">    <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下效果</p><style>.item-spc{    align-self: flex-end;}.h{    height: 200px;}</style><div class="container h">    <div class="item"></div>    <div class="item"></div>    <div class="item item-spc"></div></div><br><h4 id="弹性项排序"><a href="#弹性项排序" class="headerlink" title="弹性项排序"></a>弹性项排序</h4><p>用属性<code>order</code>可以控制弹性项的排序，order值越小，排列越靠前，<code>order</code>的默认值为0</p><div class="note orange no-icon flat"><p>随缘更新，如有错误欢迎指正</p></div>]]></content>
      
      
      <categories>
          
          <category> 🌺CSS花市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/01/28/UnionFindSet/"/>
      <url>2021/01/28/UnionFindSet/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集概念"><a href="#并查集概念" class="headerlink" title="并查集概念"></a>并查集概念</h2><p>当我们在做题的时候，会有一些关于集合的操作，比如将两个集合合并，查询一个元素是否属于某个集合，判断两个元素是否属于同个集合等，并查集就是一种用于处理这些情况的数据结构，<strong>并</strong> 指集合合并， <strong>查</strong> 指元素查询</p><p>既然有集合和元素关系判定的需求，那么首先我们得<strong>标识集合</strong>，比如说碗属于餐具，那么这里餐具就是这个集合的标识(名字)，在并查集中，集合有多种标识方法，最常见的一种是将<strong>代表元素</strong>作为集合表示，比如一个集合中包含了碗和盘子，那么我们可以随便选择一个，比如说碗，来标识集合</p><p>在具体实现中，并查集通过树形结构来实现，用根元素来标识集合，每个元素连向父节点，用于标识集合的根元素则<strong>连向自己</strong></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-2.png"></p><p>那么查找的时候只要沿着链寻找到根元素即可确定集合，查找的逻辑非常简单，沿着链往上查找，直到找到一个父节点连接指向自己的元素，，我们用c++简单地实现一下这个过程，这里用f数组表示父节点连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 searchfather</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x; <span class="comment">// 如果找到根元素则直接返回答案</span></span><br><span class="line">    <span class="keyword">return</span> sf(f[x]); <span class="comment">// 否则返回 [继续往上找得到的答案]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在介绍并查集是如何实现集合合并之前，我们现在看一下并查集需要做哪些<strong>预处理</strong></p><p>我们知道如果一个元素它的父节点连接如果指向自己，说明它用于标识这个集合 (当然用指向0，指向特殊值来标识都可以，上述例子是指向自己)，那么一开始每个元素都独立成为一个集合，就需要对每个元素自己构成的集合进行预处理————将父节点连接指向自己</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-3.png"></p><p>用代码表示就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    f[i] = i;</span><br></pre></td></tr></table></figure><p>而两个集合的合并，本质上就是，让代表两个集合的树结构成为一个树结构，并选出一个元素作为代表 (根元素)，那么我们发现一个最为简单的处理方法就是，将一棵树的根连向另一棵树的根，这样做就能满足所有的条件</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-4.png"></p><p>如上图所示的两个集合，我们只要将5号节点的父节点连接指向1节点或者将1节点的父节点连接指向5节点即可完成合并</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-5.png"></p><p>但是在正常情况下，都需要先找到集合的标识再对两个集合进行合并，需求一般长成这样</p><div class="note orange no-icon flat"><p>将3所在的集合和6所在的集合进行合并</p></div><p>这时候我们就需要先找到3所在的集合和6所在的集合，并对着两个集合的根元素做父节点连接操作，我们用C++代码简单地写一下这个过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并x所在的集合和y所在的集合</span></span><br><span class="line">fx = sf(x); <span class="comment">// 找到 x 所在集合</span></span><br><span class="line">fy = sf(y); <span class="comment">// 找到 y 所在集合</span></span><br><span class="line">f[fx] = fy; <span class="comment">// 将两者合并</span></span><br></pre></td></tr></table></figure><p>当然熟练之后你可以把查找和合并写的更简洁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找 三目表达式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x == f[x] ? x : sf(f[x]); &#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">f[sf(x)] = sf(y); </span><br></pre></td></tr></table></figure><h2 id="查找路径优化"><a href="#查找路径优化" class="headerlink" title="查找路径优化"></a>查找路径优化</h2><p>如果按照上述方法构建并查集并查找元素，会存在一个问题，如果不巧在合并的过程中形成了一条链，那么查找的复杂度会非常的高 (需要一路沿着父节点连接向上查找)，当然你可以说运气不好，但是一个优秀的算法必须要保证<strong>稳定的复杂度</strong>，在不同的测试数据情况下都表现良好</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-6.png"></p><p>这里介绍两种常用的查找路径优化方式</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>最常用的一种查找路径优化方式是路径压缩，其基本思想是</p><div class="note orange no-icon flat"><p>在查找集合根元素的同时对查找经过的路径进行压缩</p></div><p>比如说，如果查找下图4节点所在集合的根元素，在查找过程中将4节点和3节点的父元素连接全都<strong>改为指向根节点</strong>，这样在下次查找的时候就不需要经过非常长的查找路径了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-7.png"></p><p>具体的实现非常的简单，就是在每个经过的节点处，将其父节点连接指向元素更改为，<strong>查询根元素返回的答案</strong>，这里用C++代码进行演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : f[x] = sf(f[x]); </span><br><span class="line">    <span class="comment">// sf(f[x])返回的结果是集合的根元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩后的查询均摊复杂度为$O(\alpha(n))$，这里$\alpha$指代反阿克曼函数</p><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>另一种常用的方式是按秩合并，通俗一点地说就是通过有序的集合合并方式，<strong>限制并查集树的高度</strong></p><p>具体的实现思路就是，在合并的时候瞅瞅哪个集合树的高度是更高的，那么将其根元素作为合并后集合的根元素，因为高度小的集合并入高度大的集合，是不会增加高度的，只有两个高度相同的集合合并，才会使得高度增加</p><p>这里只要对于每个集合多维护一个参数h来表示高度(秩)即可，C++代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = sf(x);</span><br><span class="line">    <span class="keyword">int</span> fy = sf(y);</span><br><span class="line">    <span class="comment">// 保证fx的高度小于等于fy</span></span><br><span class="line">    <span class="keyword">if</span> (h[fx] &gt; h[fy]) swap(fx, fy);</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    f[fx] = fy;</span><br><span class="line">    <span class="comment">// 高度增加的情况</span></span><br><span class="line">    <span class="keyword">if</span> (h[fx] == h[fy]) h[fy]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集例题"><a href="#并查集例题" class="headerlink" title="并查集例题"></a>并查集例题</h2><div class="note green no-icon flat"><p><strong>亲戚</strong></p><p>你将得到一些亲戚关系的信息，如同Marry和Tom是亲戚，Tom和Ben是亲戚，等等。从这些信息中，你可以推出Marry和Ben是亲戚。请写一个程序，对于我们的关心的亲戚关系的提问，以最快的速度给出答案。</p></div><p>这个例题就是并查集的基础应用</p><ul><li><p>信息处理</p><p>  A和B是亲戚：f[sf(A)]=sf(B)</p></li><li><p>询问处理</p><p>  A和B是否是亲戚：判断sf(A)是否等于sf(B)</p></li><li><p>注意点</p><p>  集合初始化</p></li></ul><hr><div class="note green no-icon flat"><p><strong>畅通工程</strong></p><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p></div><p>这个题涉及到并查集的一个常见的应用，连通分量计数，换句话说，就是统计有几个集合，因为距离全图连通还需要添加的边数就是集合的数量减一</p><p>统计集合的数量只需要计算做完集合合并之后，父节点连接指向自己的点 (f[i] == i) 的数目即可</p><hr><div class="note green no-icon flat"><p><strong>团伙</strong></p><p>在某城市里住着 n 个人，任何两个认识的人不是朋友就是敌人，而且满足： </p><ol><li>我朋友的朋友是我的朋友； </li><li>我敌人的敌人是我的朋友； </li></ol><p>所有是朋友的人组成一个团伙。告诉你关于这 n 个人的 m 条信息，即某两个人是朋友， 或者某两个人是敌人，请你编写一个程序，计算出这个城市<strong>最多</strong>可能有多少个团伙？ </p></div><p>首先我们需要对题目的信息进行化简</p><p>朋友的朋友是朋友符合正常的集合合并逻辑，不需要特殊处理，敌人的敌人是朋友该如何处理是解决这个问题的关键</p><p>我们记x的敌人为enemy[x]，因为敌人的敌人是朋友，则A和B是敌人这个条件其实包含了两个信息：</p><ol><li>enemy[A]和B是朋友</li><li>enemy[B]和A是朋友</li></ol><p>所以这个题的处理逻辑就是，存储每个元素第一次出现的enemy，通过朋友的关系传递来标识集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理敌人关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EUnion</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enemy[a]) Union(b, enemy[a]);</span><br><span class="line">    <span class="keyword">else</span> enemy[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于敌人关系需要处理两条信息</span></span><br><span class="line">EUnion(A,B), EUnion(B,A)</span><br></pre></td></tr></table></figure><hr><div class="note green no-icon flat"><p><strong>巴士旅行</strong></p><p>有n个城市，被m条边表示m条无向道路，每条边有一个时间，表示坐巴士从一个城市到另一城市需要等待的时间。Jack最多等待巴士x分钟，也就是说需要等待超过x分钟的巴士他就不会去坐，他在城市里可以得到休息，使得他恢复等待巴士的耐心。求有多少对城市(a,b), 他可以通过坐巴士的方式从a城市到达b城市。(a,b)和(b,a)算作不同的对</p><p>有多组询问，每组给出一个x，表示Jack最多等待的时间，求出在不同x条件下的答案</p></div><p>考虑单组询问，对于给定x，将所有边权不超过x的边的两端点所在的集合合并，最后每个集合对答案的贡献为 </p><p>$size * (size - 1)$</p><p>考虑每次集合合并对答案造成的影响，假设将大小为 s1 的集合和大小为 s2 的集合进行合并，那么对答案的贡献为 </p><p>$(s1 + s2) * (s1 + s2 - 1) - s1 * (s1 - 1) - s2 * (s2 - 1)$ </p><p>即新产生的集合的贡献减去消失的集合贡献</p><p>我们可以记录每个询问原来位于询问列表中的位置，然后对询问根据x大小进行排序，对边按照权值大小进行排序，从小到大对边端点所在的两个集合进行合并处理，在处理完排序后询问列表对应的值之后将答案记录到对应的询问上</p><p>最后还原询问的顺序并输出即可</p><h2 id="种类关系处理"><a href="#种类关系处理" class="headerlink" title="种类关系处理"></a>种类关系处理</h2><p>为了说明什么是种类关系，我们先来看一个题</p><div class="note green no-icon flat"><p><strong>阵营</strong></p><p>在某场战争中有两个敌对的阵营，周围城镇的士兵不是来自阵营A就是来自阵营B，现在告诉你一些士兵之间的关系，即他们来自同一个阵营或者来自不同的阵营，之后询问一些士兵之间的关系：来自同一阵营，来自敌对阵营，或者不确定 </p></div><p>这里有两个阵营，所以种类只有两种，非A即B，区别于上面的团伙一题</p><p><strong>用并查集来处理</strong>种类关系通常有两种方法：加权和拆点 (处理种类关系的方法还有很多，暂且不讨论)</p><h3 id="拆点"><a href="#拆点" class="headerlink" title="拆点"></a>拆点</h3><p>拆点，顾名思义，就是将一个点拆成多个点</p><p>以阵营一题为例，我们用两个点来表示一个士兵，一个点表示<strong>该士兵属于A阵营</strong>，另一个点表示<strong>该士兵属于B阵营</strong></p><p>如果我们现在有两个士兵a和b，那么可以得到四个命题</p><div class="note no-icon flat"><ol><li>a士兵属于A阵营</li><li>a士兵属于B阵营</li><li>b士兵属于A阵营</li><li>b士兵属于B阵营</li></ol></div><p>如果得到信息 a士兵和b士兵属于同一阵营，那么1和3两个命题可以同时成立，2和4两个命题可以同时成立；如果得到的信息是 a士兵和b士兵属于不同阵营，那么1和4两个命题，2和3两个命题同时成立</p><p>我们将<strong>同时成立的命题归为一个集合</strong>，查询两个士兵关系的时候，对士兵对应的命题(两个点)的集合关系进行判断，就可以得到士兵之间的关系</p><p>在具体实现中，我们用点x表示x士兵属于A阵营，用点(x+n)表示x士兵属于B阵营</p><ul><li>若给出信息：x和y属于同一阵营，则 Union(x ,y), Union(x+n, y+n)</li><li>若给出信息：x和y属于不同阵营，则 Union(x, y+n), Union(x+n, y)</li><li>若查询x和y的关系：<ul><li>若sf(x)==sf(y)||sf(x+n)==sf(y+n), 则为同一阵营</li><li>若sf(x+n)==sf(y)||sf(x)==sf(y+n), 则为敌对阵营</li><li>否则，关系未知</li></ul></li></ul><h3 id="加权"><a href="#加权" class="headerlink" title="加权"></a>加权</h3><p>加权的意思就是给边赋予权值，来表示并查集树上，点和父节点之间的关系，因为是树状结构，所以边信息可以直接记录在子节点上，而不需要额外对边进行处理</p><p>还是以阵营一题为例</p><p>假设我们在做并查集处理的时候在边上多记录一个信息，表示两点是敌对还是同阵营，那么在不做路径压缩的情况下，我们可以得到类似下图的结构</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-8.png"></p><p>那么，通过计算路径上敌对边出现的次数，我们可以得到<strong>每个点和根元素之间的关系</strong>，如果两个点处在同一个集合中，我们又分别知道了这两个点和根元素的关系，那么这两个点的关系也可以轻易得到</p><p>那么压缩路径的情况下，无非是，更新路径上每个节点的父节点连接的同时，更新其向上连接的边属性(敌对/同阵营)，最终达到如下图所示的效果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-9.png"></p><p>我们用1表示敌对，0表示同阵营，那么点和集合根元素的关系即<strong>路径上经过的1数量对2取模得到的结果</strong>，也就是路径上的数字和对2取模</p><p>我们用r数组来表示点与父节点的关系，那么查找的代码可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> fx = sf(f[x]); <span class="comment">// 保留父节点连接f[x]</span></span><br><span class="line">    r[x] = (r[x] + r[f[x]]) % <span class="number">2</span>; <span class="comment">// 此时，r[f[x]]为父节点和根元素的关系</span></span><br><span class="line">    <span class="keyword">return</span> f[x] = fx; <span class="comment">// 更新父节点连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在两个集合合并的时候，我们需要先计算出两个节点和集合根节点之间的，然后用两个节点之间的关系去更新根节点之间的关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> fx, <span class="keyword">int</span> fy, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    f[fy] = fx;</span><br><span class="line">    r[fy] = (r[y] + r[x] + d) % <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="种类关系处理例题"><a href="#种类关系处理例题" class="headerlink" title="种类关系处理例题"></a>种类关系处理例题</h2><h3 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h3><div class="note green no-icon flat"><p><strong>食物链</strong></p><p>草原上有三种物种，分别为A,B,C，A吃B，B吃C，C吃A。给定若干条信息，信息分为两种</p><ol><li>1 x y 表示x和y是同类</li><li>2 x y 表示x吃y</li></ol><p>问给出的信息有几条是和前面相违背的</p></div><p>这题同样可以用上述种类关系处理的两种方法来做</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">🌼 拆点</button></li><li class="tab"><button type="button" data-href="#test-2">🌻 加权</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>将每个点拆点，比如x拆为，x-A，x-B，x-C 表示x属于A类，x属于B类，和x属于C类 (具体实现中用 x, x+n, x+2*n表示)</p><p>如果x和y属于同类，那么合并x-A和y-A，x-B和y-B，x-C和y-C</p><p>如果是x吃y的情况，那么合并x-A和y-B，x-B和y-C，x-C和y-A</p><p>对于条件矛盾判断:</p><p>如果给出信息是x和y属于同类，但是x和y+n或x和y+2n已经在同个集合中，那么该信息矛盾;</p><p>如果给出信息是x吃y，但是x和y或x和y+2n在同一个集合中，那么该信息矛盾</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>用边关系 0 表示x和y同类， 1 表示x吃y，2 表示x被y吃，则x和根结点的关系为其路径上经过的边权之和对3取余的结果，处理方式同阵营一题</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="带权并查集例题"><a href="#带权并查集例题" class="headerlink" title="带权并查集例题"></a>带权并查集例题</h2><p>在介绍种类关系处理的时候，我们已经介绍了加权方法，就是对每个节点附加信息，表示和父节点之间的关系，在压缩的时候同时进行加权信息的计算，除了种类关系表示之外，带权并查集还有更多的用途，这里用几个例题加以说明</p><div class="note green no-icon flat"><p><strong>龙珠</strong></p><p>有标号为1到n的n个龙珠，分别放在对应标号为1到n的n个城市里。下面有两种操作:</p><ol><li>T A B表示把A龙珠所在城市的所有龙珠都转移到B龙珠所在的城市中</li><li>Q A 表示查询A，需要知道A龙珠现在所在的城市，A所在的城市有几颗龙珠，A转移到这个城市移动了多少次，分别输出3个整数，表示上述信息。</li></ol></div><p>我们来看每次询问需要输出的三个信息</p><ol><li>A所在的城市</li><li>A所在的城市的龙珠数目</li><li>A龙珠到这个城市移动了几次</li></ol><p>第一条信息用朴素的并查集就可以维护，第二条信息在两个集合合并的时候将集合大小相加即可 (记录在根元素)</p><p>而第三条信息的维护，需要在集合合并的时候加权给根元素连接的那条边，并在压缩时需要向下传递</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/UnionFindSet-10.png"></p><p>我们可以发现每个龙珠从原来所在的城市移出仅会发生一次，所以每次移动，直接加权1即可，合并和路径压缩代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;  </span><br><span class="line">    <span class="keyword">int</span> fx = sf(f[x]); <span class="comment">// 保留父节点连接f[x]</span></span><br><span class="line">    move[x] += move[f[x]]; <span class="comment">// 计算移动次数和</span></span><br><span class="line">    <span class="keyword">return</span> f[x] = fx;  <span class="comment">// 更新父节点连接</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;  </span><br><span class="line">    fx = sf(x); </span><br><span class="line">    fy = sf(y);  </span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;  </span><br><span class="line">        f[fx] = fy;  </span><br><span class="line">        count[fy] += count[fx]; <span class="comment">// 龙珠数量统计</span></span><br><span class="line">        move[fx] = <span class="number">1</span>; <span class="comment">// 移动次数加权  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p><strong>试题判断</strong></p><p>有n次询问，给出a到b区间的总和 (试题的区间分数)</p><p>如果一个“子区间和”与前面的“子区间和”冲突，即为错误（而且这个“子区间和”将在接下来的判断中被忽略）</p><p>问这n次给出的总和中有几次是和前面已经给出的是矛盾的 </p></div><p>题目中给出了若干个区间和信息，我们先将其转化成点信息，区间和即前缀和的差，我们记$S_x$表示前x题的总分，那么a到b区间的和为c，就等价于式子 $S_b-S_a=c$</p><p>所以问题转化为给定若干个点之间的数值差，计算矛盾的次数，我们将数值差记录到边权上，压缩的同时计算数值差即可</p><p>核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径加权</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == f[x]) <span class="keyword">return</span> f[x];</span><br><span class="line">    <span class="keyword">int</span> fx = sf(f[x]);</span><br><span class="line">    sum[x] += sum[f[x]];</span><br><span class="line">    <span class="keyword">return</span> f[x] = fx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = sf(x), b = sf(y);</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[y] != sum[x] + data) ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[b] = sum[x] + data - sum[y];</span><br><span class="line">    f[b] = a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><div class="note orange no-icon flat"><p>未完待续</p></div>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC详解</title>
      <link href="2021/01/22/bfc/"/>
      <url>2021/01/22/bfc/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC概念与特性"><a href="#BFC概念与特性" class="headerlink" title="BFC概念与特性"></a>BFC概念与特性</h2><p>BFC的全称是Block formatting context，直接翻译是块级格式化上下文，我喜欢把它翻译成上下文无关区域，这可能更接近它的含义，具体地说</p><div class="note orange no-icon flat"><p>BFC指的是页面的一个独立的渲染区域，它有自己的布局规则，其内的元素和区域外的元素<strong>互不干扰</strong></p></div><p>除了内外元素相互不影响之外，BFC还存在一些独特的特性</p><p>首先，<strong>BFC不与浮动盒子重叠</strong>，并且<strong>BFC内部的浮动元素参与BFC的高度计算</strong>，从这两点特性可以看出，构建BFC是一个很好的清除浮动的手段，将包含浮动元素的父元素构建成为一个BFC可以有效地解决塌陷的问题</p><p>然后，BFC内部的块盒和行盒(行内所有元素构成行盒)会<strong>垂直</strong>沿着父元素的边框排列，<strong>相邻元素的margin会发生重叠</strong>，你可能会觉得这好像跟在body里写的排布规则是一样的，因为html根元素本身就是一个BFC</p><h2 id="BFC触发机制"><a href="#BFC触发机制" class="headerlink" title="BFC触发机制"></a>BFC触发机制</h2><p>满足以下任一条件即可形成BFC</p><div class="note no-icon orange flat"><ol><li>body 根元素 </li><li>浮动元素 (float: left/right，如果是inherit则需要继承属性非none)</li><li>绝对定位元素 (position: absolute/fixed)</li><li>特定布局方式 (display: inline-block/flex/table-cells)</li><li>溢出设置非visible (overflow: hidden/auto/scroll)</li></ol></div><h2 id="BFC用途"><a href="#BFC用途" class="headerlink" title="BFC用途"></a>BFC用途</h2><h3 id="浮动相关"><a href="#浮动相关" class="headerlink" title="浮动相关"></a>浮动相关</h3><h4 id="父元素塌陷问题"><a href="#父元素塌陷问题" class="headerlink" title="父元素塌陷问题"></a>父元素塌陷问题</h4><p>首先我们从特性中就可以得到一点，BFC可以很好地清除浮动，父级元素触发BFC，可以防止塌陷</p><p>塌陷的意思就是，当子元素浮动的时候，不能正常地将父元素撑开，比如下面这段代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.father</span>&#123;</span></span><br><span class="line">    background-color: pink;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现的效果如下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-2.png"></p><p>如果我们让父元素成为bfc</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以解决子元素浮动时父元素的塌陷问题</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-3.png"></p><h4 id="浮动元素覆盖问题"><a href="#浮动元素覆盖问题" class="headerlink" title="浮动元素覆盖问题"></a>浮动元素覆盖问题</h4><p>浮动元素是脱离文档流的，因此会和文档流元素出现重叠的情况</p><p>比如下列代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.b1</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.b2</span>&#123;</span></span><br><span class="line">    background-color: pink;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会产生如下效果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-4.png"></p><p>一个比较好的解决方案就是，将不希望被覆盖的元素触发BFC，使得其上下文无关 (把float盒子挤出去)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-5.png"></p><h3 id="边距设置"><a href="#边距设置" class="headerlink" title="边距设置"></a>边距设置</h3><h4 id="相邻元素的间距"><a href="#相邻元素的间距" class="headerlink" title="相邻元素的间距"></a>相邻元素的间距</h4><p>在文档流中，相邻元素间的margin是会重叠的，比方说，我们上下两个盒子各自设置了100px的外边距，实际上页面中两个盒子之间的距离并不会是200px而是100px</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-6.png"></p><p>如果希望两个盒子的外边距是互不影响的，那么我们需要做的事情就是将这两个盒子<strong>放入两个相邻的BFC</strong>中，这样就能设置各自的外边距，不会发生重叠</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.b1</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    margin: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.b2</span>&#123;</span></span><br><span class="line">    background-color: pink;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 100px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.bfc</span>&#123;</span></span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-7.png"></p></br><h4 id="父子元素margin重叠"><a href="#父子元素margin重叠" class="headerlink" title="父子元素margin重叠"></a>父子元素margin重叠</h4><p>在垂直方向上，父子元素的margin也是会重叠的，比如在子元素设置一个margin，则父元会共用这个margin</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.b0</span>&#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background-color: brown;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.b1</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.b2</span>&#123;</span></span><br><span class="line">    background-color: pink;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    margin: 25px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-8.png"></p><p>这简直就是浏览器解析设计中的bug，不过好在我们有方法解决这个问题</p><p>如果我们希望这个margin设置的是子元素和父元素的距离，则需要将父元素变为BFC</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bfc-9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🌺CSS花市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将iconfont引入自己的页面</title>
      <link href="2021/01/22/iconfont/"/>
      <url>2021/01/22/iconfont/</url>
      
        <content type="html"><![CDATA[<p>在仿写小米手机官网的时候，遇到了一个购物车小图标，会随着文字一起变色，记录一下如何实现这个</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-2.png" width="300px" /><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-3.png" width="300px" /><h2 id="素材下载"><a href="#素材下载" class="headerlink" title="素材下载"></a>素材下载</h2><p>首先登陆阿里巴巴矢量图标库iconfont</p><div class="site-card-group"><a class="site-card" href="https://www.iconfont.cn/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-4.png"/></div><div class="info"><span class="title">iconfont.cn</span><span class="desc">阿里巴巴矢量图标库</span></div></a></div><p>然后搜索图标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-5.png"></p><p>可以看到有600多个购物车的图标</p><p>我们选择一个，然后添加入库</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-6.png" width="200px" /><p>这时候可以看到右上角的购物车的标号变为了1</p><p>点开，选择添加至项目，新建项目并确定</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-7.png" width="200px" /><p>然后就可以在资源管理&gt;我的项目中找到这个项目</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-8.png"></p><p>在项目中选择Font class并下载到本地</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-9.png"></p><p>我们就得到了一个文件夹，里面有这些东西</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-10.png"></p><p>我们将这个文件将放入项目中，我这里是把这个文件夹改名为iconfont</p><h2 id="引入方法"><a href="#引入方法" class="headerlink" title="引入方法"></a>引入方法</h2><p>在html文件中引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./iconfont/iconfont.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后我们就可以在这个文件中使用这个图标</p><p>使用span或者i引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icongouwuchekong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icongouwuchekong&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个图标的大小和颜色控制方式和文字相同，所以和文字放在一起的时候，可以一同通过font的属性来调整</p><p>这样就能成功在页面上使用了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-11.png"></p><p>需要引入的两个class分别是iconfont和对应的图标名字，图标名在下载前在网页上是可以修改的</p><h3 id="在value值中使用"><a href="#在value值中使用" class="headerlink" title="在value值中使用"></a>在value值中使用</h3><p>如果想要在value值里面使用iconfont图表，则需要用unicode</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-12.png"></p><p>unicode在图标项目的界面可以查看</p><p>引入方式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span> <span class="attr">value</span>=<span class="string">&quot;<span class="symbol">&amp;#xe682;</span>&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意需要设置class为iconfont，然后在value值中填入对应的unicode即可</p><p>效果如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/iconfont-13.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🍰HTML点心铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML快捷键</title>
      <link href="2021/01/18/htmlquick/"/>
      <url>2021/01/18/htmlquick/</url>
      
        <content type="html"><![CDATA[<p>记录一些HTML的快捷键 </p><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>输入标签名字后按下<kbd>tab</kbd>键，可以自动补全</p><p>比如输入<code>h1</code>，然后按下<kbd>tab</kbd>，可以得到<code>&lt;h1&gt;&lt;/h1&gt;</code></p><h2 id="输入多个相同标签"><a href="#输入多个相同标签" class="headerlink" title="输入多个相同标签"></a>输入多个相同标签</h2><p>可以直接使用乘法，比如h1*6，就可以生成一排h1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="增量补全"><a href="#增量补全" class="headerlink" title="增量补全"></a>增量补全</h2><p>采用<code>$</code>符号，表示增量补全，比如<code>h$*6</code>可以得到</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成html基本架构"><a href="#生成html基本架构" class="headerlink" title="生成html基本架构"></a>生成html基本架构</h2><p>输入<code>!</code>然后按下<kbd>tab</kbd>键，可以在页面中生成一个html的基本架构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS和JS链接"><a href="#CSS和JS链接" class="headerlink" title="CSS和JS链接"></a>CSS和JS链接</h2><p>输入link:css，按下<kbd>tab</kbd>，可以生成css链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输入script:js，按下<kbd>tab</kbd>，可以生成js链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签信息生成"><a href="#标签信息生成" class="headerlink" title="标签信息生成"></a>标签信息生成</h2><p>采用#可以生成id，.生成类class，用[]可以生成属性，{}生成包裹的内容</p><p>举个🌰</p><p><code>#circle1.circle[color]</code></p><p>生成<code>&lt;div id=&quot;circle1&quot; class=&quot;circle&quot;&gt;&lt;/div&gt;</code></p><p><code>div[123]&#123;123&#125;</code></p><p>生成<code>&lt;div 123=&quot;&quot;&gt;123&lt;/div&gt;</code></p><h2 id="标签间关系"><a href="#标签间关系" class="headerlink" title="标签间关系"></a>标签间关系</h2><p><code>&gt;</code>表示嵌套标签，<code>+</code>表示同级标签，<code>^</code>表示上级标签，<code>(()</code>可以让<code>&gt;</code>嵌套多个同级块</p><p>举个🌰</p><p><code>div1&gt;p+p^div2&gt;p+p</code></p><p>就可以生成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div2</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>div1&gt;(div2&gt;p+p)(p+p)</code></p><p>可以生成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div1</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生成随机文本"><a href="#生成随机文本" class="headerlink" title="生成随机文本"></a>生成随机文本</h2><p>输入lorem会生成30个随机单词</p><p>输入lorem10会生成10个随机单词</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释：<kbd>ctrl</kbd>+<kbd>/</kbd></p>]]></content>
      
      
      <categories>
          
          <category> 🍰HTML点心铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster R-CNN填坑记录</title>
      <link href="2021/01/14/fasterRCNNgo/"/>
      <url>2021/01/14/fasterRCNNgo/</url>
      
        <content type="html"><![CDATA[<div class="tip error"><p>本文弃置，坑填失败了，准备换个框架</p></div><p>记录一下FasterRCNN使用的填坑记录，用的是github上的项目，项目地址如下</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/jwyang/faster-rcnn.pytorch"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=jwyang&repo=faster-rcnn.pytorch&theme=buefy&show_owner=true"/></a><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#tab-1">😭 torch 0.4.0版本</button></li><li class="tab active"><button type="button" data-href="#tab-2">😋 torch 1.0.0版本</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="tab-1"><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>换了个工作区，环境从零开始配，先安装一个python</p><p>因为wget太慢了，所以选择先下下来再传到服务器上安装</p><p><a class="btn-beautify button--animated outline blue larger" href="https://www.python.org/ftp/python/"   title="下载地址"><i class="far fa-hand-point-right fa-fw"></i><span>下载地址</span></a></p><p>我下的是python-3.3.3.tar.xz</p><p>解压: <code>tar xJf Python-3.6.6.tar.xz</code></p><p>然后进入到对应的文件夹里安装python</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Python-3.6.6/</span><br><span class="line">$ ./configure --with-ssl  </span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>安装完python之后装一下包管理工具pip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   <span class="comment"># 下载安装脚本</span></span><br><span class="line">$ python get-pip.py    <span class="comment"># 运行安装脚本</span></span><br></pre></td></tr></table></figure><p>然后安装pytorch 0.4.0版本，安装指令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install torch&#x3D;&#x3D;0.4.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;cu90&#x2F;stable</span><br></pre></td></tr></table></figure><p>下载速度巨慢无比，换了一下豆瓣源之后就快多了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -i http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F; torch&#x3D;&#x3D;1.0.0 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;cu90&#x2F;stable --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><p>也可以用其它源：</p><div class="note purple no-icon flat"><p>国内镜像源列表</p><p>豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p><p>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></div><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>然后我们按照git项目上的指示进行相应的操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lib</span><br><span class="line">$ sh make.sh</span><br></pre></td></tr></table></figure><p>然后尝试跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES&#x3D;$GPU_ID python trainval_net.py \</span><br><span class="line">                   --dataset pascal_voc --net vgg16 \</span><br><span class="line">                   --bs $BATCH_SIZE --nw $WORKER_NUMBER \</span><br><span class="line">                   --lr $LEARNING_RATE --lr_decay_step $DECAY_STEP \</span><br><span class="line">                   --cuda</span><br></pre></td></tr></table></figure><p>把各种需要的包都装上之后碰到了一个奇怪的Error</p><div class="tip error"><p>ModuleNotFoundError: No module named ‘model.utils.cython_bbox’</p></div><p>最后的解决方案是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lib</span><br><span class="line">$ python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>但是git项目里也没写这个，就离谱</p><p>又装了一堆包之后喜提新错误</p><div class="tip error"><p>ImportError: cannot import name ‘imread’</p></div><p>这里问题就比较神奇了，查阅资料得到出现这个问题的原因可能有两种</p><div class="note purple no-icon flat"><ol><li>两个第三方库的安装位置不一致，导致他们不能互相关联</li><li>scipy库的版本过高</li></ol></div><p>我对scipy库降版本之后解决了这个问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scipy==1.2.1</span><br></pre></td></tr></table></figure><p>又是一通<strong>缺啥装啥</strong>之后，遇到了一个不一样的错误</p><div class="tip error"><p>ImportError: torch.utils.ffi is deprecated. Please use cpp extensions instead.</p></div><p>没找到靠谱的解决方案，弃疗，换个1.0版本的代码从头再来</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="tab-2"><p>环境安装同0.4.0版本 </p><p>在Git项目页面从master分支切换到1.0.0分支下载项目</p><p>然后安装依赖并下载cocoapi</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install -r requirements.txt</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pdollar/coco.git</span><br><span class="line"><span class="built_in">cd</span> coco/PythonAPI</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>尝试运行一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=<span class="variable">$GPU_ID</span> python trainval_net.py \</span><br><span class="line">                   --dataset pascal_voc --net vgg16 \</span><br><span class="line">                   --bs <span class="variable">$BATCH_SIZE</span> --nw <span class="variable">$WORKER_NUMBER</span> \</span><br><span class="line">                   --lr <span class="variable">$LEARNING_RATE</span> --lr_decay_step <span class="variable">$DECAY_STEP</span> \</span><br><span class="line">                   --cuda</span><br></pre></td></tr></table></figure><p>报错虽然会迟到，但是从不会缺席</p><div class="tip error"><p>ImportError: cannot import name ‘_mask’</p></div><p>解决方案参考</p><div class="tag link"><a class="link-card" title="Github Issue" href="https://github.com/cocodataset/cocoapi/issues/59"><div class="left"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="/img/git.png"/></div><div class="right"><p class="text">Github Issue</p><p class="url">https://github.com/cocodataset/cocoapi/issues/59</p></div></a></div><p>大概意思就是原项目中<code>lib/pycocotools</code>已经不行了，得换最新的</p><p>那我们下一个最新的</p><p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/cocodataset/cocoapi"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=cocodataset&repo=cocoapi&theme=buefy&show_owner=true"/></a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> cocoapi/PythonAPI</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>然后把<code>lib/pycocotools</code>删掉，把PythonAPI里面生成的pycocotools装进去，就可以解决这个问题</p><div class="tip error"><p>ImportError: cannot import name ‘_C’</p></div><p>新的问题又出现了</p><p>是因为在lib中使用setup.py的时候用的是旧的pycocotools，所以得重新再build一遍</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build develop</span><br></pre></td></tr></table></figure><p>然后，错误是越来越奇怪了</p><div class="tip error"><p>ImportError: /home/dl/forever97/fasterRCNN/lib/model/_C.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZN2at19UndefinedTensorImpl10_singletonE</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OD </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器</title>
      <link href="2021/01/13/css2/"/>
      <url>2021/01/13/css2/</url>
      
        <content type="html"><![CDATA[<div class="note no-icon flat"><p>之前写网页css一般都是照着改，没有去管css选择器的规则，今天整理一下</p></div><h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h2><p>css中基础的选择器分为标签选择器，类选择器，id选择器和通配选择器</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>标签选择器就是对于html已有的标签附加属性</p><p>比如我们给这个页面的h5标签附加颜色属性为红色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h5</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>h5 {     color: red;}</style><h5 id="h5标签"><a href="#h5标签" class="headerlink" title="h5标签"></a>h5标签</h5><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器就是自己定义一个类class，对于属于这个类的元素全部赋予对应的属性，css写法就是在类名前加一个<code>.</code></p><p>比如说给这个页面定义一个绿色类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.green</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.green{    color: green;}.big{    font-size: 2em;}</style><p>然后把一个h5标签给上green这个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h5 class&#x3D;&quot;green&quot;&gt;h5标签&lt;&#x2F;h5&gt;</span><br></pre></td></tr></table></figure><h5 class="green">h5标签</h5><p>我们发现就能覆盖掉原来的颜色</p><p>同一个标签是可以拥有多个类名的，两个类名用空格隔开即可，比如我们再创建一个类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.big</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给h5标签添加两个类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h5 class=&quot;green big&quot;&gt;h5标签&lt;/h5&gt;</span><br></pre></td></tr></table></figure><h5 class="green big">h5标签</h5><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>因为html标签中的id属性是不可重复的，所以id就是唯一标识，id选择器只能对对应id的元素附加属性，css写法是id名前加一个<code>#</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#blue</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>#blue{    color: blue;}</style><p>然后我们给刚才这个h5标签一个blue id</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>h5标签<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 class="green" id="blue">h5标签</h5><p>成功覆盖掉了原来的类属性</p><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><p><del>可能从开始阅读这篇文章就发现了，字全是棕色的，因为设置了通用选择器，对于全局设置相同的属性</del></p><p>通用选择器可以设置全局属性，方法如下，因为全局字变色太影响阅读，故不演示效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>strong em{    color: brown;}strong>i{    color: red;}</style><p>通过以上的h5标签例子我们也可以发现这四种基础css选择器的优先级，id &gt; 类 &gt; 标签 &gt; 通用</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>属性选择器给拥有某种属性的元素给出样式</p><p>比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[hello]</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能给所有拥有hello属性的p赋予样式</p><h4 id="精准选择"><a href="#精准选择" class="headerlink" title="精准选择"></a>精准选择</h4><p>当然还能拥有某种属性的元素精准赋予样式，方式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[hello=<span class="string">&quot;1&quot;</span>]</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>p[hello="1"]{    color: red;}</style><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hello</span>=<span class="string">&quot;1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到效果如下</p><p hello="1">123</p><h4 id="匹配选择"><a href="#匹配选择" class="headerlink" title="匹配选择"></a>匹配选择</h4><p>属性选择器还可以做到匹配选择，方式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[hello*=<span class="string">&quot;234&quot;</span>]</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>p[hello*="234"]{    color: orange;    font-size: 2em;}</style><p>意思是给hello属性值中包含234作为子串的元素赋予样式，效果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hello</span>=<span class="string">&quot;1234&quot;</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p hello="1234">1234</p><p>还可以选择匹配开头和匹配结尾，只要把<code>*</code>分别替换为<code>^</code>和<code>$</code>即可</p><h4 id="组内匹配"><a href="#组内匹配" class="headerlink" title="组内匹配"></a>组内匹配</h4><p>如果一个属性有多个值，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">hello</span>=<span class="string">&quot;12 23&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么想要给包含了12的赋予样式，就不能精准匹配了，需要采用的写法是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[hello~=<span class="string">&quot;12&quot;</span>]</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><style>p[hello~="12"]{    color: lightgreen;}</style><p hello="12 23">12</p><h4 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h4><p>匹配属性值时还可以忽略大小写，具体实现方法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[hello$=<span class="string">&quot;.doc&quot;</span> i]</span></span><br></pre></td></tr></table></figure><p>则不管是以.doc，.DOC还是.dOc各种大小写结合的结尾都可以被匹配到</p><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>后代选择器用来选择元素的后代，比如<code>&lt;strong&gt;</code>里面的<code>&lt;em&gt;</code>标签</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span> <span class="selector-tag">em</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果是<code>strong</code>的后代<code>em</code>都是棕色的</p><p><code>&lt;em&gt;em&lt;/em&gt;</code>: <em>em</em></p><p><code>&lt;strong&gt;&lt;em&gt;em&lt;/em&gt;</code>: </strong><strong><em>em</em></strong></p><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>子元素选择器和后代选择器唯一的区别就是子元素选择器只允许直系子元素得到对应属性，后代选择器则可以选择所有的后代，写法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">strong</span>&gt;<span class="selector-tag">i</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;strong&gt;&lt;i&gt;i&lt;/i&gt;&lt;/strong&gt;</code>: <strong><i>i</i></strong></p><p><code>&lt;strong&gt;&lt;em&gt;&lt;i&gt;i&lt;/i&gt;&lt;/em&gt;&lt;/strong&gt;</code>: <strong><em><i>i</i></em></strong></p><h3 id="同级选择器"><a href="#同级选择器" class="headerlink" title="同级选择器"></a>同级选择器</h3><h4 id="相邻同级选择器"><a href="#相邻同级选择器" class="headerlink" title="相邻同级选择器"></a>相邻同级选择器</h4><p>用<code>+</code>来表示相邻同级实现选择</p><p>举个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>+<span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示<code>h1</code>相邻的后续同级元素<code>p</code>会获得样式</p><h4 id="后续同级选择器"><a href="#后续同级选择器" class="headerlink" title="后续同级选择器"></a>后续同级选择器</h4><p>用<code>~</code>来选择某个元素之后所有的同级元素</p><p>写法如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lable</span> ~ <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示选择<code>lable</code>之后所有的同级<code>p</code>标签</p><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>同时满足属于某个标签和类，写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">em</span><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>其实就是，大家一起定义一些属性，可以少写点代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>, <span class="selector-tag">em</span>, <span class="selector-tag">strong</span>, <span class="selector-id">#haha</span>, <span class="selector-class">.ha</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器可以看成是选择了一个事件 (个人理解)</p><p>比如<code>:hover</code>鼠标覆盖后属性，<code>:active</code>是选中属性</p><p>通常采用交集选择器来使用伪类选择器，比如<code>tab [type=radio]:checked</code>，<a href="/2021/01/07/css1/">前不久刚见过</a>，不过当时不知道是伪类选择器</p><hr><p>先记录到这，之后有新内容再来补充</p>]]></content>
      
      
      <categories>
          
          <category> 🌺CSS花市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv2：全面升级的YOLO</title>
      <link href="2021/01/08/YOLOv2/"/>
      <url>2021/01/08/YOLOv2/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>YOLOv2多方面地对YOLO进行了优化，将算法的速度和精度都提高到了一个新的高度</p></div><p>YOLOv2沿用了YOLO的结构，并做了大量的优化</p><div class="site-card-group"><a class="site-card" href="/2021/01/06/YOLOv1"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-1.png"/></div><div class="info"><span class="title">YOLO回顾</span></div></a></div><hr><h2 id="更精准-Better"><a href="#更精准-Better" class="headerlink" title="更精准 [Better]"></a>更精准 [Better]</h2><p>YOLO相比于Fast R-CNN来说存在大量的定位误差，且召回率较低，因此优化主要是为了解决这两个问题</p><h3 id="批标准化"><a href="#批标准化" class="headerlink" title="批标准化"></a>批标准化</h3><p>YOLOv2用BN层代替了dropout，置于每个卷积层之后，有助于解决bp中梯度弥散和梯度爆炸的情况，mAP提升2%以上</p><h3 id="高分辨率分类器"><a href="#高分辨率分类器" class="headerlink" title="高分辨率分类器"></a>高分辨率分类器</h3><p>先在ImageNet上以$448\times 448$分辨率进行10个epoch的微调，然后根据检测结果对网络微调，这本质上是一种迁移学习，这种方法提升了将近4%的mAP</p><h3 id="带锚框的卷积"><a href="#带锚框的卷积" class="headerlink" title="带锚框的卷积"></a>带锚框的卷积</h3><p>YOLOv2移除了YOLO中的FC层，采用锚框来预测bbox，同时，将网络的输入从$448\times 448$缩小到416，这样特征图有奇数个位置，只有一个中心单元 (因为大型物体往往在图像中心)，32倍下采样之后得到$13 \times 13$的特征图</p><p>同时，解耦类的预测和空间位置，区别于YOLO中为每个格子预测类别，YOLOv2为每个锚框预测类和对象</p><p>引入锚框后mAP从69.5下降到69.2，但是Recall从81%上升至88%</p><h3 id="聚类提取锚框尺寸"><a href="#聚类提取锚框尺寸" class="headerlink" title="聚类提取锚框尺寸"></a>聚类提取锚框尺寸</h3><p>若手工设计锚框的尺寸 (Faster R-CNN)，就需要通过网络学习来对其进行调整，如果给定的先验框更好，网络就更容易学习到好的检测方法</p><p>基于这个想法，YOLOv2采用k-means聚类的方法来替代手工设计锚框，锚框的中心即网格的中心，采用欧式距离的话，较大的box会比较小的box产生更多的误差，因此采用如下式子表示距离</p><p>$d(box,centroid)=1-IoU(box,centroid)$</p><p>对速度和召回率之间做了一个权衡之后，确定k=5</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-2.png"></p><h3 id="偏移公式优化"><a href="#偏移公式优化" class="headerlink" title="偏移公式优化"></a>偏移公式优化</h3><p>在Faster RCNN中，偏移修正公式如下所示</p><p>$x=t_x * w_a - x_a$</p><p>$y=t_y * h_a - y_a$</p><p>$x_a$和$y_a$是锚框的中心点坐标，$w$和$h$是锚框的宽和高，t则是需要学习的参数，由于$t_x$和$t_y$是没有被约束的，所以预测框的中心会乱飘，所以训练的早期非常不稳定</p><p>因此yolov2采用了下列预测公式</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-3.png"></p><p>$c$表示中心点所处区域左上角格子的中心点坐标，$p$代表锚框的信息，$\sigma$代表预测框中心点和左上角坐标的距离，通过$c$和$\sigma$得到预测框中心点坐标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-4.png"></p><h3 id="细粒度检测"><a href="#细粒度检测" class="headerlink" title="细粒度检测"></a>细粒度检测</h3><p>YOLOv2通过采用passthrough层来实现细粒度检测，这个东西和resnet中的shortcut类似，思想都是将高层的语义和低层的位置信息结合，无非是结合方式不同</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-5.png"></p><p>passthrough采取的方式是把低层特征图一拆四 (如上图)，然后和高层特征图直接叠加作为特征图</p><h2 id="更快-Faster"><a href="#更快-Faster" class="headerlink" title="更快 [Faster]"></a>更快 [Faster]</h2><p>YOLOv2不再使用VGGnet而是提出了Darknet-19 (19conv+5maxpooling)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-6.png"></p><p>Darknet-19的精度和VGG-16五五开，但是浮点运算量减少到约$\frac{1}{5}$</p><h2 id="更强-Stronger"><a href="#更强-Stronger" class="headerlink" title="更强 [Stronger]"></a>更强 [Stronger]</h2><p>作者还构建了WordTree，一通操作之后可以识别9000种物体(YOLO9000)，详见论文 (<psw>(扣树无关，我不看)</psw>)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv2-7.png"></p><hr><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1612.08242v1"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> 2017 </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS标签页实现</title>
      <link href="2021/01/07/css1/"/>
      <url>2021/01/07/css1/</url>
      
        <content type="html"><![CDATA[<div class="note purple no-icon flat"><p>前些天跟同学一起糊实验室的项目，要做个实验平台，想实现一个点击实验步骤然后块的内容就会变成对应步骤的功能，当时糊了一个页内链接，贼丑，然后同学用js控制了内容的显隐实现了这个功能，今天看到arxiv上有类似的块，查了点资料，学习一下实现方法</p></div><p>总的来说是要实现这样一个东西</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/css1-2.png"></p><p>点击上面的lable然后就可以切换下面的内容框内的文字</p><h2 id="单选按钮radio"><a href="#单选按钮radio" class="headerlink" title="单选按钮radio"></a>单选按钮radio</h2><p>首先需要用到的是input标签中的单选按钮radio</p><p>下面给出一个示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span>选项一</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span>选项二</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span>选项三</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><br><div class="tab1">    <input type="radio" name="tab-group-1">选项一    <input type="radio" name="tab-group-1">选项二    <input type="radio" name="tab-group-1">选项三</div><br><p>注意我们需要给每个input标签一个相同的name表示他们属于同一组radio，这样子才能起到单选的效果</p><h2 id="绑定lable与radio"><a href="#绑定lable与radio" class="headerlink" title="绑定lable与radio"></a>绑定lable与radio</h2><p>现在我们想要给每个选项外边套一个框，这个可以通过绑定lable和radio来实现</p><p>具体我们来看代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.tab</span> <span class="selector-tag">label</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line">    padding: 10px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-1&quot;</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-2&quot;</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;tab-3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-3&quot;</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现效果如下</p><br><style>.tab2 label {    background: #eee;    padding: 10px;    border: 1px solid #ccc;    position: relative;}</style><div class="tab2">    <input type="radio" name="tab-group-01" id="tab-01">    <label for="tab-01">选项一</label>    <input type="radio" name="tab-group-01" id="tab-02">    <label for="tab-02">选项二</label>    <input type="radio" name="tab-group-01"    id="tab-03">    <label for="tab-03">选项三</label></div><br><p>绑定用的是label标签的for属性，通过id和radio绑定，绑定的效果就是当你点击label的时候，起到点击input同样的效果</p><p>这里我们发现前面那个圆点显然是我们不需要的，所以我们在css中把它隐藏掉</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tab</span> <span class="selector-attr">[type=radio]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以得到这样的效果</p><br><style>.tab3 label {    background: #eee;    padding: 10px;    border: 1px solid #ccc;    position: relative;}.tab3 [type=radio] {    display: none;}</style><div class="tab3">    <input type="radio" name="tab-group-001" id="tab-001">    <label for="tab-001">选项一</label>    <input type="radio" name="tab-group-001" id="tab-002">    <label for="tab-002">选项二</label>    <input type="radio" name="tab-group-001"    id="tab-003">    <label for="tab-003">选项三</label></div><br><h2 id="radio的checked效果"><a href="#radio的checked效果" class="headerlink" title="radio的checked效果"></a>radio的checked效果</h2><p>现在我们看到这三个label没啥区别，我们希望我们选中label的时候能够有变化，比如边框底部的线消失，颜色变化 (先不考虑下面内容框的显示)</p><p>这里我们需要给选中状态check额外添加一个css属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tab</span> <span class="selector-attr">[type=radio]</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>~</code>符号表示的是同一个父元素下该元素后的所有元素</p><p>所以这里是tab的radio后所有的label，所以这里我们就不能将所有label放在一个tab里面了，要分多个tab来放，同时对tab设置一个<code>float: left</code></p><p>效果如下</p><br><style>.tab5 {    float: left;}.tab5 label {    background: #eee;    padding: 10px;    border: 1px solid #ccc;    position: relative;}.tab5 [type=radio] {    display: none;}.tab5 [type=radio]:checked ~label{    background: white;    border-bottom: 1px solid white;}</style><div class="tab5">    <input type="radio" name="tab4-group-1" id="tab4-1">    <label for="tab4-1">选项一</label></div><div class="tab5">    <input type="radio" name="tab4-group-1" id="tab4-2">    <label for="tab4-2">选项二</label></div><div class="tab5">    <input type="radio" name="tab4-group-1"    id="tab4-3">    <label for="tab4-3">选项三</label></div><br><br><h2 id="z-index的使用"><a href="#z-index的使用" class="headerlink" title="z-index的使用"></a>z-index的使用</h2><p>最后我们来加上内容框，首先设置一个内容框的css，用tabs把所有东西框起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tabs</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把内容框加到html代码中去</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-1&quot;</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容一</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-2&quot;</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容二</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-3&quot;</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容三</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><style>.tabs1 {    position: relative;    min-height: 200px;     clear: both;    margin: 25px 0;}.content1 {    position: absolute;    top: 30px;    left: 0;    background: white;    right: 0;    bottom: 0;    padding: 20px;    border: 1px solid #ccc;}</style><body><div class="tabs1">    <div class="tab5">        <input type="radio" id="tab5-1" name="tab5-group-1">        <label for="tab5-1">选项一</label>        <div class="content1">            内容一        </div>    </div>    <div class="tab5">        <input type="radio" id="tab5-2" name="tab5-group-1">        <label for="tab5-2">选项二</label>        <div class="content1">            内容二        </div>    </div>    <div class="tab5">        <input type="radio" id="tab5-3" name="tab5-group-1">        <label for="tab5-3">选项三</label>        <div class="content1">            内容三        </div>    </div></div></body><br><p>我们发现最后一个内容框会把前两个内容框盖掉，并且之前的下边框横线消失也会被内容框盖住</p><p>这里需要用到css中一个属性叫z-index，这个属性可以规定当元素重叠时哪个元素盖在上面 (值大的盖在上面)，有了这个东西，我们将checked，也就是选中的元素放在最上面，不就实现了切换的功能么</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[type=radio]</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">label</span> &#123;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[type=radio]</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">label</span> ~ <span class="selector-class">.content</span> &#123;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在input属性中加入checked用于标记默认显示，这个标签页功能就实现了</p><br><style>    .tabs1 {        position: relative;        min-height: 200px;         clear: both;        margin: 25px 0;    }    .tab6 {        float: left;    }    .tab6 label {        background: #eee;        padding: 10px;        border: 1px solid #ccc;        position: relative;    }    .tab6 [type=radio] {        display: none;    }    .content1 {        position: absolute;        top: 30px;        left: 0;        background: white;        right: 0;        bottom: 0;        padding: 20px;        border: 1px solid #ccc;    }    .tab6 [type=radio]:checked ~ label {        background: white;        border-bottom: 1px solid white;        z-index: 2;    }    .tab6 [type=radio]:checked ~ label ~ .content1 {        z-index: 1;    }</style><body><div class="tabs1">    <div class="tab6">        <input type="radio" id="tab-1" name="tab-group-1" checked>        <label for="tab-1">选项一</label>        <div class="content1">            内容一        </div>    </div>    <div class="tab6">        <input type="radio" id="tab-2" name="tab-group-1">        <label for="tab-2">选项二</label>        <div class="content1">            内容二        </div>    </div>    <div class="tab6">        <input type="radio" id="tab-3" name="tab-group-1">        <label for="tab-3">选项三</label>        <div class="content1">            内容三        </div>    </div></div><br><h2 id="代码总览"><a href="#代码总览" class="headerlink" title="代码总览"></a>代码总览</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tabs</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span> <span class="selector-attr">[type=radio]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span> <span class="selector-attr">[type=radio]</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid white;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tab</span> <span class="selector-attr">[type=radio]</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">label</span> ~ <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-1&quot;</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容一</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-2&quot;</span>&gt;</span>选项二<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容二</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab-3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tab-group-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tab-3&quot;</span>&gt;</span>选项三<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            内容三</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="tip success"><p>标签页功能成功实现</p></div>]]></content>
      
      
      <categories>
          
          <category> 🌺CSS花市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO：实时目标检测</title>
      <link href="2021/01/06/YOLOv1/"/>
      <url>2021/01/06/YOLOv1/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>基本YOLO模型能够以每秒45帧实时处理图像，较小版本fastyolo每秒处理155帧，同时仍能达到其它实时探测器2倍的mAP</p></div><p>YOLO的意思就是You only look at once，从名字上听起来就非常快，在RCNN系列的网络中采用的是two-stage方法，即先生成候选框，然后对候选框进行分类，而以YOLO为代表的one-stage方法则是<strong>直接回归</strong>到类别概率和物体坐标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-2.png"></p><h2 id="Yolo核心思想"><a href="#Yolo核心思想" class="headerlink" title="Yolo核心思想"></a>Yolo核心思想</h2><p>Yolo的思想非常简单，就是将输入的图像划分成$S\times S$的格子，如果检测物体的中心在某个格子内，那个这个格子就负责检测这个物体</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-1.png"></p><p>每个格子会预测B个bbox以及其对应的置信度(confidence scores)，置信度表示bbox包含一个物体的确定程度和bbox的准确度，所以其计算公式为</p><p>$Pr(Obj) \cdot IoU(pred,GT)$</p><p>公式的含义是，若格子中有物体，则置信度为$IoU(pred,GT)$，否则为0</p><p>每个bbox由5个预测组成：x、y、w、h和置信度。(x,y) 坐标表示长方体相对于网格单元边界的中心。w和h对图像的宽度和高度进行了预测。置信度预测表示预测框和任何GT之间的IoU</p><p>此外，每个格子预测C个分类，所以输出量为$S\times S \times (5*B+C)$</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>网络类似GoogleNet，包含24层卷积层和2层全连接层，用$3 \times 3$卷积层接$1\times 1$还原层(reduction layers)替代了GoogleNet的初始模块，这种方式降低了计算量，同时提升了模型的非线性能力</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-3.png"></p><p>输入图像的尺寸为$448\times 448$，输出为$7\times 7 \times 30$的tensor $(S=7，B=2，C=20)$</p><div class="tip warning"><p>这里我们可以发现，对于一个格子的两个bbox，其实是共用一份类别预测的，也就是说，YOLO会对于一个格子预测两个框，然后选择IoU更高的一个来使用这个类别预测，整张图<strong>最多</strong>只能检测出$S\times S$个物体</p></div><h2 id="Loss函数"><a href="#Loss函数" class="headerlink" title="Loss函数"></a>Loss函数</h2><p>YOLO使用均方和误差作为loss函数来优化模型参数，Loss函数分为三个部分，坐标误差，置信度误差和类别误差，具体见下图 (图源自CSDN，链接见文末)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-4.png"></p><p>坐标误差项计算的是正样本中心坐标的损失，$\lambda_{coord}$设置为5，提高位置损失的权重，而w和h做了开方处理，这是因为，小的bbox的偏移比大的bbox的偏移更不能被接受，而开方之后，较小的bbox的偏差对loss会有更大的影响 (横轴值较小，偏移时，反映到纵轴上较大)</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/YOLOv1-5.png" width="30%" height="30%"><p>置信度误差项中$\lambda_{noobj}$设置为0.5，调低负样本置信度损失的权重</p><p>类别误差项计算正样本的类别损失</p><h2 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h2><p>查看下图对比可以知道YOLO的背景图像的误检率是低于Fast R-CNN (这是因为YOLO相比RCNN系列获得更多的全局信息)，但是在定位上比Fast R-CNN略逊一筹</p><psw>重新画饼图主要是我想玩一下mermaid画图</psw><hr><div class="mermaid">pie    title Fast R-CNN    &quot;Correct 71.6%&quot; : 71.6    &quot;Loc 8.6%&quot; : 8.6    &quot;Sim 4.3%&quot; : 4.3    &quot;Background 13.6%&quot; : 13.6    &quot;Other 1.9%&quot; : 1.9</div><div class="mermaid">pie    title YOLO    &quot;Correct 65.5%&quot; : 65.5    &quot;Loc 19.0%&quot; : 19.0    &quot;Sim 6.75%&quot; : 6.75    &quot;Background 4.75%&quot; : 4.75    &quot;Other 4.0%&quot; : 4.0</div><div class="note purple no-icon flat"><p>Correct: correct class and IOU &gt; .5<br>Localization: correct class, .1 &lt; IOU &lt; .5<br>Similar: class is similar, IOU &gt; .1<br>Other: class is wrong, IOU &gt; .1<br>Background: IOU &lt; .1 for any object</p></div><hr><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1506.02640"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a><a class="site-card" href="https://blog.csdn.net/app_12062011/article/details/77554288"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/csdn.png"/></div><div class="info"><span class="title">YOLO解读</span></div></a><a class="site-card" href="https://zhuanlan.zhihu.com/p/25236464"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhihu.png"/></div><div class="info"><span class="title">YOLO解读</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> 2016 </tag>
            
            <tag> one-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cascade R-CNN：级联RCNN以提升检测质量</title>
      <link href="2021/01/06/cascadeRCNN/"/>
      <url>2021/01/06/cascadeRCNN/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>Cascade RCNN 采用级联的方式，几乎对任意的RCNN都起到提升2到4点AP的作用</p></div><p>Faster R-CNN系列改进回顾</p><div class="site-card-group"><a class="site-card" href="/2020/12/22/RCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-1.png"/></div><div class="info"><span class="title">R-CNN回顾</span></div></a><a class="site-card" href="/2020/12/23/fastRCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-1.png"/></div><div class="info"><span class="title">Fast R-CNN回顾</span></div></a><a class="site-card" href="/2020/12/25/fasterRCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-1.png"/></div><div class="info"><span class="title">Faster R-CNN回顾</span></div></a></div><hr><h2 id="RCNN系列存在的问题"><a href="#RCNN系列存在的问题" class="headerlink" title="RCNN系列存在的问题"></a>RCNN系列存在的问题</h2><p>在RCNN系列中IoU的阈值决定了一个RoI属于正样本或是负样本，如果我们抬高阈值，则得到的RoI肯定是更接近真实物体，那么训练得到的检测器肯定会更为准确 (更好的proposal得到更好的bbox)</p><p>但同时会导致两个问题:</p><div class="note purple no-icon flat"><ol><li>过拟合，更高的IoU阈值会导致选出更少的正样本 (如下图所示)，正负样本的严重不均衡导致训练过拟合 <img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cascadeRCNN-2.png" width="50%" height="50%"></li><li>严重的<strong>mismatch</strong>问题</li></ol></div><div class="tip bolt"><p><strong>Mismatch问题</strong></p><p>训练阶段bbox回归学习的正样本是和GT的IoU大于阈值的Proposals，而测试阶段由于没有GT，用于bbox回归坐标的正样本是所有的Proposals，可能存在IoU小于阈值的，会导致性能下降，随着IoU阈值的提高，问题会变得更加严重</p></div><h2 id="实验与发现"><a href="#实验与发现" class="headerlink" title="实验与发现"></a>实验与发现</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cascadeRCNN-3.png"></p><p>作者对不同的IoU阈值设置做了三组实验，c图展示了proposals的分布，横纵轴为经过bbox回归前后的候选框IoU分布，d图展示了测试阶段将bbox判断为正样本的IoU阈值 (注意区分IoU的含义)</p><p>可以发现，候选框IoU和IoU阈值接近时，训练效果更好，而越远，mismatch的效果会更严重</p><p>所以作者得出一个结论</p><div class="note orange no-icon flat"><p><strong>单一IoU阈值无法对所有IoU的proposals进行优化</strong></p></div><h2 id="级联R-CNN"><a href="#级联R-CNN" class="headerlink" title="级联R-CNN"></a>级联R-CNN</h2><div class="note info no-icon flat"><p>既然单一IoU阈值没法适配所有的情况，那就多整几个</p><p>—— Cascade R-CNN</p></div><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhengyige.png" width="30%" height="30%"><p>级联RCNN的结构如图所示，I表示图片，B表示bbox回归，C表示分类，H表示RCNN网络部分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cascadeRCNN-1.png"></p><p>图中表示的结构很清晰，将前一个回归网络输出的bbox作为下一个检测器的输入继续进行回归，整三遍再输出，越靠后的检测器设置的IoU阈值越高</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhengsange.png" width="30%" height="30%"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>级联主要是为了解决mismatch的问题，通过逐个RCNN块不断地提高bbox的IoU值，使得和更高的阈值能够相匹配，而因为正负样本均衡也不会出现过拟合的问题，多个RCNN回归级联适配了更多阈值的proposals</p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhengbage.png" width="30%" height="30%"><hr><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1712.00726"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> two-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mask R-CNN：引入Mask分支以实现实例分割</title>
      <link href="2020/12/31/maskRCNN/"/>
      <url>2020/12/31/maskRCNN/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>Mask RCNN 是基于Faster RCNN提出的，在高效完成目标检测的同时实现了高质量的实例分割</p></div><p>Faster R-CNN系列改进回顾</p><div class="site-card-group"><a class="site-card" href="/2020/12/22/RCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-1.png"/></div><div class="info"><span class="title">R-CNN回顾</span></div></a><a class="site-card" href="/2020/12/23/fastRCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-1.png"/></div><div class="info"><span class="title">Fast R-CNN回顾</span></div></a><a class="site-card" href="/2020/12/25/fasterRCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-1.png"/></div><div class="info"><span class="title">Faster R-CNN回顾</span></div></a></div><hr><p>Mask R-CNN相对于Faster R-CNN的改进主要有三点</p><div class="note no-icon flat"><ol><li>引入FPN结构进行特征提取</li><li>采用RoI Align代替RoI pooling</li><li>在分类和回归的分支基础上，加入Mask分支</li></ol></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/maskRCNN-2.png"></p><h2 id="特征金字塔FPN"><a href="#特征金字塔FPN" class="headerlink" title="特征金字塔FPN"></a>特征金字塔FPN</h2><p>使用单一尺寸的特征(Faster R-CNN)的做法，在经过CNN逐层的下采样，到达最后特征层的时候图片中小物体的有效信息较少，检测性能急剧下降 (图b)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/maskRCNN-3.png"></p><p>而图像金字塔 (图a) 将输入图片做成多个尺寸，来生成不同尺度的特征来解决多尺度的问题，这种做法计算量大，非常耗时</p><p>特征层分层预测 (图c) 语义信息差距太大，高分辨率的低层特征不具备足够的检测能力</p><p>基于以上几种做法，提出了特征金字塔FPN (图d)，从高层携带信息传给低层，再分层预测</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/maskRCNN-4.png"></p><p>首先自底向上提取语义信息，然后依次进行上采样，各层进行$1\times 1$卷积降低通道数 (使通道数变为256)，将浅层定位细节与上采样的高层语义结合 (逐元素相加)，最后用$3\times 3$卷积做融合 (消除上采样的重叠效应)</p><div class="note purple no-icon flat"><p>关于FPN，更多信息可以参考原文</p><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1612.03144"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="/img/arxiv.png"/></div><div class="info"><span class="title">FPN论文原文</span></div></a></div></div><h2 id="RoI-Align"><a href="#RoI-Align" class="headerlink" title="RoI Align"></a>RoI Align</h2><p>Mask R-CNN对Faster R-CNN第二个改进是用RoI Align层替代了RoI Pooling层，RoI Pooling层存在两次取整操作，导致RoI特征与回归得到的位置存在一定的偏差，这个问题被称为不匹配问题(Missalignment)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/maskRCNN-6.png"></p><p>RoI Align通过双线性插值来解决这个问题 (即坐标和大小都保留浮点数)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/maskRCNN-5.png"></p><p>比如将RoI切分为$2\times 2$的网格，每个网格中采样$4$个点，则将每个单元格子均分成四个小方格后取每个方格的中心点作为采样点即可，对每个单元格内的采样点进行最大池化，就得到了最终RoI Align的结果</p><div class="tip warning"><p>Mask分支属于图像分割领域的知识，这里不详细展开了解</p></div><hr><div class="site-card-group"><a class="site-card" href="https://arxiv.org/abs/1703.06870"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> two-stage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster R-CNN：通过RPN实现实时目标检测</title>
      <link href="2020/12/25/fasterRCNN/"/>
      <url>2020/12/25/fasterRCNN/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>Faster RCNN 用 RPN 优化了候选框初选的过程，提高了RCNN系列网络的综合性能</p></div><p>首先回顾一下R-CNN和Fast R-CNN</p><div class="site-card-group"><a class="site-card" href="/2020/12/22/RCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-1.png"/></div><div class="info"><span class="title">R-CNN回顾</span></div></a><a class="site-card" href="/2020/12/23/fastRCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-1.png"/></div><div class="info"><span class="title">Fast R-CNN回顾</span></div></a></div><hr><p>可以看到所谓R-CNN的缺陷，主要体现在RoI上 </p><div class="note purple no-icon flat"><ol><li>RoI特征提取造成较大时间消耗 (每个RoI用CNN提取特征)和内存消耗 (RoI提取需要先存取)</li><li>RoI获取过程时间消耗太大 (罪魁祸首Selective Search)</li></ol></div><p>Fast R-CNN解决了RoI的第一个问题 (同时也搞定了多阶段训练的问题)，而Faster R-CNN主要是解决RoI的第二个问题，用RPN来替代耗时巨大的Selective Search</p><p>Faster R-CNN分为两个模块，第一个模块是用于产生区域框的深度全卷积网络，第二个模块就是Fast R-CNN目标检测器</p><h2 id="RPN网络"><a href="#RPN网络" class="headerlink" title="RPN网络"></a>RPN网络</h2><p>如图所示，RPN(Region Proposal Network)的作用就是以feature map作为输入，得到Region Proposal (候选区域)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-1.png"></p><div class="tip bolt"><p>特征图中的点与原图中的位置的对应关系只与CNN中经过的池化层数量有关，因为在Faster R-CNN中，所有的卷积层均为卷积核为3，步长为1，填充值为1，所有池化层均为窗口大小为2，步长为2，也就是说根据过卷积层长宽变化计算公式 $H = (H – size + 2 * padding) / stride + 1$，过卷积层后原图不会发生大小变化，而经过池化层长宽缩小为原来的一半，如果是四个池化层，则下采样率就是16</p></div><p>然后我们来看看在RPN的内部在做什么</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-2.png"></p><p>根据原文的图中可以看到，先是用特征图中每个生成k个anchors (文中k=9)，然后用anchors和特征去得到4k个偏移量 (reg layer) 和2k个分数 (cls layer)</p><h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><p>所以问题就来了，什么是Anchors，Anchors有什么用</p><p>Anchors的意思是锚，我们知道锚是一种停船所用的工具，给船限定了移动的范围，使得船停的更稳</p><p>那么这里的Anchors呢就是对于特征图上的点为中心生成k个<strong>固定比例</strong>的框，将这些框锚定到这个点上</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-3.png"></p><p>首先对特征图上的 (0,0) 点，也就是原图中的区域 (0，0，15，15) 生成如下9个Anchors</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[ -84.  -40.   99.   55.]</span><br><span class="line"> [-176.  -88.  191.  103.]</span><br><span class="line"> [-360. -184.  375.  199.]</span><br><span class="line"> [ -56.  -56.   71.   71.]</span><br><span class="line"> [-120. -120.  135.  135.]</span><br><span class="line"> [-248. -248.  263.  263.]</span><br><span class="line"> [ -36.  -80.   51.   95.]</span><br><span class="line"> [ -80. -168.   95.  183.]</span><br><span class="line"> [-168. -344.  183.  359.]]</span><br></pre></td></tr></table></figure><p>这里的锚框大小是根据reshape后的图像大小人为设定的，在处理中为了方便处理，会先将图像reshape为 $800 \times 600$ 大小，在处理完之后再reshape回去</p><p>得到第一组锚框之后，我们只要在特征图上平移锚点，就能得到原图对应区域的9个锚框</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-4.png"></p><p>特征图上每个点 (256-d|256张特征图) 负责对原图对应区域的9个锚框进行学习训练</p><p>这里和Fast R-CNN中最后一步类似，训练两个分支，cls layer (输出量2k) 得到框内是前景 (物体|正样本) 的概率和是背景 (负样本) 的概率，reg layer负责计算偏移量 (输出量4k | x,y,w,h)</p><h2 id="Faster-R-CNN总览"><a href="#Faster-R-CNN总览" class="headerlink" title="Faster R-CNN总览"></a>Faster R-CNN总览</h2><p>总结一下Faster R-CNN (图源自知乎，链接见文末)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fasterRCNN-5.png"></p><p>RPN部分先进行一次$3\times 3$的卷积结合周围特征点的空间信息，然后进入两个分支</p><div class="note no-icon flat"><ol><li>通过softmax分类得到正负样本的概率</li><li>回归计算bbox偏移量</li></ol></div><p>得到正样本对应的框并修正后就传入Fast R-CNN的部分进行后续的内容</p><p>所以总的来说，Faster相比于Fast，最为关键的一步，就是用RPN替换了Selective Search，具体做法是在图上布满手工设计的框，对框打分和修正，所以，本质上RPN就是一个bottom-up attention</p><hr><p>更多的内容参考我觉得比较好的解读和原文</p><div class="site-card-group"><a class="site-card" href="https://zhuanlan.zhihu.com/p/31426458"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhihu.png"/></div><div class="info"><span class="title">Faster R-CNN全流程解读</span></div></a><a class="site-card" href="https://zhuanlan.zhihu.com/p/86403390"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/zhihu.png"/></div><div class="info"><span class="title">Anchors解读</span></div></a><a class="site-card" href="https://arxiv.org/abs/1506.01497"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/arxiv.png"/></div><div class="info"><span class="title">论文原文</span></div></a></div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIPS </tag>
            
            <tag> OD </tag>
            
            <tag> two-stage </tag>
            
            <tag> 2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fast R-CNN：引入RoI池化以共享卷积计算</title>
      <link href="2020/12/23/fastRCNN/"/>
      <url>2020/12/23/fastRCNN/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>Fast RCNN 在训练速度上达到 RCNN 的9倍，测试速度达到其213倍，同时在PASCAL VOC 2012测试集上mAP达到66%</p></div><h2 id="RCNN和SPPnet"><a href="#RCNN和SPPnet" class="headerlink" title="RCNN和SPPnet"></a>RCNN和SPPnet</h2><p>首先回顾一下RCNN中存在的一些问题</p><div class="note purple no-icon flat"><ol><li>训练是多阶段的 (CNN + SVM + bbox regressor)</li><li>训练耗时占空间 (每个候选框的特征需提取并保存)</li><li>测试速度慢 (47s/img)</li></ol></div><div class="site-card-group"><a class="site-card" href="/2020/12/22/RCNN/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-1.png"/></div><div class="info"><span class="title">R-CNN回顾</span></div></a></div><hr><p>SPPnet是RCNN的改良版本，在RCNN中，需要先提取候选框中的特征，然后将每个候选框的特征单独输入CNN中做卷积操作，而SPPnet的核心思想就是从feature map中提取ROI(候选框)特征</p><p>这将面临两个问题：</p><div class="note no-icon flat"><ol><li>原始图像的候选框如何映射到特征图 (卷积层的输出)</li><li>候选框对应的特征如何满足全连接层的输入要求 (特征无法像图片一样拉伸或者填充)</li></ol></div><p>为了解决全连接层输入大小固定的问题，SPPnet提出了空间金字塔池化 (SPP，spatial pyramid pooling)，不管输入的特征图大小，均用三种不同尺度的滤波器做池化，最终得到$4\times 4$，$2\times 2$，$1\times 1$大小的256通道的特征图，级联得到固定大小的输出</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-2.png"></p><p>而映射问题，本质上就是去找到特征图的区域，使得其感受野近似原来的候选框，这里采用的是用步长之积对原坐标进行缩放的方式来定位</p><p>计算公式为：</p><p>左上角坐标：$\lfloor x/S \rfloor+1$，$\lfloor y/S \rfloor+1$</p><p>右下角坐标：$\lceil x/S \rceil-1$，$\lceil y/S \rceil-1$</p><p>其中$S$为池化和卷积的步长之积</p><p>SPPnet在测试阶段比RCNN快了$10 \sim 100$倍，在训练阶段快了3倍，但是SPPnet依然也存在一些问题</p><div class="note purple no-icon flat"><ol><li>训练是多阶段的这一点没有改善 </li><li>很难通过fine-tuning对SPP-layer之前的网络进行参数微调，当网络深度加深时很难保证精度</li></ol></div><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><p>Fast R-CNN的基本架构如下，图描述的非常清楚</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-1.png"></p><p>主要特点有：</p><div class="note no-icon flat"><ol><li>沿用SPPnet将一整张图作为CNN的输入来提取特征的方法</li><li>用RoI池化替代SPP-layer</li><li>将分类 (softmax产生N+1类) 和回归 (对N个目标类的4个位置坐标输出) 放在一起训练</li></ol></div><h3 id="RoI池化层"><a href="#RoI池化层" class="headerlink" title="RoI池化层"></a>RoI池化层</h3><p>RoI池化层的目的是将所有输出固定为$H \times W$</p><p>文章中将所有RoI用四元组$(r,c,h,w)$定义，即左上角坐标和长宽，RoI池化层的工作原理是将$h \times w$的RoI窗口划分为$H \times W$小块，每块大小为$h/H \times w/W$，最大池化每个小块中的值，输出对应的网格单元，这样就能得到固定大小的输出</p><p>SPPnet很难更新空间金字塔池化层前的卷积层是因为反向传播非常低效，其低效性源于每个RoI巨大的感受野 (通常是全图)</p><p>为了解决这个问题，作者将采样方式从以RoI为中心的采样转化为以图片为中心的采样，之前的R-CNN和SPPnet都是采用RoI为中心的采样，每个SGD的mini-batch中包含不同图像的样本，不能共享卷积计算，图片为中心的采样是分层采样，先对图像采样(N)，然后在采样图像对候选区域采样(R/N，R为批次输入)，N调小之后，在一个batch中可以有更多的图在正反向传播时共享特征，提高效率</p><h3 id="多任务损失"><a href="#多任务损失" class="headerlink" title="多任务损失"></a>多任务损失</h3><p>Fast R-CNN中有两个同级的输出层，分类和回归，分类的目的是计算概率$p=(p_0,\dots,p_K)$，回归则得到物体类的平移和缩放$t^k=(t^k_x,t^k_y,t^k_w,t^k_h)$，两个输出相对应的GT为物体标签类别$u$和回归目标$v$</p><p>总的损失函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-3.png"></p><p>$L_{cls}(p,u)=-log\ p_u$是类别u的负对数损失，最小化正确类别的负对数损失，本质上就是在做最大似然估计</p><p>$\lambda$用来调节多任务loss之间的平衡，$[u\ge1]$则限定物体首先存在然后计算第二项loss (背景则不计算第二项)</p><p>Loss的第二部分则是对每个坐标或偏移量计算$Smooth_{L1}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-4.png"></p><p>计算公式如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fastRCNN-5.png"></p><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><div class="note blue no-icon flat"><ol><li>提取图片的候选框 (Selective Search)</li><li>将框和全图传入CNN网络提取RoI特征</li><li>将RoI特征传入RoI池化层得到大小固定的输入</li><li>通过一系列FC层在最后一层分支分别对框回归和对物体分类</li><li>用对bbox进行回归得到的偏移量对bbox进行修正，并根据NMS对bbox进行筛选</li></ol></div><hr><div class="btns rounded grid5">            <a class="button" href='https://arxiv.org/pdf/1504.08083.pdf' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICCV </tag>
            
            <tag> OD </tag>
            
            <tag> two-stage </tag>
            
            <tag> 2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R-CNN：Region Proposal + CNN特征</title>
      <link href="2020/12/22/RCNN/"/>
      <url>2020/12/22/RCNN/</url>
      
        <content type="html"><![CDATA[<div class="tip fa-book"><p>RCNN第一次将CNN引入目标检测领域，相比之前(利用SIFT和HOG提取)将mAP提高30%以上，实现了53.3%的mAP</p></div><h2 id="mAP指标"><a href="#mAP指标" class="headerlink" title="mAP指标"></a>mAP指标</h2><p>补充一下mAP指标的背景知识</p><p>mAP(mean Average Precision)，字面意思，各类别 AP(检测精度) 的平均值</p><p>AP(某类别检测精度) 的计算方式则是P-R曲线下包围的面积(积分计算)，P-R曲线的P指的是准确率(Precision)，R指的是召回率(Recall)，召回率也叫查全率</p><p>他们的计算公式分别为</p><p>$P=\frac{TP}{TP+FP}$</p><p>$R=\frac{TP}{len(GTs)}$</p><p>公式中的TP，FP含义如下</p><ul><li>TP(True Positive)：IoU大于阈值的检测框数量(同一个GT(Ground Truth)的框只算一次)</li><li>FP(False Positive)：IoU小于等于阈值的检测框数量or同一个GT的多余检测框</li></ul><p>IoU(Intersection of Union) 用于衡量预测框和真实框的贴合程度</p><p>$IoU_{A,B}=\frac{S_A \ \cap \ S_B}{S_A \ \cup \ S_B}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-2.png"></p><h2 id="R-CNN训练阶段"><a href="#R-CNN训练阶段" class="headerlink" title="R-CNN训练阶段"></a>R-CNN训练阶段</h2><p>RCNN目标检测系统包含三个模块</p><ol><li>生成区域候选框(region proposals)</li><li>CNN提取特征</li><li>线性SVM分类</li></ol><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-1.png"></p><h3 id="区域候选框搜索"><a href="#区域候选框搜索" class="headerlink" title="区域候选框搜索"></a>区域候选框搜索</h3><p>用Selective Search搜索出2000个候选框</p><div class="tip bolt"><p>Selective Search算法主要思想：先将图片划分成许多的小区域，通过区域的相似度(颜色直方图，梯度直方图)按照区域<strong>从小到大</strong>聚合 (防止大区域不断吞并小区域)，重复直到整张图像合并成一个区域，输出所有<strong>曾经存在过的区域</strong>作为候选区域框</p></div><p>这里得到的候选框是大小不一的，但是传入CNN提取特征的必须是大小一致的，所以这里需要对候选框进行处理</p><p>这里作者尝试了几种方法：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-3.png"></p><ol><li>扩充到需要的规模大小 (B图)</li><li>用平均值在超出部分填充 (C图)</li><li>拉伸到对应尺寸 (D图)</li></ol><p>结果是，先以padding=16扩充，然后进行拉伸效果最好</p><h3 id="CNN特征提取"><a href="#CNN特征提取" class="headerlink" title="CNN特征提取"></a>CNN特征提取</h3><p>将候选区域数据缩放为$227 \times 227$，采用5个卷积层和2个连接层，从每个区域候选框中提取4096维向量</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RCNN-4.png"></p><p>作者首先在ILSVRC2012数据集上进行了有监督的预训练(Supervised pre-training)，然后微调(参数随机梯度下降)以进行域迁移(Domain-specific fine-tuning)</p><p>此外，还将CNN的ImageNet特定的1000路分类层替换为随机初始化的(N+1)路分类层(N个对象类+1背景)</p><p>训练过程中batchsize设置为128(正负样本32:96)，将和GT框IoU大于等于0.5的标记为正样本(物体类别)，小于0.5的标记为负样本(背景类别)</p><h3 id="SVM分类器"><a href="#SVM分类器" class="headerlink" title="SVM分类器"></a>SVM分类器</h3><p>对每个类别训练一个特定的SVM线性分类器，只有将物体全部包含在内的区域才被判定为正样本(区别于CNN的正样本)，这里作者经过测试发现IOU阈值设置为0.3是最优的(小于这个值就标记为负样本)</p><p>Q1：为什么不直接用CNN分类(softmax本身不就起到分类作用么)，而是在后面加个SVM分类器来画蛇添足</p><p>Q2：为什么SVM和CNN的正负样本定义不同</p><p>A：这两个问题其实是同一个问题，所以作者放在一起回答了，CNN容易过拟合，所以需要大量的训练数据，因此只能宽松标注条件，而SVM支持少样本训练所以阈值可以设置得低一些，同时因为CNN的宽松标注，导致其输出精度低，因此需要接SVM分类器</p><p>训练过程采用了标准的难负样本挖掘算法 (hard negative mining method)</p><div class="tip bolt"><p><strong>难负样本挖掘算法</strong></p><p>每次把那些顽固棘手的错误，送回去继续训练，直到成绩不再提升</p></div><h2 id="R-CNN测试阶段"><a href="#R-CNN测试阶段" class="headerlink" title="R-CNN测试阶段"></a>R-CNN测试阶段</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>候选框获取</p></p></div><div class="body"><ol><li><p>提取region proposals</p></li><li><p>将候选框归一化为227x227</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>特征提取</p></p></div><div class="body"><p>对每个候选区域，用CNN提取特征</p></div></div><div class="timenode"><div class="meta"><p><p>分类</p></p></div><div class="body"><p>对每个类别用SVM分类器打分</p></div></div><div class="timenode"><div class="meta"><p><p>去重</p></p></div><div class="body"><p>用非极大值抑制(NMS)去除多余的框</p><ol><li><p>将得分最高的bbox作为选定框</p></li><li><p>计算选定框与其它bbox的IoU，去除大于设定阈值的bbox</p></li><li><p>重复以上过程至待选集合为空</p></li></ol></div></div><div class="timenode"><div class="meta"><p><p>位置精修</p></p></div><div class="body"><p>对bbox回归，见下</p></div></div></div><h2 id="BBOX回归"><a href="#BBOX回归" class="headerlink" title="BBOX回归"></a>BBOX回归</h2><p>作者通过误差分析，发现mAP低的原因是位置框不准确，于是提出一种简单的方法来提高mAP，用pool5层的数据来训练一个回归器，正则化设置$\lambda = 1000$，输出为xy方向的平移和缩放</p><p>在测试阶段对类别的位置框进行调整</p><h2 id="RCNN的缺陷"><a href="#RCNN的缺陷" class="headerlink" title="RCNN的缺陷"></a>RCNN的缺陷</h2><ol><li>速度过慢 (Selective Search，CNN需要对所有候选框提取特征)</li><li>内存占用大 (在过程中需要提取并保存每个候选区域)</li><li>非端到端 (需要分开训练不同模块)</li></ol><hr><div class="btns rounded grid5">            <a class="button" href='https://arxiv.org/pdf/1311.2524.pdf' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> ⭐OD摘星楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> OD </tag>
            
            <tag> two-stage </tag>
            
            <tag> 2015 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫学习记录：动漫之家漫画爬取</title>
      <link href="2020/12/17/spider2/"/>
      <url>2020/12/17/spider2/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>爬虫时效性低，代码可能随时间失效，但爬虫思路不变</p></div><h2 id="获取漫画章节名"><a href="#获取漫画章节名" class="headerlink" title="获取漫画章节名"></a>获取漫画章节名</h2><p>首先，随便在排行榜上选了一个比较短的漫画《雪屋》 (没看过，并非推荐)</p><p><a href="https://www.dmzj.com/info/xuewu.html">漫画链接</a></p><p>审查一下元素，发现代表章节的都在class属性为list_con_li的<code>&lt;ul&gt;</code>标签下的<code>&lt;a&gt;</code>标签中，但是是<strong>倒序</strong>的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-1.png"></p><p>所以我们找到包含对应class的<code>&lt;ul&gt;</code>，然后遍历里面的<code>&lt;a&gt;</code>标签，通过往dict前端插入将倒序调整成顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line">target_url = <span class="string">&quot;https://www.dmzj.com/info/xuewu.html&quot;</span></span><br><span class="line">r = requests.get(url=target_url)</span><br><span class="line">bs = BeautifulSoup(r.text, <span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">list_con_li = bs.find(<span class="string">&#x27;ul&#x27;</span>, class_=<span class="string">&quot;list_con_li&quot;</span>)</span><br><span class="line">comic_list = list_con_li.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">chapter_names = []</span><br><span class="line">chapter_urls = []</span><br><span class="line"><span class="keyword">for</span> comic <span class="keyword">in</span> comic_list:</span><br><span class="line">    href = comic.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    name = comic.text</span><br><span class="line">    chapter_names.insert(<span class="number">0</span>, name)</span><br><span class="line">    chapter_urls.insert(<span class="number">0</span>, href)</span><br><span class="line"> </span><br><span class="line">print(chapter_names)</span><br><span class="line">print(chapter_urls)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-2.png"></p><p>“啪”的一下，很快就出来了</p><h2 id="获取页面内容"><a href="#获取页面内容" class="headerlink" title="获取页面内容"></a>获取页面内容</h2><p>然后我们尝试爬取一个章节的内容，打开预告章节</p><p><a href="https://www.dmzj.com/view/xuewu/109248.html">预告章节地址</a></p><p>打开之后，发现后面被自动加上了#@page=1，翻页的时候会变成#@page=2，但是这显然不是这一页图片的地址</p><p>审查元素，图片的地址在这里</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-3.png"></p><p>当然在html里面找还是有点费劲</p><p>有个更简单的办法</p><p>在network里面重加载一下页面，然后在img里面找，可以更容易地找到这张对应的图片</p><p>不得不吐槽一下这个动漫之家的广告也太多了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-4.png"></p><p>然后用这个地址，在html里面<kbd>CTRL</kbd>+<kbd>F</kbd>，就能在html里面定位对应的位置</p><p>然后审查元素，尝试抓取一下这张图的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">target_url = <span class="string">&quot;https://www.dmzj.com/view/xuewu/109248.html&quot;</span></span><br><span class="line">r = requests.get(url=target_url)</span><br><span class="line">bs = BeautifulSoup(r.text, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">comic_wraCon = bs.find(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;comic_wraCon autoHeight&quot;</span>)</span><br><span class="line">imgs = comic_wraCon.find_all(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">    src = img.get(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    print(src)</span><br></pre></td></tr></table></figure><p>结果是什么都没抓到</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bukexue.png"></p><p>这里我们采用view-source来检查一下原页面</p><div class="tip bolt"><p>view-source可以忽略动态加载的内容，查看网页源码</p><p>具体用法就是在网址前加上view-source:</p></div><p>在source里面查找对应的class，发现是空的，怪不得抓不到图片地址，因为图片是<strong>动态加载</strong>的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-5.png"></p><p>看一下图片的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;images.dmzj.com&#x2F;img&#x2F;chapterpic&#x2F;33872&#x2F;127406&#x2F;16007394818532.jpg</span><br></pre></td></tr></table></figure><p>我们在source里面搜<code>16007394818532</code></p><p>找到如下代码</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-6.png"></p><p>图片的链接就藏在里面</p><p>我们用正则表达式去匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.dmzj.com/view/xuewu/109248.html&#x27;</span></span><br><span class="line">r = requests.get(url=url)</span><br><span class="line">html = BeautifulSoup(r.text, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">script_info = html.script</span><br><span class="line">pics = re.findall(<span class="string">&#x27;\d&#123;14&#125;&#x27;</span>, <span class="built_in">str</span>(script_info))</span><br><span class="line">chapter1 = re.findall(<span class="string">&#x27;\|(\d&#123;5&#125;)\|&#x27;</span>, <span class="built_in">str</span>(script_info))[<span class="number">0</span>]</span><br><span class="line">chapter2 = re.findall(<span class="string">&#x27;\|(\d&#123;6&#125;)\|&#x27;</span>, <span class="built_in">str</span>(script_info))[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> pic <span class="keyword">in</span> pics:</span><br><span class="line">    url = <span class="string">&#x27;https://images.dmzj.com/img/chapterpic/&#x27;</span> + chapter1 + <span class="string">&#x27;/&#x27;</span> + chapter2 + <span class="string">&#x27;/&#x27;</span> + pic + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">    print(url)</span><br></pre></td></tr></table></figure><div class="tip bolt"><p>正则表达式re中，\d{x}表示在字符串中获取长度为x的连续数字</p></div><p>chapter1和2这里取数组第一个元素是因为输出看了一下发现后面的不对劲，就比如chapter1的正则数组[‘127406’, ‘109248’]，第二个数是页面的尾号，不构成图片地址</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-7.png"></p><p>跟网页图片顺序比对了一下，发现没问题</p><p>那我们就可以随便挑选一张图片来下载一下了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line">dn_url = <span class="string">&#x27;https://images.dmzj.com/img/chapterpic/33872/127406/16007394818532.jpg&#x27;</span></span><br><span class="line">urlretrieve(dn_url,<span class="string">&#x27;1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后就可以得到一个</p><div class="tip error"><p>urllib.error.HTTPError: HTTP Error 403: Forbidden</p></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/bukexue.png"></p><p>403表示资源不可用</p><p>我们打开<a href="https://images.dmzj.com/img/chapterpic/33872/127406/16007394818532.jpg">图片链接</a>查看</p><p>发现也是403，但是从站内点开的同一个地址却是图片，只是刷新一下之后也会变成403</p><p>说明这是一种通过Referer的反爬手段，仅允许站内用户访问</p><p>所以我们得在requests请求中加入包含referer的header</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">download_header = &#123;</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.dmzj.com/view/yaoshenji/41917.html&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dn_url = <span class="string">&#x27;https://images.dmzj.com/img/chapterpic/33872/127406/16007394818532.jpg&#x27;</span></span><br><span class="line"><span class="keyword">with</span> closing(requests.get(dn_url, headers=download_header, stream=<span class="literal">True</span>)) <span class="keyword">as</span> response:</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.jpg&#x27;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> response:</span><br><span class="line">                file.write(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;链接异常&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;下载完成！&#x27;</span>)</span><br></pre></td></tr></table></figure><div class="tip bolt"><p>status_code=200表示请求已成功，请求所希望的响应头或数据体将随此响应返回</p></div><p>成功下载图片</p><h2 id="代码总览"><a href="#代码总览" class="headerlink" title="代码总览"></a>代码总览</h2><p>在pics这里还是加了个排序，因为第一次爬下来的时候发现除了预告章节之外剩下的顺序都不对，头秃</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建保存目录</span></span><br><span class="line">save_dir = <span class="string">&#x27;雪屋&#x27;</span></span><br><span class="line"><span class="keyword">if</span> save_dir <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(<span class="string">&#x27;./&#x27;</span>):</span><br><span class="line">    os.mkdir(save_dir)</span><br><span class="line"></span><br><span class="line">target_url = <span class="string">&quot;https://www.dmzj.com/info/xuewu.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取章节链接和章节名</span></span><br><span class="line">r = requests.get(url=target_url)</span><br><span class="line">bs = BeautifulSoup(r.text)</span><br><span class="line">list_con_li = bs.find(<span class="string">&#x27;ul&#x27;</span>, class_=<span class="string">&quot;list_con_li&quot;</span>)</span><br><span class="line">cartoon_list = list_con_li.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">chapter_names = []</span><br><span class="line">chapter_urls = []</span><br><span class="line"><span class="keyword">for</span> cartoon <span class="keyword">in</span> cartoon_list:</span><br><span class="line">    href = cartoon.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    name = cartoon.text</span><br><span class="line">    chapter_names.insert(<span class="number">0</span>, name)</span><br><span class="line">    chapter_urls.insert(<span class="number">0</span>, href)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载漫画</span></span><br><span class="line"><span class="keyword">for</span> i, url <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(chapter_urls)):</span><br><span class="line">    download_header = &#123;</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: url</span><br><span class="line">    &#125;</span><br><span class="line">    name = chapter_names[i]</span><br><span class="line">    chapter_save_dir = os.path.join(save_dir, name)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(save_dir):</span><br><span class="line">        os.mkdir(chapter_save_dir)</span><br><span class="line">        r = requests.get(url=url)</span><br><span class="line">        html = BeautifulSoup(r.text)</span><br><span class="line">        script_info = html.script</span><br><span class="line">        pics = re.findall(<span class="string">&#x27;\d&#123;14&#125;&#x27;</span>, <span class="built_in">str</span>(script_info))</span><br><span class="line">        pics = <span class="built_in">sorted</span>(pics, key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x))</span><br><span class="line">        chapter1 = re.findall(<span class="string">&#x27;\|(\d&#123;5&#125;)\|&#x27;</span>, <span class="built_in">str</span>(script_info))[<span class="number">0</span>]</span><br><span class="line">        chapter2 = re.findall(<span class="string">&#x27;\|(\d&#123;6&#125;)\|&#x27;</span>, <span class="built_in">str</span>(script_info))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> idx, pic <span class="keyword">in</span> <span class="built_in">enumerate</span>(pics):</span><br><span class="line">            url = <span class="string">&#x27;https://images.dmzj.com/img/chapterpic/&#x27;</span> + chapter1 + <span class="string">&#x27;/&#x27;</span> + chapter2 + <span class="string">&#x27;/&#x27;</span> + pic + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            pic_name = <span class="string">&#x27;%03d.jpg&#x27;</span> % (idx + <span class="number">1</span>)</span><br><span class="line">            pic_save_path = os.path.join(chapter_save_dir, pic_name)</span><br><span class="line">            <span class="keyword">with</span> closing(requests.get(url, headers=download_header, stream=<span class="literal">True</span>)) <span class="keyword">as</span> response:</span><br><span class="line">                <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(pic_save_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                        <span class="keyword">for</span> data <span class="keyword">in</span> response:</span><br><span class="line">                            file.write(data)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">&#x27;链接异常&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;下载成功&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功下载漫画《雪屋》</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-8.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider2-9.png"></p><div class="tip success"><p>漫画爬虫制作完毕</p></div>]]></content>
      
      
      <categories>
          
          <category> 🔬爬虫研究所 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYTHOH </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫学习记录：用Requests和bs4爬一本小说</title>
      <link href="2020/12/16/spider1/"/>
      <url>2020/12/16/spider1/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>爬虫时效性低，代码可能随时间失效，但爬虫思路不变</p></div><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>首先介绍一下采用的工具requests和bs4</p><p>这里主要用request.get向浏览器发起get请求，利用bs4中的Beautiful Soup对html内容进行解析，提取真正需要的内容，文档如下</p><div class="site-card-group"><a class="site-card" href="https://2.python-requests.org/zh_CN/latest/user/quickstart.html"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-1.png"/></div><div class="info"><span class="title">Requests</span><span class="desc">Requests quickstart</span></div></a><a class="site-card" href="https://beautifulsoup.readthedocs.io/zh_CN/latest/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-2.png"/></div><div class="info"><span class="title">Beautiful Soup</span><span class="desc">Beautiful Soup中文文档</span></div></a></div><h2 id="页面爬取"><a href="#页面爬取" class="headerlink" title="页面爬取"></a>页面爬取</h2><p>首先用requests来获取小说页面的html，这里选择笔趣看的《心魔》一书</p><p>打开第一节，将网址记录下来</p><p>在pycharm中写下如下代码，就可以获取到该页面的html</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    target = <span class="string">&#x27;https://www.bqkan.com/11_11154/4135502.html&#x27;</span></span><br><span class="line">    req = requests.get(url=target)</span><br><span class="line">    print(req.text)</span><br></pre></td></tr></table></figure><p>结果如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-3.png"></p><p>这时候就要用上我们的BeaufifulSoup</p><p>我们发现需要的内容在showtxt里面，并且只有一个showtxt，那么我们在所有的div里面找showtxt即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    target = <span class="string">&#x27;https://www.bqkan.com/11_11154/4135502.html&#x27;</span></span><br><span class="line">    req = requests.get(url=target)</span><br><span class="line">    <span class="comment"># print(req.text)</span></span><br><span class="line">    html = req.text</span><br><span class="line">    bf = BeautifulSoup(html)</span><br><span class="line">    texts = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;showtxt&#x27;</span>)</span><br><span class="line">    print(texts)</span><br></pre></td></tr></table></figure><p>find_all(‘div’, class_=’showtxt’)的意思就是找到class为showtxt的div，这里class要加下划线是因为class是python本身的语法词</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-4.png"></p><p>成功获取showtxt内容，但是我们发现有很多乱七八糟的不想要的东西，需要进行处理只留下文本</p><p>我们发现每两行之间除了<code>&lt;br&gt;</code>之外，还有八个空格，所以我们把空格替换成换行，然后忽略所有的标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(texts[<span class="number">0</span>].text.replace(<span class="string">&#x27;\xa0&#x27;</span> * <span class="number">8</span>, <span class="string">&#x27;\n\n&#x27;</span>))</span><br></pre></td></tr></table></figure><p>就可以得到这一章的文本内容了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-5.png"></p><h2 id="目录爬取"><a href="#目录爬取" class="headerlink" title="目录爬取"></a>目录爬取</h2><p>现在我们需要爬下一整本小说，则需要获取每个章节的网址，然后到每个网址去爬对应的文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">    req = requests.get(url=target)</span><br><span class="line">    print(req.text)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-6.png"></p><p>应该是这个位置，可惜是乱码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">    req = requests.get(url=target).content.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    print(req)</span><br></pre></td></tr></table></figure><p>用GBK解码 (不知道为啥这么写，我试出来的)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-7.png"></p><p>完美拿到了目录页面 (虽说没有中文也没啥问题，只要有章节网址就行了)</p><p>然后我们审查元素，发现目录这个div叫listmain，所以提取listmain</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">    req = requests.get(url=target).content.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(req)</span></span><br><span class="line">    bf = BeautifulSoup(req, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    listmain = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;listmain&#x27;</span>)</span><br><span class="line">    print(listmain)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-8.png"></p><p>然后我们把每个a里面的东西拿出来，做地址的拼接处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = <span class="string">&#x27;http://www.biqukan.com&#x27;</span></span><br><span class="line">    target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">    req = requests.get(url=target).content.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(req)</span></span><br><span class="line">    bf = BeautifulSoup(req, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    listmain = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;listmain&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(listmain)</span></span><br><span class="line">    a_bf = BeautifulSoup(<span class="built_in">str</span>(listmain[<span class="number">0</span>]), features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    a = a_bf.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> a:</span><br><span class="line">        print(each.string, server + each.get(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure><p>得到章节+地址</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-10.png"></p><p>前面12行是我们不想要的，处理的时候在数组里面抹去</p><p>然后我们整合一下之前的模块，把它们函数化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">downloader</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.server = <span class="string">&#x27;http://www.biqukan.com&#x27;</span></span><br><span class="line">        self.target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">        self.names = []  <span class="comment"># 存放章节名</span></span><br><span class="line">        self.urls = []  <span class="comment"># 存放章节的页面链接</span></span><br><span class="line">        self.nums = <span class="number">0</span>  <span class="comment"># 章节数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_download_url</span>(<span class="params">self</span>):</span></span><br><span class="line">        req = requests.get(url=self.target).content.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(req)</span></span><br><span class="line">        bf = BeautifulSoup(req, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        listmain = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;listmain&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(listmain)</span></span><br><span class="line">        a_bf = BeautifulSoup(<span class="built_in">str</span>(listmain[<span class="number">0</span>]), features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        a = a_bf.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 掐头去尾，拿掉不要的章节</span></span><br><span class="line">        self.nums = <span class="built_in">len</span>(a[<span class="number">12</span>:-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> a[<span class="number">12</span>:-<span class="number">2</span>]:</span><br><span class="line">            self.names.append(each.string)</span><br><span class="line">            self.urls.append(self.server + each.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">            <span class="comment"># print(each.string, self.server + each.get(&#x27;href&#x27;))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_contents</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        req = requests.get(url=target)</span><br><span class="line">        html = req.text</span><br><span class="line">        bf = BeautifulSoup(html, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        texts = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;showtxt&#x27;</span>)</span><br><span class="line">        texts = texts[<span class="number">0</span>].text.replace(<span class="string">&#x27;\xa0&#x27;</span> * <span class="number">8</span>, <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> texts</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dl = downloader()</span><br><span class="line">    dl.get_download_url()</span><br></pre></td></tr></table></figure><h2 id="下载与保存"><a href="#下载与保存" class="headerlink" title="下载与保存"></a>下载与保存</h2><p>最后我们需要一个模块来把爬到的内容下载并保存起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">self, name, path, text</span>):</span></span><br><span class="line">    write_flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(name + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.writelines(text)</span><br><span class="line">        f.write(<span class="string">&#x27;\n\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dl = downloader()</span><br><span class="line">    dl.get_download_url()</span><br><span class="line">    print(<span class="string">&#x27;-----------开始下载----------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dl.nums):</span><br><span class="line">        dl.writer(dl.names[i], <span class="string">&#x27;心魔.txt&#x27;</span>, dl.get_contents(dl.urls[i]))</span><br><span class="line">        print(dl.names[i]+<span class="string">&#x27; 下载完成&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;---------全书下载完成---------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>全部的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">downloader</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.server = <span class="string">&#x27;http://www.biqukan.com&#x27;</span></span><br><span class="line">        self.target= <span class="string">&#x27;https://www.bqkan.com/11_11154/&#x27;</span></span><br><span class="line">        self.names = []  <span class="comment"># 存放章节名</span></span><br><span class="line">        self.urls = []  <span class="comment"># 存放章节的页面链接</span></span><br><span class="line">        self.nums = <span class="number">0</span>  <span class="comment"># 章节数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_download_url</span>(<span class="params">self</span>):</span></span><br><span class="line">        req = requests.get(url=self.target).content.decode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(req)</span></span><br><span class="line">        bf = BeautifulSoup(req, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        listmain = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;listmain&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(listmain)</span></span><br><span class="line">        a_bf = BeautifulSoup(<span class="built_in">str</span>(listmain[<span class="number">0</span>]), features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        a = a_bf.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 掐头去尾，拿掉不要的章节</span></span><br><span class="line">        self.nums = <span class="built_in">len</span>(a[<span class="number">12</span>:-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> a[<span class="number">12</span>:-<span class="number">2</span>]:</span><br><span class="line">            self.names.append(each.string)</span><br><span class="line">            self.urls.append(self.server + each.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">            <span class="comment"># print(each.string, self.server + each.get(&#x27;href&#x27;))</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_contents</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        req = requests.get(url=target)</span><br><span class="line">        html = req.text</span><br><span class="line">        bf = BeautifulSoup(html, features=<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">        texts = bf.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&#x27;showtxt&#x27;</span>)</span><br><span class="line">        texts = texts[<span class="number">0</span>].text.replace(<span class="string">&#x27;\xa0&#x27;</span> * <span class="number">8</span>, <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> texts</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">self, name, path, text</span>):</span></span><br><span class="line">        write_flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(name + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            f.writelines(text)</span><br><span class="line">            f.write(<span class="string">&#x27;\n\n\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dl = downloader()</span><br><span class="line">    dl.get_download_url()</span><br><span class="line">    print(<span class="string">&#x27;-----------开始下载----------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dl.nums):</span><br><span class="line">        dl.writer(dl.names[i], <span class="string">&#x27;心魔.txt&#x27;</span>, dl.get_contents(dl.urls[i]))</span><br><span class="line">        print(dl.names[i]+<span class="string">&#x27; 下载完成&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;---------全书下载完成---------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后就可以愉快地下起来了，虽然比较慢 (可以多线程加速，但是我还不会)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spider1-11.png"></p><div class="tip success"><p>小说爬虫制作完毕</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下爬虫的思路，大体可以分三个步骤</p><ol><li>发起HTTP请求，获取数据</li><li>解析数据，提取想要的部分</li><li>下载并保存数据</li></ol><p>爬虫spider就是一只互联网上的小蜘蛛，由你来指定规则控制它通过哪条丝线从一张网爬到另一张网，在每张网上抓取什么信息</p><psw>最后，《心魔》真的很好看，强力推荐</psw>]]></content>
      
      
      <categories>
          
          <category> 🔬爬虫研究所 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PYTHOH </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习记录：多媒体与超链接</title>
      <link href="2020/12/14/html3/"/>
      <url>2020/12/14/html3/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>本文所有展示效果都是使用了博客css后的效果，并非单纯html效果</p></div><p>记录一下html媒体嵌入与超链接的方法</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>先介绍一下最基础的超链接方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/2020/12/14/html2/&quot;</span>&gt;</span>HTML学习记录：文字排版<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="/2020/12/14/html2/">HTML学习记录：文字排版</a></p><p>当然我们还可以为超链接增加图片，这种方式叫块级链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/2020/12/14/html2/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html2-1.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下所示，点击图片即打开链接</p><a href="/2020/12/14/html2/">  <img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html2-1.png"  id="superStar"></a><h3 id="文档内链接"><a href="#文档内链接" class="headerlink" title="文档内链接"></a>文档内链接</h3><p>除了链接到别的网页，还可以在html文档的内部进行链接，不过首先要在链接的元素上加入id，比如我们给上文的图片链接加个id，然后尝试去链接到它</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入id--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/2020/12/14/html2/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html2-1.png&quot;</span> <span class="attr">id</span>=<span class="string">&quot;superStar&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--链接写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#superStar&quot;</span>&gt;</span>Super Star<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跳转到 <a href="#superStar">Super Star</a></p><p>当然可以跳转到别的页面的对应位置，在#前加上对应url即可</p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p>我们可以给链接加上download属性，使得链接不再是跳转至页面，而是去完成下载任务</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span></span><br><span class="line">  下载最新的 Firefox 中文版 - Windows（64位）</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="图片嵌入"><a href="#图片嵌入" class="headerlink" title="图片嵌入"></a>图片嵌入</h2><p>比如本文的封面图，和本文生成的html在同一个文件夹下，就可以直接用如下代码嵌入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果这张图片存储在和html页面同路径的images文件夹下</p><p>则需要使用如下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/1.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="备选文本"><a href="#备选文本" class="headerlink" title="备选文本"></a>备选文本</h3><p>备选文本用于图没了的情况下显示，使用方法如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;0.png&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">&quot;图没了&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="0.png"     alt="图没了"></p><h3 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h3><p>我们还可以为图片添加宽度高度和标题，标题在鼠标悬停在图片上时会显示，而规定了高度和宽度会使得加载速度更快</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.png&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">&quot;图没了&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">width</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">height</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">title</span>=<span class="string">&quot;图片的标题&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="1.png"     alt="图没了"     width="400"     height="300"     title="图片的标题"></p><hr><h2 id="音视频嵌入"><a href="#音视频嵌入" class="headerlink" title="音视频嵌入"></a>音视频嵌入</h2><p>音视频都支持多源，来满足不同浏览器的需求</p><p>视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">muted</span></span></span><br><span class="line"><span class="tag">       <span class="attr">poster</span>=<span class="string">&quot;poster.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>H5为视频新增了一些可选择的属性 (摘录自MDN)</p><ol><li><p>width 和 height:<br> 你可以用属性控制视频的尺寸，也可以用 CSS 来控制视频尺寸。 无论使用哪种方式，视频都会保持它原始的长宽比 — 也叫做纵横比。如果你设置的尺寸没有保持视频原始长宽比，那么视频边框将会拉伸，而未被视频内容填充的部分，将会显示默认的背景颜色。</p></li><li><p>autoplay:<br> 这个属性会使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。建议不要应用这个属性在你的网站上，因为用户们会比较反感自动播放的媒体文件。</p></li><li><p>loop:<br> 这个属性可以让音频或者视频文件循环播放。同样不建议使用，除非有必要。</p></li><li><p>muted:<br> 这个属性会导致媒体播放时，默认关闭声音。</p></li><li><p>poster:<br> 这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。</p></li><li><p>preload:<br> 这个属性被用来缓冲较大的文件，有3个值可选：</p><pre><code> &quot;none&quot; ：不缓冲 &quot;auto&quot; ：页面加载后缓存媒体文件 &quot;metadata&quot; ：仅缓冲文件的元数据</code></pre></li></ol><p>音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="通用嵌入工作"><a href="#通用嵌入工作" class="headerlink" title="通用嵌入工作"></a>通用嵌入工作</h2><p>以pdf为例，可以使用<code>embed</code>或<code>object</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;900&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">src</span>=<span class="string">&quot;barcodeTree.pdf&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;mypdf.pdf&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;application/pdf&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;800&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1200&quot;</span> <span class="attr">typemustmatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://forever97.github.io/dataViz/treeVis/barcodeTree/">示例</a></p><hr><h2 id="Iframe嵌入"><a href="#Iframe嵌入" class="headerlink" title="Iframe嵌入"></a>Iframe嵌入</h2><p>Iframe允许将整个web页嵌入到另一个网页</p><p>举个🌰，偷走bilibili的镇站之宝</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://player.bilibili.com/player.html?aid=19390801&amp;cid=31621681&amp;page=1&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>效果如下</p><iframe src="https://player.bilibili.com/player.html?aid=19390801&cid=31621681&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> <div class="tip success"><p>记录完毕</p></div>]]></content>
      
      
      <categories>
          
          <category> 🍰HTML点心铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习记录：文字排版</title>
      <link href="2020/12/14/html2/"/>
      <url>2020/12/14/html2/</url>
      
        <content type="html"><![CDATA[<div class="tip warning"><p>本文所有展示效果都是使用了博客css后的效果，并非单纯html效果</p></div><p>记录一下html中的排版标签</p><h2 id="标题与段落"><a href="#标题与段落" class="headerlink" title="标题与段落"></a>标题与段落</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>顶级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><h1>顶级标题</h1><h2>二级标题</h2><h3>三级标题</h3><h4>四级标题</h4><h5>五级标题</h5><h6>六级标题</h6><p>段落</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表分为无序列表(Unordered Lists)和有序列表(Ordered Lists)，以及自定义列表</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><ul>  <li>元素一</li>  <li>元素二</li>  <li>元素三</li>  <li>元素四</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>元素四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><ol>  <li>元素一</li>  <li>元素二</li>  <li>元素三</li>  <li>元素四</li></ol><p>列表是可以嵌套的，比如在有序列表的<code>&lt;li&gt;</code>标签中嵌套一个无序列表或者有序列表都是可行的</p><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CPU<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器的默认样式会在描述列表的描述部分 (description description) 和描述术语 (description terms) 之间产生缩进，效果如下</p><dl>   <dt>计算机</dt>   <dd>用来计算的仪器</dd>   <dd>CPU</dd>   <dt>显示器</dt>   <dd>以视觉方式显示信息的装置</dd></dl><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span><span class="attr">cellpadding</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;10&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;yellow&quot;</span>  <span class="attr">frame</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义表格，表的边框、单元格边距、单元格间距 、背景颜色、框架属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span><span class="comment">&lt;!-- 定义标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!-- 定义行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="comment">&lt;!-- 定义表头--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>信息<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!-- 定义表头,跨两列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- 定义单元格内容和背景--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>信息1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>信息2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table border="1"cellpadding="10" cellspacing="10" bgcolor="yellow"  frame="box"><!-- 定义表格，表的边框、单元格边距、单元格间距 、背景颜色、框架属性-->    <caption>我的标题</caption><!-- 定义标题-->    <tr><!-- 定义行-->        <th>表头</th><!-- 定义表头-->        <th colspan="2">信息</th> <!-- 定义表头,跨两列-->    </tr>    <tr>        <td>单元格内容</td><!-- 定义单元格内容和背景-->        <td bgcolor="lightgreen">信息1</td>        <td>信息2</td>    </tr></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">    块引用</span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote>    块引用</blockquote><p>浏览器在渲染块引用时默认会增加缩进，作为引用的一个指示符</p><h3 id="行内引用"><a href="#行内引用" class="headerlink" title="行内引用"></a>行内引用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>行内引用<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br></pre></td></tr></table></figure><p><q>行内引用</q></p><h2 id="特殊文本样式"><a href="#特殊文本样式" class="headerlink" title="特殊文本样式"></a>特殊文本样式</h2><p>文本强调</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下</p><p><strong>粗体</strong><br><em>斜体</em></p><hr><p>缩略 <code>&lt;abbr&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我们使用 <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;超文本标记语言（Hyper text Markup Language）&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> 来组织网页文档。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们使用 <abbr title="超文本标记语言（Hyper text Markup Language）">HTML</abbr> 来组织网页文档。</p><hr><p>上下标 <code>&lt;sup&gt;</code> 和 <code>&lt;sub&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>x<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>+y<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>x<sup>2</sup>+y<sub>2</sub></p><hr><p>计算机代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br><span class="line">&lt;&#x2F;code&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">    所见</span><br><span class="line">        即所得</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;var&gt;变量名&lt;&#x2F;var&gt;</span><br><span class="line"></span><br><span class="line">&lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;V&lt;&#x2F;kbd&gt;</span><br><span class="line"></span><br><span class="line">&lt;samp&gt;计算机程序输出&lt;&#x2F;samp&gt;</span><br></pre></td></tr></table></figure><code><pre>    cout << "hello world" << endl;</pre></code><pre>    所见        即所得</pre><p><var>变量名</var></p><p><kbd>Ctrl</kbd>+<kbd>V</kbd></p><p><samp>计算机程序输出</samp></p><div class="tip success"><p>记录完毕</p></div>]]></content>
      
      
      <categories>
          
          <category> 🍰HTML点心铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Github Action实现全自动部署</title>
      <link href="2020/12/11/githubAction/"/>
      <url>2020/12/11/githubAction/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客在部署的时候，随着文章越来越多，编译的时间也会越来越长，而通过Github Action，我们可以在完成博客编写和修改之后直接将改动push到远程仓库，让其自动完成编译和部署</p><h2 id="创建存放源码的私有仓库"><a href="#创建存放源码的私有仓库" class="headerlink" title="创建存放源码的私有仓库"></a>创建存放源码的私有仓库</h2><p>首先，需要创建一个用来存放Hexo博客源码的<strong>私有</strong>仓库</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-1.png"></p><p>之后我们需要将源码push到这里</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-2.png"></p><div class="tip warning"><p>采用私有仓库的原因是以下的操作会使用token，如果token被盗用则盗用者可以任意操作你的git仓库</p></div><h2 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h2><h3 id="Github-Token"><a href="#Github-Token" class="headerlink" title="Github Token"></a>Github Token</h3><p>在github的Settings中选择 Developer Settings -&gt; Personal access tokens -&gt; generate new token，token名字任意，勾选上repo项</p><p><a href="https://github.com/settings/tokens">快速访问</a></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-3.png"></p><p>确定生成后，将token复制下来保存好</p><div class="tip warning"><p>官方提示：Make sure to copy your new personal access token now. You won’t be able to see it again!</p><p>就是说这个只显示一次，如果你丢失了这个token，那么你得重新再生成一个</p></div><h3 id="Gitee-Token"><a href="#Gitee-Token" class="headerlink" title="Gitee Token"></a>Gitee Token</h3><p>头像(右上角) -&gt; 设置 -&gt; 私人令牌 -&gt; 生成新令牌</p><p><a href="https://gitee.com/profile/personal_access_tokens">快速访问</a></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-4.png"></p><p>同样需要保存好这个token</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-5.png"></p><h2 id="配置deploy项"><a href="#配置deploy项" class="headerlink" title="配置deploy项"></a>配置deploy项</h2><p>打开站点配置文件_config.yml，对deploy进行修改</p><p>修改格式如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">    gitHub: https://[GithubUsername]:[GithubToken]@github.com/[GithubUsername]/[GithubBlogRepo].git</span><br><span class="line">    gitee: https://[GiteeUsername]:[GiteeToken]@gitee.com/[GiteeUsername]/[GiteeBlogRepo].git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="配置Github-Action"><a href="#配置Github-Action" class="headerlink" title="配置Github Action"></a>配置Github Action</h2><p>在博客的根目录新建.github文件夹，进入并创建workflows文件夹，然后在其内创建autodeploy.yml</p><p>将以下代码粘入其中</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 当有改动推送到master分支时，启动Action</span><br><span class="line">name: 自动部署</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="line"></span><br><span class="line">  release:</span><br><span class="line">    types:</span><br><span class="line">      - published</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: 检查分支</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        ref: master #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="line"></span><br><span class="line">    - name: 安装 Node</span><br><span class="line">      uses: actions/setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;12.x&quot;</span><br><span class="line"></span><br><span class="line">    - name: 安装 Hexo</span><br><span class="line">      run: |</span><br><span class="line">        export TZ=&#x27;Asia/Shanghai&#x27;</span><br><span class="line">        npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">    - name: 缓存 Hexo</span><br><span class="line">      uses: actions/cache@v1</span><br><span class="line">      id: cache</span><br><span class="line">      with:</span><br><span class="line">        path: node_modules</span><br><span class="line">        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: 安装依赖</span><br><span class="line">      if: steps.cache.outputs.cache-hit != &#x27;true&#x27;</span><br><span class="line">      run: |</span><br><span class="line">        npm install --save</span><br><span class="line"></span><br><span class="line">    - name: 生成静态文件</span><br><span class="line">      run: |</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line"></span><br><span class="line">    - name: 部署</span><br><span class="line">      run: |</span><br><span class="line">        git config --global user.name &quot;[GithubUsername]&quot;</span><br><span class="line">        git config --global user.email &quot;[GithubEmail]&quot;</span><br><span class="line">        git clone git@github.com:[GithubUsername]/[GithubBlogRepo].git .deploy_git</span><br><span class="line">        # =====注意.deploy_git前面有个空格=====</span><br><span class="line">        # clone 静态文件仓库，防止 Hexo 推送时覆盖整个静态文件仓库，只推送有更改的文件</span><br><span class="line">        hexo deploy</span><br></pre></td></tr></table></figure><h2 id="配置远程仓库和分支"><a href="#配置远程仓库和分支" class="headerlink" title="配置远程仓库和分支"></a>配置远程仓库和分支</h2><p>在.gitignore中输入以下内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure><p>然后提交源码到私有仓库</p><p>指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin <span class="comment"># 删除原有仓库链接</span></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git <span class="comment">#[SourceRepo]为新的存放源码的github私有仓库</span></span><br><span class="line">git checkout -b master <span class="comment"># 切换到master分支，</span></span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 如果不是，后面的所有设置的分支记得保持一致</span></span><br><span class="line"><span class="comment"># 2020年10月以后，新建仓库的默认分支换成main</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action update&quot;</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br></pre></td></tr></table></figure><h2 id="遇到的一些奇怪错误"><a href="#遇到的一些奇怪错误" class="headerlink" title="遇到的一些奇怪错误"></a>遇到的一些奇怪错误</h2><p>上传完成之后打开仓库的action，发现已经开始跑action了，但是我这里部署失败了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-7.png"></p><p>检查了各个仓库的拼写，重新生成了token都没有解决这个问题</p><p>所以我把部署分开写，然后检查在哪个环节出的问题</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-8.png"></p><p>发现是clone这句出了问题，问了一下Akilar，得到的答复是</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-9.png"></p><p>于是我注释了这句，最后的文件为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 当有改动推送到master分支时，启动Action</span><br><span class="line">name: 自动部署</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="line"></span><br><span class="line">  release:</span><br><span class="line">    types:</span><br><span class="line">      - published</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: 检查分支</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        ref: main #2020年10月后github新建仓库默认分支改为main，注意更改</span><br><span class="line"></span><br><span class="line">    - name: 安装 Node</span><br><span class="line">      uses: actions/setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;12.x&quot;</span><br><span class="line"></span><br><span class="line">    - name: 安装 Hexo</span><br><span class="line">      run: |</span><br><span class="line">        export TZ=&#x27;Asia/Shanghai&#x27;</span><br><span class="line">        npm install hexo-cli -g</span><br><span class="line">    - name: 缓存 Hexo</span><br><span class="line">      uses: actions/cache@v1</span><br><span class="line">      id: cache</span><br><span class="line">      with:</span><br><span class="line">        path: node_modules</span><br><span class="line">        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: 安装依赖</span><br><span class="line">      if: steps.cache.outputs.cache-hit != &#x27;true&#x27;</span><br><span class="line">      run: |</span><br><span class="line">        npm install --save</span><br><span class="line">    - name: 生成静态文件</span><br><span class="line">      run: |</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">    - name: 用户名</span><br><span class="line">      run: |</span><br><span class="line">        git config --global user.name &quot;forever97&quot;</span><br><span class="line">    - name: 邮箱</span><br><span class="line">      run: |</span><br><span class="line">        git config --global user.email &quot;857426255@qq.com&quot;</span><br><span class="line">    #- name: 克隆静态文件仓库</span><br><span class="line">      #run: |</span><br><span class="line">        #git clone git@github.com:forever97/forever97.github.io.git .deploy_git</span><br><span class="line">        # =====注意.deploy_git前面有个空格=====</span><br><span class="line">        # clone 静态文件仓库，防止 Hexo 推送时覆盖整个静态文件仓库，只推送有更改的文件</span><br><span class="line">    - name: 部署</span><br><span class="line">      run: |</span><br><span class="line">        hexo deploy</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/githubAction-10.png"></p><div class="tip success"><p>部署成功</p></div>]]></content>
      
      
      <categories>
          
          <category> 🍺BLOG酒肆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vercel加速博客访问</title>
      <link href="2020/12/11/vercel/"/>
      <url>2020/12/11/vercel/</url>
      
        <content type="html"><![CDATA[<p>Vercel可以提供免费的serverless和全局CDN服务，并且可以根据git上hexo博客的master(main)分支是否变动来启动自动部署</p><h2 id="在Vercel上部署"><a href="#在Vercel上部署" class="headerlink" title="在Vercel上部署"></a>在Vercel上部署</h2><ul><li>首先访问Vercel，在右上角点击注册，新建项目并选择From Git Repository</li></ul><div class="site-card-group"><a class="site-card" href="https://vercel.com/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-0.png"/></div><div class="info"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-00.png"/><span class="title">Vercel</span><span class="desc">Vercel官网地址</span></div></a></div><ul><li>在页面输入git项目地址</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-1.png"></p><p>然后对项目进行确认，如果不是自己的项目，系统会自动帮你fork到自己的库</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-2.png"></p><ul><li>选择person account后，需要为自己的Github安装Vercel，All repositories表示为所有的git仓库安装，Only select repositories表示只为当前仓库安装</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-3.png"></p><p>Vercel会识别出hexo博客的静态页面，点击continue即可</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-4.png"></p><ul><li>最后import project，Vercel的PROJECT NAME可以自定义，但是之后不支持修改</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-5.png"></p><p>然后就可以访问Vercel部署的页面了</p><div class="tip success"><p>完成</p></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-6.png"></p><p>可以感觉到访问比github快多了</p><div class="site-card-group"><a class="site-card" href="https://forever97-github-io.vercel.app/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-7.png"/></div><div class="info"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/avatar.png"/><span class="title">forever97</span><span class="desc">forever97's blog</span></div></a></div><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><ul><li>在Project-&gt;Setting-&gt;Domain中可以设置域名，点击<code>ADD</code></li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-8.png"></p><ul><li>然后到域名供应商这里添加解析记录</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-9.png"></p><ul><li>将DNS设置为Vercel提供的</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/vercel-10.png"></p><p>等域名解析生效之后就可以用自定义的域名来访问vercel上部署的blog了</p><div class="tip success"><p>自定义域名完成</p></div>]]></content>
      
      
      <categories>
          
          <category> 🍺BLOG酒肆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习记录：基础概念</title>
      <link href="2020/12/10/html1/"/>
      <url>2020/12/10/html1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h2><p>在VSC上写下html，就会有一个小窗，选html:5</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html1-3.png"></p><p>然后就可以快速得到一个html的框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们对这个框架里面的内容稍做解释</p><ol><li><code>&lt;!DOCTYPE html&gt;</code>负责告诉浏览器文档的标准:HTML/XML</li><li><code>lang=&quot;en&quot;</code>，用于指定页面的语言类型</li><li><code>&lt;head&gt;</code>头标签里面表示页面的配置</li><li><code>&lt;meta&gt;</code>表示元配置，即页面的基本配置</li><li><code>&lt;body&gt;</code>表示网页的主体</li></ol><h2 id="元素与属性"><a href="#元素与属性" class="headerlink" title="元素与属性"></a>元素与属性</h2><p>在生成的框架中，可以看到html的标签基本上是成对出现的，比如<code>&lt;title&gt;&lt;/title&gt;</code>，夹在中间的就是这个标签类型的元素，标签在html中的作用就是<strong>定义语义</strong></p><p>而不成对出现的元素称为空元素，比如<code>&lt;img&gt;</code></p><p>HTML中元素是可以嵌套的，但是嵌套必须是<strong>有序</strong>的，必须是包含的</p><p>比如以下例子就是错误的</p><div class="note warning no-icon flat"><p>&lt;p&gt;小鸡腿儿最&lt;strong&gt;可爱&lt;/p&gt;&lt;/strong&gt;</p></div><p>HTML中有两个重要的元素概念：块级元素和内联元素，块级元素比如<code>&lt;p&gt;&lt;/p&gt;</code>，会把内容挤到下一行，而内联元素比如<code>&lt;span&gt;&lt;/span&gt;</code>，内容会在同一行展现</p><p>而HTML中的元素是可以赋予<strong>属性</strong>的，属性为元素赋予额外信息，举个例子</p><div class="note info no-icon flat"><p>&lt;p style=”font-size:20px;color:red”&gt;小鸡腿儿最可爱&lt;/p&gt;</p></div><p>效果如下</p><p style="font-size:20px; color:red">小鸡腿儿最可爱</p><p>style是一种属性，里面的写法和css是相同的，但是元素可以附加不止一种属性，但是属性之间要用空格隔开，比如我们在<code>&lt;a&gt;</code>标签的元素里再加入链接href</p><div class="note info no-icon flat"><p>&lt;a style=”font-size:15px; color:red” href=”cicily96.gitee.io”&gt;小鸡腿儿最可爱&lt;/a&gt;</p></div><p>就可以得到一个链接</p><p><a style="font-size:15px; color:red" href="https://cicily96.gitee.io">小鸡腿儿最可爱</a></p><h2 id="注释与特殊字符"><a href="#注释与特殊字符" class="headerlink" title="注释与特殊字符"></a>注释与特殊字符</h2><p>html中注释的写法是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;p&gt;这是注释&lt;/p&gt; --&gt;</span></span><br></pre></td></tr></table></figure><p>在html中还有一些特殊的符号，因为在html中本身具有作用，所以不能够直接写出来，需要用一些特殊的符号代替</p><table><thead><tr><th>原义字符</th><th>等价字符引用</th></tr></thead><tbody><tr><td>&lt;</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;gt;</code></td></tr><tr><td>“</td><td><code>&amp;quot;</code></td></tr><tr><td>‘</td><td><code>&amp;apos;</code></td></tr><tr><td>&amp;</td><td><code>&amp;amp;</code></td></tr></tbody></table><h2 id="头标签-lt-head-gt"><a href="#头标签-lt-head-gt" class="headerlink" title="头标签&lt;head&gt;"></a>头标签<code>&lt;head&gt;</code></h2><p>头标签一些重要的常用元素有</p><div class="tip bell"><ol><li>title：网页的标题，显示在浏览器标签上</li><li>meta：提供页面的基本信息</li><li>base：为页面所有链接定义默认地址</li><li>link：定义文档与外部资源的关系</li></ol></div><div class="tag link"><a class="link-card" title="meta标签" href="https://www.runoob.com/tags/tag-meta.html"><div class="left"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://static.runoob.com/images/favicon.ico"/></div><div class="right"><p class="text">meta标签</p><p class="url">https://www.runoob.com/tags/tag-meta.html</p></div></a></div><p>link的使用这里以css文件的引入为例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>rel=”stylesheet”表明这是文档的样式表</p><div class="tip success"><p>记录完毕</p></div><details cyan open><summary> 小鸡腿儿的HTML文章 </summary>              <div class='content'>              <div class="site-card-group"><a class="site-card" href="https://cicily96.gitee.io/2020/12/02/W3school-Learning2/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html1-2.png"/></div><div class="info"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://cicily96.gitee.io/img/friend_404.gif"/><span class="title">Cicily</span><span class="desc">HTML学习记录1</span></div></a><a class="site-card" href="https://cicily96.gitee.io/2020/12/03/W3school-Learning3/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html1-4.png"/></div><div class="info"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://cicily96.gitee.io/img/friend_404.gif"/><span class="title">Cicily</span><span class="desc">HTML学习记录2</span></div></a><a class="site-card" href="https://cicily96.gitee.io/2020/12/04/W3school-Learning4/"><div class="img"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/html1-5.png"/></div><div class="info"><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://cicily96.gitee.io/img/friend_404.gif"/><span class="title">Cicily</span><span class="desc">HTML学习记录3</span></div></a></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 🍰HTML点心铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Space-Reclaiming Icicle Plots：空间回收冰柱图</title>
      <link href="2020/12/07/spaceReclaimingIciclePlots/"/>
      <url>2020/12/07/spaceReclaimingIciclePlots/</url>
      
        <content type="html"><![CDATA[<div class="tip bell"><p>IEEE引用格式：H. Van De Wetering, N. Klaassen, and M. Burch, “Space-Reclaiming Icicle Plots,” IEEE Pacific Vis. Symp., vol. 2020-June, pp. 121–130, 2020, doi: 10.1109/PacificVis48177.2020.4908.</p></div><h1 id="文献内容"><a href="#文献内容" class="headerlink" title="文献内容"></a>文献内容</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>提出了空间回收冰柱图，在所有层次结构级别上回收空白空间，以提高层次结构元素的可见性</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>层次结构可视化通常在空间效率和层次结构描绘上存在一个权衡，高空间效率的层次结构无法提供有关结构的清晰视图，而保持结构化的则空间效率低</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="符合设计原则"><a href="#符合设计原则" class="headerlink" title="符合设计原则"></a>符合设计原则</h3><ul><li>从上到下的布局<br>  从根到底部的视觉跟踪简单而直观</li><li>堆叠原理<br>  堆叠结构清楚反应父子关系</li><li>结构清晰<br>  轻松了解分支，深度和子层次结构大小</li><li>空间效率高<br>  使用百分比参数回收丢失的空间</li><li>无重叠</li><li>子层次可选择</li></ul><h3 id="主要设计思想"><a href="#主要设计思想" class="headerlink" title="主要设计思想"></a>主要设计思想</h3><p>冰柱图子树垂直结束时，叶下垂直空间不能回收，形成损失空间，因此引入空间回收参数，同时，允许用户交互式调整</p><h3 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spaceReclaiminglciclePlots-2.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spaceReclaiminglciclePlots-3.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spaceReclaiminglciclePlots-4.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/spaceReclaiminglciclePlots-5.png"></p><p>等要用冰柱图相关内容时再回过头来看</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><ul><li>H1：层次结构大小的增加会导致响应时间更长</li><li>H2：空间回收较少，即σ较高，其响应时间较短</li><li>H3：层次越大，σ值之间的响应时间差就越大</li><li>H4：回收的空间越多，对情节的判断就越具有审美吸引力</li></ul><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><ul><li>T1：查找具有最大分支因子的节点</li><li>T2：查找具有至少10个节点且其根位置尽可能低的子树</li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>任务正确率都超过90%</p><p>H1通过，H2，H3，H4都不对</p><h1 id="阅读体会"><a href="#阅读体会" class="headerlink" title="阅读体会"></a>阅读体会</h1><p>文章提出了一个很有趣的观点，回收冰柱图中的空白区域来补充到其它的数据上让数据呈现变得更饱满</p><p>不过实验部分缺少与其它算法的对比(可能也是因为没有类似的)</p><p>空白区域的回收，感觉其它类型的图中能做类似事情的好像非常少，文中提到可以考虑其它类型的冰柱图，比如Sunburst plots</p><div class="btns rounded grid5">            <a class="button" href='https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9086292' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> PacificVis </tag>
            
            <tag> 树可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uncertainty Treemaps：可视化数据不确定性</title>
      <link href="2020/12/03/uncertaintyTreemaps/"/>
      <url>2020/12/03/uncertaintyTreemaps/</url>
      
        <content type="html"><![CDATA[<div class="tip bell"><p>IEEE引用格式：M. Sondag, W. Meulemans, C. Schulz, K. Verbeek, D. Weiskopf, and B. Speckmann, “Uncertainty Treemaps,” IEEE Pacific Vis. Symp., vol. 2020-June, pp. 111–120, 2020, doi: 10.1109/PacificVis48177.2020.7614.</p></div><h1 id="文献内容"><a href="#文献内容" class="headerlink" title="文献内容"></a>文献内容</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>研究了如何在Treemap中可视化分层数据和其相关的不确定性</p><p>提出了两个相互矛盾的关键要求</p><ol><li>视觉聚合：矩框大小需要和值匹配</li><li>用区域编码不确定度：用相同视觉变量对不确定度编码，方便与数据的比较</li></ol><p>通过使用不确定性遮罩在数据相同的空间可视化不确定性，同时满足两个要求，维持了Treemap的严格递归性质</p><p>还提出了一种遮盖的质量度量，用于指导Treemaps的布局算法修改</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-1.png"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数值数据通常会有与每个数据值相关的不确定性，支持对复杂数据类型和不确定数据同时可视化的技术很少</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ol><li>coffee：1994年至2014年每个国家/地区的咖啡平均进口量以及相关的标准差</li><li>Infant：1992年至2016年每个国家的婴儿平均死亡人数及相关的标准差</li><li>S&amp;P：2016年3月11日至2016年11月10日，标准普尔500指数中每只股票的平均收盘价及相关的标准差</li><li>CES：2014年每户（消费者）的平均支出； 标准偏差代表测量不确定度</li></ol><h3 id="遮罩设计"><a href="#遮罩设计" class="headerlink" title="遮罩设计"></a>遮罩设计</h3><p>叶级以上的节点逐层线宽和间距加倍，最右图显示了一个具有四个节点的二级Treemap</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-2.png"></p><p>遮罩质量示例，最为正确的嵌套是较低级别的遮罩延伸到较高级别的遮罩之外</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-3.png"></p><p>遮罩渲染方式对比实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-6.png"></p><h3 id="不确定树图算法"><a href="#不确定树图算法" class="headerlink" title="不确定树图算法"></a>不确定树图算法</h3><p>作者采用两类方法提升树图算法生成的树图质量</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Mask-Friendly Algorithms</button></li><li class="tab"><button type="button" data-href="#test-2">Mask-Aware Algorithms</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>将面积较小的子节点放置在底部的树图会导致质量较低的遮盖</p><p>对给定树图水平或垂直镜像会影响遮盖的质量，因此可以用镜像方式对质量进行优化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>采用遮盖质量度量在树映射的算法中进行启发式选择</p><p>用MASKAWARESPLIT过程替代APPROXIMATIONSPLIT过程</p><ul><li>优先垂直分割</li><li>采用简单布局来估算mask质量</li><li>使水平分割的总不确定度尽可能相等</li></ul><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/uncertaintyTreemaps-5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="专家意见"><a href="#专家意见" class="headerlink" title="专家意见"></a>专家意见</h3><p>Uncertainty Treemaps比气泡树图和并置变体更可取</p><h1 id="阅读体会"><a href="#阅读体会" class="headerlink" title="阅读体会"></a>阅读体会</h1><p>文章的主要内容是在Treemap中引入遮盖来代表不确定度，对遮盖的质量提出度量并通过该度量来指导treemap的算法优化</p><p>一些问题，对于度量的提出，作者并没有做实验和调研，对遮盖的清晰度的衡量比较主观，这里插入一个RCT会更合理</p><p>有一点小想法，如果可以加入交互微调整，Uncertainty Treemaps的功能会变得更强大，就比如用户可以手动调整大的矩阵块来提升Treemap质量，小的矩阵块会根据大的块自动调整位置</p><div class="btns rounded grid5">            <a class="button" href='https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9086235' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a><a class="button" href='https://github.com/tue-alga/UncertaintyTreemaps' title='下载源码'><i class='fas fa-download'></i>下载源码</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> PacificVis </tag>
            
            <tag> 树可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeEvo：祖先的特征是如何影响几代人的家谱的</title>
      <link href="2020/12/01/treeEvo/"/>
      <url>2020/12/01/treeEvo/</url>
      
        <content type="html"><![CDATA[<div class="tip bell"><p>IEEE引用格式：S. Fu, H. Dong, W. Cui, J. Zhao, and H. Qu, “How Do Ancestral Traits Shape Family Trees over Generations?,” IEEE Trans. Vis. Comput. Graph., vol. 24, no. 1, pp. 205–214, 2018, doi: 10.1109/TVCG.2017.2744080.</p></div><h1 id="文献内容"><a href="#文献内容" class="headerlink" title="文献内容"></a>文献内容</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>提出了一项设计研究，研究探讨了后代的生活史特征，男性创始人社会经济地位与家谱结构之间的关系</p><ol><li>描述人口统计学领域的任务，帮助专家确定位置结构特征 </li><li>设计和开发了可视化分析系统TreeEvo，用于假设生成和关联的验证</li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>两代分析在研究和评估过程中比较简单，但是扩展到多代过程极具挑战性</p><ol><li>人们对于多代人的社会经济和人口发展过程的先验知识有限，而错误的假设会在研究设计和统计估计中引入偏差，因此亟需视觉分析工具，基于新可用数据来生成和验证/拒绝假设</li><li>社会科学中大多数统计工具(SPSS，STATA，R)在可视化分析中受限(图形选项有限，需要高级编程技能)，阻碍专家理解和处理分层数据结构</li><li>已有工具很少利用多代数据以及整个家谱集合中的结构信息来帮助发现重要信息</li></ol><h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><h3 id="专家方面"><a href="#专家方面" class="headerlink" title="专家方面"></a>专家方面</h3><p>六位领域专家</p><ol><li>一位人口统计专家 (本文共同作者)</li><li>一名教授 (历史人口和社会学领域) 和四名研究生</li></ol><p>设计分三阶段，每个阶段包括所有专家一次正式面谈和内部专家的几次非正式面谈</p><div class="tip key"><ol><li>确定多代分析中的重要研究问题并得出可视化的分析任务</li><li>根据专家的反馈对TreeEvo进行迭代开发</li><li>组织与不同专家的访谈，评估TreeEvo的有效性和实用性</li></ol></div><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>CMGPD-LN</p><p>根据清朝（1644-1912）政府在1749年至1909年间在中国辽宁省编制的三年期户口簿抄录的。该数据集包含超过260万个人的150万条记录</p><h3 id="确定领域研究问题"><a href="#确定领域研究问题" class="headerlink" title="确定领域研究问题"></a>确定领域研究问题</h3><p>先简单可视化树集合，在集合面板用MDS布局显示族树集合(a)，每个点代表一棵树，并且两个点彼此靠近意味着两个家族在位置，人口和世代数三个方面相似。 借助过滤(b)，专家们可以选择感兴趣的家谱。选择族后，将显示族树的详细信息(c)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/treeEvo-2.png"></p><p>在早期模型中专家提出了一些原型无法回答的问题，比如<span class='p red'>家族树结构和男性创始人特征之间的关系</span></p><h3 id="分析工作流程"><a href="#分析工作流程" class="headerlink" title="分析工作流程"></a>分析工作流程</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>Data Cleaning</p></p></div><div class="body"><p>重心放在仅由一个男性祖先和他的男性后代组成的家谱上</p></div></div><div class="timenode"><div class="meta"><p><p>Hypothesis Generation</p></p></div><div class="body"><p>家谱的倾向与男性创始人的个人特征之间存在关联</p></div></div><div class="timenode"><div class="meta"><p><p>Variable Definition</p></p></div><div class="body"><p>世代数，男性成员数和倾斜度</p><p>倾斜度测量方法是专家新定义的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/treeEvo-3.png"></p></div></div><div class="timenode"><div class="meta"><p><p>DataAnalysis</p></p></div><div class="body"><p>采用了Multinomial Logit Model(MLM)</p><p>专家采用STATA来运行MLM，对分析结果进行信息了解通常要生成统计图，但是STATA绘图选项效率低，绘图代价高</p></div></div></div><h3 id="任务分析"><a href="#任务分析" class="headerlink" title="任务分析"></a>任务分析</h3><p>分为两类：</p><ul><li><p>结构识别</p><p>  T1：通过深度或世代数来组织整个家庭树的收集<br>  T2：通过结构特征汇总家庭树<br>  T3：详细介绍家庭树的结构</p></li><li><p>关联分析</p><p>  T4：基于结构特征的灵活分区家庭树<br>  T5：统计多变量分析与MLM的集成</p></li></ul><h2 id="TREEEVO"><a href="#TREEEVO" class="headerlink" title="TREEEVO"></a>TREEEVO</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>采用桑基图(Sankey)，为了支持针对增长和连续性的数据集的探索 (T1)</p><p>但是传统的Sankey图设计存在两种限制</p><ol><li>由Sankey节点表示的元素处于聚合状态，丢失了许多细节，比如家谱的结构分布 (T2不满足)</li><li>传统Sankey图要求事先重新定义这些节点，很难按照要求灵活划分和选择具有各种结构特征的树集合 (T4不满足)</li></ol><p>为了解决限制，重新设计了Sankey节点 (灵感来源于<a href="http://www.cs.umd.edu/hcil/trs/2013-11/2013-11.pdf">Monroe et al</a>)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/treeEvo-4.png"></p><ol><li>将每个家谱树概括成一条像素线 (图a)</li><li>将每条像素线的颜色编码 (图b)</li><li>可以根据结构特征对紧密对齐的像素线进行排序 (图c)</li></ol><p>这样专家能根据结构树来了解家族树集合的分布 (T2)</p><p>并且根据具有灵活性的各种结构特征来划分分区树集合 (T4)</p><h3 id="显示细节"><a href="#显示细节" class="headerlink" title="显示细节"></a>显示细节</h3><p>当用户选择一个或多个Sankey节点时，显示详细信息，每个Sankey节点的详细组成都会在详细信息面板(T3)中以空格填充的形式显示</p><p>Nmap来计算空间填充布局</p><h3 id="使用MLM进行分析-T5"><a href="#使用MLM进行分析-T5" class="headerlink" title="使用MLM进行分析 (T5)"></a>使用MLM进行分析 (T5)</h3><h1 id="阅读体会"><a href="#阅读体会" class="headerlink" title="阅读体会"></a>阅读体会</h1><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/treeEvo-1.png"></p><p>这篇文章可视系统部分基本上就是对Sankey图的一个对于特定使用情况的优化和内容补充，用行来表示相同深度的家族树集(分三组：蓝-左倾斜，白-倾斜，红-右倾斜)，节点对应不同家族树，而对于家族树的结构部分用矩形部分来补充(颜色：倾斜度，区域大小：数量)，只有区域足够大才能显示族树的节点链接结构</p><p>这篇基本的研究思路就是和domain experts一起合作，对设计原型进行迭代，确定任务-初步模型-得到反馈(使用中什么问题没能回答)-迭代更新-使用反馈</p><p>一些缺陷也比较显然，比如这个设计只能处理深度比较小的情况，深度大的话，在矩形区域中很难显示，然后这个对于倾斜度单分组的设计过于specific，当然对于这个研究假设是够的，如果往多条件分组上考虑的话可以怎么做呢？(暂时没想到好的处理方法，先降维？或者做三维的类似桑基图的东西？)</p><div class="btns rounded grid5">            <a class="button" href='https://www.sci-hub.ren/10.1109/tvcg.2017.2744080' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> VIS </tag>
            
            <tag> 树可视化 </tag>
            
            <tag> TVCG </tag>
            
            <tag> InfoVis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BarcodeTree：多层次结构的可伸缩比较</title>
      <link href="2020/11/26/barcodeTree/"/>
      <url>2020/11/26/barcodeTree/</url>
      
        <content type="html"><![CDATA[<div class="tip bell"><p>IEEE引用格式：G. Li et al., “BarcodeTree: Scalable Comparison of Multiple Hierarchies,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 1, pp. 1022–1032, 2020, doi: 10.1109/TVCG.2019.2934535.</p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一种新的可视化技术BarcodeTree(BCT)，用于比较多棵树的拓扑结构和节点属性值。BCT可以同时提供100个浅层且稳定的树的概览，而不需要聚合单个节点。每个BCT使用类似于条形码的样式在单行中显示，允许树垂直堆叠，匹配节点水平排列，以方便比较并保持空间效率。作者设计了一些视觉线索和交互技术来帮助用户理解树的拓扑结构和比较树。在两种BCT与icicle plots的比较实验中，结果表明BCT降低了不同树之间的垂直距离，使树之间的比较更加直观。本文还提供了两个案例研究，涉及数百棵树的数据集，以演示BCT的效用。</p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>数据集有时由许多相似的树(不同地方的图书馆)或随着时间变化的单个树组成(一个网站的网站地图)，这种树集合的可视化概述可以极大地帮助执行比较，识别存在或者不存在的节点或子树，亦或是查找趋势和异常值</p><p>之前的许多文献都是单树可视化，少有树的可视化比较，大多局限于一次可视化两棵树，也有同时展示三棵树或者更多树的可视化，但是结果显示不超过40棵树，随着各种数据源的不断增长，越来越需要可视化更多的树</p><p>本文提出了BarcodeTree(BCT)，用于跨多棵树对拓扑结构和节点属性值进行可伸缩的比较，BCT将每棵树线性化为单行，垂直压缩可视化，便于多棵树的堆叠和匹配节点的对齐，减少了匹配节点之间的距离，本文研究了两种变种，BCTw(宽度编码)和BCTh(高度编码)，它们分别将节点深度编码为矩形的宽度或高度，及节点属性可以用颜色编码，或者(在BCTw的情况下)用矩形的高度编码。为了帮助用户理解拓扑结构，作者还设计了“结构提示”来突出显示光标下节点的后代、祖先和兄弟节点。</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-1.png"></p><p>BCTs的设计是通过使用相对较浅和稳定的树数据集来实现的。所谓“稳定”，指的是有一个预定义的通用树，它是数据集中所有树的超级树，树之间的区别在于它们可能包含超级树中不同的节点子集和属性，每个节点上的值可能会改变。举一些这种树的数据集的例子：</p><ol><li>一个大学图书馆的多日日常借阅记录，书遵循预先定义的分类系统</li><li>多个图书馆的藏书</li><li>不同政府或者同一政府多个部分的长期预算</li><li>电子商务网站产品分类层次随时间增长的层次结构</li></ol><p>作者将两种BCT和<a href="https://scihubtw.tw/10.2307/2685881">icicle plots</a>以及<a href="https://scihubtw.tw/10.1007/978-3-642-17289-2_33">Indented Pixel Tree Plots (IPTP)</a>进行研究比较，在所有研究任务中，花在IPTP上的时间都比icicle plots多，然后进行对照实验，比较BCTw、BCTh和icicle plots，发现BCTs在需要理解单个树拓扑的任务上花费的时间明显更多，而在比较多棵树的任务上花费的时间明显更少</p><p>本文的贡献有：</p><ol><li>BarcodeTree，一种新颖的可视化技术，用于比较多个浅层和稳定树的拓扑结构和节点属性值，可以容纳100棵树，每棵树有数百个节点(但扇出度较小)，在正常屏幕尺寸范围内</li><li>视觉反馈(“结构线索”)帮助用户理解拓扑结构</li><li>一个RCT表明，BCTs可以使树比较任务比与之竞争的可视化技术更容易</li><li>两个涉及图书馆图书数据集的用例来演示BCTs的效用</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="单树可视化"><a href="#单树可视化" class="headerlink" title="单树可视化"></a>单树可视化</h3><p>根据父节点-子节点关系的可视化编码，可以将树可视化分为显式和隐式技术，显式技术用可见的边，线段或弧对这些关系进行编码，隐式技术使用包含(例如，子节点嵌套或封闭在父节点内)或邻接</p><p>大多数显式的树形可视化在2D或3D空间中排列分层数据，而在1D空间中排列节点的研究还不够。<a href="https://scihubtw.tw/10.1109/infvis.2003.1249028">Thread Arc</a>按照时间顺序将树中的节点沿1D行排列，并在节点之间使用圆弧来编码父子关系。然而，在线弧中使用的弧使它很难压缩布局成一个薄条状，这将最终导致堆叠许多树在一起。相反，BCT不使用显式的视觉元素编码父子关系，这增加了堆叠多棵树的空间效率</p><p>在隐式树可视化中，包含编码的一个突出示例是<a href="https://scihubtw.tw/10.1109/visual.1991.175815">treemap</a>，子节点在父节点体内安营扎寨，通过大小来显示节点属性值，而非叶节点的属性值通常是其子节点的和。相比之下，BCTs允许节点的属性值独立于其子节点的值。树状图通常排列为2D或3D。<a href="https://innovis.cpsc.ucalgary.ca/innovis/uploads/Publications/Publications/Neumann_2005_AVR.pdf">ArcTree</a>将分层数据线性化，并将节点排列在单行中，这可以看作是一个“一维”树图</p><p>邻接编码，比如冰柱图(icicle plots)，是显式编码和包含编码之间的折中，与显式编码相比，使用邻接不显示节点之间的显式边缘，从而节省了空间，与树状图等包含编码相比，使用邻接并不那么节省空间，但使树的不同层次更容易区分，冰柱图显示了垂直邻接的父子关系:子节点位于父节点之下。树的每一层都是一行，而整棵树占据几行。虽然可以将多个冰柱图垂直堆叠起来进行树的比较，但BCTs比冰柱图需要更少的垂直空间。这样BCTs就减少了不同树的匹配节点之间的距离。</p><p>BCTs可以理解为另一种邻接编码。它以深度优先遍历的顺序将树的节点映射到双杠上。每个父节点既不包含子节点，也没有到子节点的显式链接，但是用户仍然可以识别底层的拓扑结构。这类似于缩进轮廓的布局(在许多文件浏览器中使用)和缩进像素树图(IPTP)，这两种布局都按照深度优先遍历的顺序定位节点。缩进大纲布局很适合显示带有文本标签的节点。为了使用户能够阅读这些文本标签，缩进大纲总是将节点垂直排列而不是水平排列。如果从节点中删除文本标签，压缩并旋转90度，就可以得到一个类似于BCTh的布局，使其适合将多个树堆叠在一起。IPTP为树的每一层分配单独的行，就像icicle plots一样，因此这两种布局的垂直压缩程度都不如BCTs</p><h3 id="树的可视化比较"><a href="#树的可视化比较" class="headerlink" title="树的可视化比较"></a>树的可视化比较</h3><p>比较是数据分析中必不可少的一项工作。有一系列技术可以用于可视化地比较树，本文将其细分为:并置(juxtaposition)、合并视图(merged views)和原子(atomic representations)表示。</p><p>并置是最普遍的策略，可以在空间或时间上进行。空间并置可以通过节点-链接表示，径向表示法和树状图来实现。这种并排视图可以通过刷屏、链接和动态查询来利用交互，交互式地突出显示其他树的相应节点。但是，如果没有交互，就很难理解许多节点突出显示的差异，这使得它无法向用户提供跨多颗树的许多更改的概览。此外，因为以前工作中的表示没有像BCTs中那样垂直压缩(也就是说，它们没有压缩)，这些先前的技术无法扩展树的数量。之前的作品也将冰柱图并列比较。其中一些将两个冰柱图邻接排列，并用边连接匹配的叶节点。通过镜像冰柱图，代码流允许用户比较两棵以上的树。明确绘制的链接提供了拓扑结构差异的概述，但也占用了很大的空间，再次阻止了该技术一次容纳数量超过“少量的树”。<a href="https://scihubtw.tw/10.3897/bdj.4.e9787">Taxonaut</a>将多个缩进轮廓水平并置，并使用联合树对它们进行对齐，但它的可伸缩性仍然不尽如人意，因为每个缩进的大纲需要占用几列。一些研究使用弯曲波段在树中连接匹配节点，但代价是将单个节点“模糊在一起”。时间并置，例如<a href="https://wenku.baidu.com/view/e0f076d86f1aff00bed51ee0.html">时间树</a>，使用动画在不同的树之间转换，这种策略也不能很好地适用于大量的树木。用户记住帧之间变化的能力有限，因此必须多次查看动画</p><p>之前的一些作品建议将多棵树合并到一个单一的视觉表现中，以提高空间效率。<a href="https://scihubtw.tw/10.1145/1879211.1879238">Beck et al</a>提出了一种依赖结构矩阵，该矩阵沿邻接矩阵的每边排列一个冰柱图，矩阵中的每个单元编码节点的差异。这种方法一次只能容纳两棵树，矩阵只显示叶子节点比较的结果。<a href="https://scihubtw.tw/10.1109/tvcg.2007.70556">Graham et al</a>通过将一些树合并成一个有向无环图(DAG)表示来探索这些树。与联合树相比，DAG允许显示一个节点的多个祖先路径。合并的视图需要显示多个树之间的差异。然而，多个树的关系是复杂的，尤其是在处理大量树时，而且在一个合并视图中显示这些结果也很困难</p><p>对于数量足够大的树，有限的屏幕空间无法显示所有树的全部细节，因此开发了将树可视化为原子表示的技术。之前的工作将每棵树可视化为散点图中的单个点，以支持对大量树的比较。两点之间的距离表示关联树之间的相似程度。<a href="https://scihubtw.tw/10.1109/tvcg.2017.2744080">TreeEvo</a>主要关注家谱的结构异质性。它使用像素线可视化每个家族树，并将它们分组到Sankey图的节点中。关系的显式表示只显示来自高级概述的比较结果，但不能提供拓扑结构和节点属性值的详细比较。</p><p>尽管之前在树的比较方面做了大量的工作，但据我们所知，之前的方法还不能同时完整地显示100棵树，即在一个典型的PC屏幕上同时显示所有单个节点、拓扑结构和节点属性值。这是BCT的一个独特的特点</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>本文寻求一种技术来比较多个浅层和稳定的树，这种技术比以前的技术更具可扩展性。首先考虑以前关于树比较的文献，以确定支持哪些任务。<a href="http://www.cs.umd.edu/hcil/trs/2012-14/2012-14.pdf">Guerra-G’omez et al</a>确定了五种树形比较</p><ol><li>比较节点没有属性值时的拓扑差异</li><li>比较拓扑结构没有变化的叶节点的属性值</li><li>比较拓扑结构没有变化的所有节点的属性值</li><li>比较叶节点的属性值与拓扑结构的变化</li><li>比较拓扑变化时所有节点的属性值</li></ol><p>Munzner等人指出，结构比较是通过将一棵树上的每个节点与另一棵树上对应的节点相关联来实现的，除了比较任务，Chi等人还为多树探索确定了全局和局部任务，全局任务指的是比较多个树以发现趋势/模式。本地任务指查找有关拓扑或节点属性的特定信息。本文设法支持上述所有类型的任务。可以考虑的一些与树相关的附加任务是编辑树的方法(例如，移动节点或子树)，但是这样的编辑任务超出了本文的范围，因为本文寻求可视化数据</p><p>因此，本文对新布局的需求来自三个主要需求。为了支持Guerra-G’omez的五个任务，需要一种技术，以一种能够实现高效比较的方式显示拓扑和节点属性，为了支持全局任务，该技术应该显示尽可能多的树，同时还应该显示每棵树中尽可能多的单个节点。为支持本地任务提供每个树的拓扑结构的清晰描述也是可取的。然而，与容纳许多树和许多节点相比，清晰的拓扑结构不那么重要。这是因为用户总是可以从使用新布局的许多树的概览开始，比较多个树并发现趋势或异常值，然后再向下钻取到一个或几个树，这些树使用更传统的布局来更清楚地显示拓扑。</p><p>以下是本文具体的设计要求。R1和R2解决全局任务的需要，R3和R4支持Guerra-G’omez等人确定的五种比较，R5支持本地任务</p><details ><summary> R1：在一个屏幕中显示许多树 </summary>              <div class='content'>              <p>在一个典型的显示空间中提供概述对于比较多个树是非常重要的，这也是树比较的许多使用场景的需求之一</p>              </div>            </details><details cyan><summary> R2：表示每棵树中的多个节点 </summary>              <div class='content'>              <p>可视化应该显示每个树中的单个节点。在用户仍在查看多树数据集的概述时提供这种细粒度的信息，减少了用户向下钻取更详细视图的需要</p>              </div>            </details><details green><summary> R3：为每个节点显示一个定量属性 </summary>              <div class='content'>              <p>对每个节点的属性值进行编码，以便能够跨树比较节点值，从而揭示趋势和异常值。</p>              </div>            </details><details yellow><summary> R4：便于在许多树中比较节点的存在/不存在或属性值 </summary>              <div class='content'>              <p>在多棵树中找到匹配的节点、比较它们的属性值以及比较不同树中节点的存在与否应该很容易</p>              </div>            </details><details red><summary> R5：显示每棵树中的拓扑(父-子)关系 </summary>              <div class='content'>              <p>它应该有可能辨别树数据的拓扑结构。最后列出这一要求是为了表明，如果为了提高空间效率而牺牲一些对父子关系清晰度的牺牲是可以接受的(R1,R2)</p>              </div>            </details><h2 id="BarcodeTree设计"><a href="#BarcodeTree设计" class="headerlink" title="BarcodeTree设计"></a>BarcodeTree设计</h2><p>根据以上的设计要求，本文提出了BarcodeTree，BCT是一种比较多棵树之间拓扑结构和节点属性值的树形可视化方法。在本节中，将介绍BCT的可视化设计，然后提出交互技术来帮助用户理解底层的层次数据</p><h3 id="视觉编码设计"><a href="#视觉编码设计" class="headerlink" title="视觉编码设计"></a>视觉编码设计</h3><p>为了实现树和节点数量的可扩展性，作者研究了多棵树到垂直和水平位置的映射拓扑。具体来说，BCT将每棵树可视化在单行中，以最小化其垂直范围，从而最大限度地增加可以垂直堆叠的树的数量(R1)，BCT还在每行中水平地打包节点。父子关系以一种节省空间的方式编码到相对位置，以最大化可以水平打包的节点数量(R2)</p><p>BCT将每个节点表示为一个矩形，可以非常有效地呈现，这意味着可以以交互帧速率呈现大量节点(R1，R2)，矩形的视觉通道(宽度，高度，颜色)可以编码节点深度和节点属性值(R3)，将节点深度映射到矩形宽度产生BCTw。具体来说，根节点的宽度最大，深度越深的节点的宽度越小。BCTw中相邻节点的宽度差是相同的。将节点深度映射到矩形高度会产生BCTh，这使得用户更容易地感知每个节点的深度。在大量树的可视化结果中，每个节点只占用很小的空间以适应屏幕空间。具体来说，每个节点的宽度和高度都很小。较小的长度可以编码节点深度，因为目标层次化数据相对较浅。然而，节点属性值具有较高的动态范围。因此节点属性值只能编码为节点颜色，而不受节点大小的限制。将节点属性值编码到颜色通道中无法支持精确的比较。其余视觉通道(高度BCTw和宽度的BCTh)在某些情况下可以重复编码属性值作为补充。但是，将属性值编码到BCTh的节点宽度中，会导致对齐后节点之间的间隙增大，从而降低空间利用效率。因此，这种设计被排除。</p><p>BCTs使用预先排序的深度优先遍历来确定水平节点的位置，它对父-子关系进行编码。根据第一次遍历时间的顺序，将层次结构中的节点从左到右添加到布局中。每个节点的后代被放置在节点的右侧。用户可以通过扫描N的右侧找到节点N的后代，直到遇到与N宽度或高度相同的另一个节点，这取决于使用的BCT的变体。因此，BCT允许用户解释树的拓扑结构(R5)，由于它的紧凑性，BCT可以嵌入到单行文本中，就像火花线一样。例如，<img no-lazy class="inline" src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-2.png" style="height:1.5em"/>表示具有11个节点和4个级别的树。</p><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><p>为了帮助用户理解和导航分层数据，本文为BCTs设计了三种交互技术。下面以BCTw作为一个例子来说明交互技术和这些设计也可以应用到BCTh</p><p><strong>结构线索突出</strong>，尽管用户可以分辨出BCTs中的拓扑，但这个过程可能很繁琐，需要用户顺序地扫描节点。为了帮助理解(R5)，本文添加了交互式结构线索。下图显示了如何使用下划线或标记来表示光标下节点的祖先、子节点和兄弟节点</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-3.png"></p><p>为了表示后代，首先使用单个水平笔画(图a)。然而，发现分析人员仍然难以理解后代的特征，如子树的数量或平衡。因此，团队开发了图b中的变体，其中每个子树都用单独的水平笔画表示。笔画的数量和长度表示子树的数量和大小，便于判断树是否平衡</p><p><strong>压缩与对角线条纹符号</strong>，对于具有数万个节点的树，BCTs表示可能非常宽，很难在屏幕中容纳。在探索大型层次数据时，用户通常只对少数子树感兴趣，其他部分会分散他们的注意力。如果几个感兴趣的子树不能在相同的屏幕空间中显示，用户需要水平地来回滚动以在这些子树之间导航。为了方便这种探索，用户可以选择感兴趣的子树，然后将每个连续的无兴趣区域聚合为对角条纹符号</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-4.png"></p><p><strong>折叠/展开节点</strong>，当一个分支中的节点不能在屏幕中显示时，它将阻碍用户的导航。本文提供了折叠/扩展交互，以最大限度地利用BCT可视化表示进行交互可视化，图中显示随着用户细化他们感兴趣的焦点而逐步打开分支的情况。压缩分支用等腰三角形预览。预览图标在压缩分支的根节点下面</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-5.png"></p><p>三角形符号的视觉编码类似于Space-树，三角形底的宽度编码为平均宽度(项目数除以深度)。高度编码子树的深度。暗度编码子树的节点总数。即使是折叠的子树，用户仍然可以从三角形符号中获得概览信息，甚至可以对整个子树进行粗略的比较。单击节点可以打开折叠的分支</p><h3 id="对齐比较法"><a href="#对齐比较法" class="headerlink" title="对齐比较法"></a>对齐比较法</h3><p>为了比较多棵树之间的拓扑结构和节点属性值，本文提出了一种包含两个步骤的比对方法。第一步是垂直地并置多个树，第二步是水平地对齐BCTs。还介绍了对齐结果和排序交互的可视化编码</p><p><strong>水平对齐</strong>，本文的方法对多个树进行对齐，并将匹配节点映射到相同的水平位置，以帮助用户比较它们的拓扑结构(R4)。本文的对齐方法构造了一个联合树，将多棵树合并成一棵树(见下图算法)，然后用BCT对并集树进行可视化，得到并集BCT，并将每棵树中的节点映射到它们在并集BCT中的匹配节点的位置。并联BCT作为节点的一种超集，由多个节点组成。构造union BCT是一个自顶向下的递归过程。每次迭代合并所有匹配的子节点(及其子树)，然后追加未匹配的子节点。映射策略确定每个节点的位置，允许在垂直叠加多棵树后将匹配节点放置在同一水平位置</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-6.png"></p><p>由于对齐结果将多棵树的节点合并，因此对齐结果的宽度大于单个BCT。本文方法支持交互式地对齐一个节点子集，并将其他节点按原始BCT顺序排列，这减少了比较结果的宽度。本文方法提供了两种对齐策略，即对齐感兴趣的子树和将树对齐到某个级别。</p><p>图a显示了三个原始BCTs。本文方法通过根据是否需要对齐将BCTs划分为段来对齐感兴趣的子树。每个分区段包含一个子树，然后计算每个分段的最大长度，并首先对它们进行对齐。然后，本文方法分别计算每个片段中节点的布局。如图6(b)所示，对于未对齐的片段，基于BCT布局算法对节点进行布局。对于对齐后的节点，采用基于并集的对齐比较算法进行节点布局</p><p>为了将BCTs对齐到一定的级别，如图c所示，首先构建该级别以上节点的联合树，然后计算这些树的叶节点之间的后代节点的最大长度。然后将联合树的节点放置并保留空白空间，空白空间的长度为每个叶节点后面的最大长度。最后，计算节点在相应的空白空间中的对齐层下的位置。</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-7.png"></p><p><strong>视觉编码</strong>，对齐结果将不存在的节点编码为轮廓矩形，用户可以选择节点/子树作为引用，并识别其他树中多余的/缺失的部分。BCT的可视化编码便于用户理解差异。它将缺少的节点映射为红色矩形，将多余的节点映射为绿色矩形，如下图a所示。将节点属性值编码为高度可能很难在不同的树之间进行比较，特别是当它们的差异很小的时候，选择如图(b)所示的方式后，在匹配节点上添加指标，显示节点值的正负变化，指示符的位置与参考节点的节点值相同，其颜色表示正负差异(R4)*</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-8.png"></p><p><strong>排序</strong>，用户可以根据不同的标准交互地对多个BCTs进行排序，首先，用户可以选择感兴趣的子树，并根据节点数或拓扑结构相似性对多棵树进行排序。其次，用户可以选择根据所选节点的值对多棵树进行排序。为了揭示这些树的进化模式，用户可以根据它们的原始特征，例如时间顺序，对它们进行排序</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者进行了一个控制实验来评估两种BCT变种在四种不同任务中的性能</p><h3 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h3><p>本文的目标是评估BCT的两个变种BCTw和BCTh，为了进行实验比较，本文考虑了哪些现有技术还允许多个树沿着垂直(y)轴堆叠，而每个树的节点沿着水平(x)轴打包，更准确地说，是考虑在深度优先遍历过程中，叶节点的x坐标单调增加的计数。这一标准意味着不考虑径向布局技术，以及包含技术，如树状图和嵌套圆</p><p>一个众所周知的沿着轴排列叶节点的技术是冰柱图，经典的节点链接布局技术通过连接带有线段的冰柱图中矩形的中心以及父-子关系也可以做到这一点。但是，与经典的节点链接布局相比，冰柱图中的矩形为标签提供了更多的空间，也更容易用鼠标进行选择。之前的研究曾用冰柱图来比较多棵树，虽然没有对齐</p><p>另一种候选技术是缩进像素树图(IPTP)，每个节点分配一个唯一的x的位置(不仅仅是叶节点),允许堆叠树的匹配节点保持一致和比较，IPTP最初发布的形式以较小的大小呈现叶节点，但是这将阻碍叶节点上的属性显示，因此本文的实现绘制了相同大小的所有节点</p><p>对于每种技术，本文提出了两个问题:每个子节点是否在x轴上重叠其父节点(1)，在y轴上重叠其父节点(2)，对于冰柱图，这些问题的答案是(yes, no)，也就是说，在x轴上有重叠，但在y轴上没有，在BCT中，答案是(no，yes)。对于IPTP，答案是(no，no)，这两个问题中的每一个都提供了一种折衷，重叠节省了空间，但可能使区分节点更加困难。因此，最终选择对四种技术做出研究：BCTw, BCTh, ICICLE, IPTP</p><h3 id="分析技术和假设"><a href="#分析技术和假设" class="headerlink" title="分析技术和假设"></a>分析技术和假设</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-9.png"></p><p>表中根据几个标准比较了这四种技术，第三行是关于垂直空间的要求。如果假设所有的技术都显示相同大小的叶节点，那么很明显，BCTh尤其是BCTw比其他技术节省了垂直空间，允许不同的树更紧密地堆叠在一起。第四行是关于节点的大小:冰柱导致更大的非叶节点，使它们更容易用鼠标选择，表中的最后两行是灰色的，因为本文的答案是试验性的和假设的，最后第二行表示哪种技术最擅长传递树的结构: 本文怀疑BCTh，尤其是BCTw在这里会受到影响</p><p>最后一行涉及多个树的比较。本文怀疑ICICLE不支持对不同树中的匹配节点进行简单的比较，因为匹配节点之间的间隔空间被其他节点填满，阻碍了寻找匹配节点。然而，IPTP为每个节点分配唯一的x位置，由于没有中间节点，便于比较不同树中的匹配节点。两种BCT技术也都为每个节点分配唯一的x位置，并且允许不同的树之间离的更近，使得比较更容易</p><p>表中的最后两行是本文试图通过实验来研究的。目的是确认BCT确实在比较匹配节点方面更好，并测试其他技术是否在帮助用户理解树的结构方面更好。本文提出以下假设:</p><ol><li>H1: 对于需要理解结构的任务，相比于ICICLE或IPTP，BCT需要更多的时间和/或导致更高的错误率 </li><li>H2: 对于需要比较多棵树的任务，BCT比ICICLE或IPTP需要更少的时间 </li><li>H3: 在需要比较多棵树的任务中，BCT导致的错误率与ICICLE或IPTP相当(即不比ICICLE或IPTP差) </li></ol><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>为了测试前面的假设，设计了四个任务，Task1和Task2需要用户理解单个树的结构，Task3和Task4需要比较多个树</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-10.png"></p><details ><summary> Task1：查找后代节点 </summary>              <div class='content'>              <p>将显示一个树，其中突出显示一个节点N。用户必须找到N的第二个子节点的第二个子节点，然后单击该节点来完成任务</p>              </div>            </details><details cyan><summary> Task2：寻找最近的共同祖先 </summary>              <div class='content'>              <p>将显示一个树，其中突出显示了两个节点N1和N2。用户必须找到N1和N2最近的(最深的)共同祖先，并点击它。如果N1本身是N2的祖先，用户必须单击N1的父节点</p>              </div>            </details><details green><summary> Task3：不滚动的树比较 </summary>              <div class='content'>              <p>在屏幕空间内显示三棵树的对齐结果，垂直堆叠将匹配节点放置在同一水平位置，其中一棵树T1突出显示为“参考树”。用户必须对这两棵树进行比较，以便在其他两棵树中找出哪一棵(称为T2)与参考树T1包含的相同节点最多。用户必须单击T2的标签才能完成任务。请注意，此任务不涉及单击节点，而是单击整个树的标签，而且无论使用何种树布局技术，这些标签的大小总是相同的。</p>              </div>            </details><details yellow><summary> Task4：与滚动的树比较 </summary>              <div class='content'>              <p>这与Task3相同，除了现在有6棵树要比较，而且在屏幕空间内一次只能看到3棵树，需要用户垂直滚动才能比较这些树，滚动是用鼠标滚轮完成的(也就是说，用户不需要点击滚动条来开始滚动)。要完成此任务，用户必须单击5个非引用树之一的标签，以指示哪个与引用树具有最多的相同节点</p>              </div>            </details><p>Task1和Task2的目的是检验假设H1，Task3和Task4度量了在多个树之间比较节点集以测试H2和H3的能力。Task3和Task4被设计用来衡量节省垂直空间的好处，特别是Task4，在Task4中，ICICLE和IPTP需要用户滚动更多的页面</p><p>Task1至4都在其它研究中有相似的内容 (具体文献说明看原文)</p><p>对于所有任务，节点的最大垂直大小始终设置为相同，相邻节点之间的水平间距也相同，此外，在BCTh和冰柱技术中，叶节宽度始终相同。但是在BCTw中叶子节点更薄，因为BCTw要求有薄的叶子节点来允许非叶子节点的宽度范围</p><p>本文的任务不需要用户比较不同节点之间的属性值。这是因为<a href="http://vis.stanford.edu/files/2010-MTurk-CHI.pdf">之前的工作</a>已经研究了用不同通道编码的成对属性的比较。相反，文本感兴趣的是理解使用时的权衡，用BCT了解树结构和比较多棵树</p><h3 id="初步研究"><a href="#初步研究" class="headerlink" title="初步研究"></a>初步研究</h3><p>一项初步研究将所有四种技术(BCTw、BCTh、ICICLE和IPTP)与四名用户和所有四项任务进行了比较。用户来自计算机科学系。试点的目的是验证实验设计是否合适。在试验期间，每个用户花费了1.5个多小时来完成所有任务。试验的主要结果是，在所有任务中，IPTP总是比ICICLE慢。在试点之前，团队怀疑IPTP可以比ICICLE受益，因为在匹配节点之间没有任何节点。然而，在访谈中，用户报告节点占据间隔空间(以冰柱形式)并不妨碍比较;相反，它们提供引用来帮助查找其他树中的匹配节点。根据测量的时间和访谈结果，团队将IPTP从整个实验中移除，让整个实验中的用户在1小时内完成所有任务。</p><h3 id="完整实验"><a href="#完整实验" class="headerlink" title="完整实验"></a>完整实验</h3><p>为了了解BCT的优缺点，本文对BCTw、BCTh和冰柱进行了完整的对比实验</p><div class="timeline"><div class="timenode"><div class="meta"><p><p>参与者和装置</p></p></div><div class="body"><p>21名用户(年龄在25-35岁之间)，来自计算机科学，经济，商业和金融领域，都是右撇子，熟悉层次数据，并对视觉分析任务有经验</p><p>任务在安静的戴尔精密计算机实验室中完成，T5500台式电脑，因特尔Xeon四核处理器，8GB，RAM和NVidia Quadro 2000图形卡驱动，23英寸LCD，1920x1080像素监控，实验平台用node.js和javascript开发</p></div></div><div class="timenode"><div class="meta"><p><p>数据集</p></p></div><div class="body"><p>本文使用算法生成的数据，而不是真实世界的数据，这样可以更容易地控制数据的特征，使将来更容易复制类似的研究(如果需要的话)，并避免使用任何特定的真实世界数据集可能带来的偏差</p><p>除Task4外，实验中生成的树都适合屏幕，不会滚动，深度在2到5之间，每个节点有0到5个子节点，同一组树之间的差异设计节点出现或消失，但不涉及节点从树的一个位置移动到另一个位置</p><p>BCT布局可以通过在对齐结果中复制每个移位的节点来显示节点的位移。然而，实验生成的数据并没有涉及节点位移，原因有二</p><ol><li>为了节省垂直空间，实验中没有一种技术使用显式链接来显示树之间的匹配节点。因此，为了显示节点位移，所有技术使用节点重复是合理的。此外，这四种技术都以相同的深度优先顺序为叶节点分配x坐标。这些相似之处表明，当使用涉及节点位移的数据时，所有的技术都会遇到类似的问题，而为实验生成这样的数据可能只会延长试验时间和/或降低统计能力。</li><li>用于原型定性评估的真实数据集是基于图书馆图书分类的，其中节点从不从一个地方移动到另一个地方。这至少是真实世界中不发生节点位移的一个领域。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>过程</p></p></div><div class="body"><p>每个用户使用三种技术中的每种技术完成所有四项任务。任务按照固定的顺序完成。在每个任务中，用户以平衡的顺序分别经历了这三种技术，从热身试验开始。</p><p>总共有21个用户，4个任务，3个技术，8次重复= 2016次试验</p><p>用户被要求尽可能准确和快速地完成每次试验，并被告知准确性和完成时间同样重要</p></div></div><div class="timenode"><div class="meta"><p><p>实验结果</p></p></div><div class="body"><p>用重复测量方差分析来分析每个任务的速度和错误率</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-11.png"></p><ol><li>任务1中，ICICLE比BCT技术的每一种都要快得多，而两种BCT技术没有明显差异，方差分析发现这些技术的错误率之间没有显著差异</li><li>任务2中，技术有重大影响，冰柱图明显比较快，冰柱图的错误率显著低于BCT</li><li>任务3中，ICICLE比两种BCT技术都要慢得多，且两种BCT技术没有显著差异，错误率也没有显著差异</li><li>任务4中，ICICLE比两种BCT技术都要慢，错误率没有显著差异</li></ol></div></div><div class="timenode"><div class="meta"><p><p>结果讨论</p></p></div><div class="body"><p>鉴于初步研究的结果删除IPTP的考虑，重新表述假设如下：</p><ol><li>Task1和Task2中，BCT技术需要的时间比冰柱多</li><li>对于Task3和Task4，BCT技术需要的时间明显少于ICICLE</li><li>对于Task3和Task4, BCT技术的错误率并不比ICICLE差多少</li></ol><p>所有三个假设都得到了证实</p><p>正如预期的那样，BCT技术完成拓扑解释任务更困难，但是树比较任务更简单</p><p>然后作者提到，Task1和Task2中的点击选择，都是对于节点来说的，移动鼠标光标和单击所需的时间由Fitts定律控制，较小的目标点击需要更多的时间，而ICICLE的非叶节点比BCT要大得多，因此是具备巨大的优势的，所以ICICLE在任务一二中优秀的速度并不奇怪，同时也说明，BCT的拓扑解释能力其实也并不像数据显示的那么糟糕</p><p>BCTh比BCTw速度更快且错误率更低，因为BCTh的设计旨在使每个节点的深度更清晰，然而，这种设计的代价是使BCTh的垂直可压缩性低于BCTw，这也意味着节点属性值只能使用颜色来显示，这比使用高度来表示数量值的效果要差</p></div></div></div><h2 id="定性评估"><a href="#定性评估" class="headerlink" title="定性评估"></a>定性评估</h2><p>本文通过与两位领域专家一起工作确定的两个用例来演示BCT技术的效用</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>本文的评估使用了大学图书馆的借书记录，图书馆经常根据杜威十进制分类法组织图书，这是一种专有的层次系统，树的更深层次对书籍进行分类，并不断改进，根节点包含所有的书籍，其中子节点对应文学，技术，社会，法学等分支，每个叶节点代表最细粒度的图书类别</p><p>数据集包含了两年的借书记录(01/01/2016 31/12/2017)。对于每一天，根据所有借书的Dewey decimal分类法构造一棵树，其中每个节点的属性值等于该节点所属类别的借书数量。数据集包含730棵树，每天一棵</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>本文实现了一个基于BCT技术的原型系统。在这个系统中，顶部的柱状图显示了每天的借书总数(根节点上的属性值)。用户可以在直方图中选择间隔。在条形图的下面，交互式视图支持多重比较这两个部门。还实现了之前提出的交互技术，包括结构提示、对角条纹符号和节点对齐。系统还提供了数据挖掘的辅助功能，包括过滤和排序</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-12.png"></p><h3 id="专家用户"><a href="#专家用户" class="headerlink" title="专家用户"></a>专家用户</h3><p>团队邀请了两位至少有15年经验的大学图书馆员来评估本文的基于BCT的多棵树的比较原型系统。两位专家感兴趣的是通过比较不同时期的借阅记录来优化人力资源配置和图书管理。在对数据集进行研究之前，专家们对原型系统的使用情况进行了简要介绍。下面是在他们的探索中出现的两个用例。第一种情况表明BCTs可以支持比较多棵树的拓扑结构，第二种情况表明<br>BCTs可以支持比较节点属性值</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">用例1：拓扑结构的比较</button></li><li class="tab"><button type="button" data-href="#test-2">用例2：节点属性比较</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>探究了一年中两个学期借书模式的差异</p><p>从总体直方图中，专家们了解到借书的数量是相似的。选择的树被可视化为BCT行，并垂直堆叠以供比较。</p><p>专家们在第二层对子树进行对齐，将匹配节点放置在相同的水平位置。他们发现，第一个时期的语言类别的借书数量比第二个时期的要多得多。然后，专家们将重点放在语言类别上，用对角线条纹符号压缩其他部分，并对齐语言范畴。图底部的探索结果显示了不同的拓扑变化模式</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/barcodeTree-13.png"></p><p>首先，在概述层面，专家们发现，在(a)区间内，学生借阅语言类图书的频率要高于(b)区间内，专家们还注意到，在两个区间内，类英语和古英语的拓扑结构变化都很小。具体来说，这类借阅记录几乎每天都有。但是，区间(a)中的语言和希腊语言这两类语言的借用模式与区间(b)中的借用模式有很大的不同。此外，专家们继续比较不同时期的借记所构建的拓扑结构。专家们发现学生们在周末通常不借阅语言范畴的书，在区间(b)的语言分类下，他们发现学生通常在周一借书</p><p>在查阅了大学手册后，专家们发现许多国际学生的基础课程都在第一学期。因此，与语言类相关的书籍在第一学期更受欢迎。从详细的借阅记录中，专家们还发现，国际学生借阅语言类图书最多。有了这个发现，图书管理员可以将语言类别下的图书位置更改到更方便的位置，并增加更多的管理员和志愿者来帮助留学生找到这些书</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>探讨了学生学期借用行为与假期借用行为的差异</p><p>专家们希望找到不同类别的节点属性变化规律，首先梳理了两个学期的概览直方图、区间，然后，专家们从比较结果概述开始探索</p><p>原型系统根据该类别下的借阅记录数量与借阅记录总数的比率提供过滤交互。由于专家希望探索最常借用的类别，他们将比率设置在0:35到0:95之间</p><p>可视化结果显示，在区间(c)中，社会科学与技术几乎每天都有大量的图书借阅(cs和ct)。在(a)区间，专家们发现社会科学类(as)的借阅记录数量呈上升趋势。具体来说，一开始会过滤掉更少的节点，然后随着时间的推移会出现更多的节点。但科技类借用纪录(at)保持稳定。在区间(b)期间，社会科学类的借书记录数量较多，而技术类的借书记录数量较少。此外，专家还发现中间出现两次异常增长。</p><p>手册上指出，大学提供了许多选修科目在间隔(b)从不同的系。学生需要选择感兴趣的课程并计入学分。然后，专家们调查了社会科学与技术相关课程的详细信息。社会科学有17门课，其中11门课在课堂上讲授。然而，与技术相关的学生在课堂上只有5门课程，其他16门课程涉及到行业实践和实习。在大学里只有需要上课的课程需要学生从图书馆借书。这样一来，学生更有可能选择社会科学相关的课程，而不是技术相关的课程。如上所述，(a)和(b)间隔的课程安排有很大差异，但(a)和(c)间隔的课程在社会科学与技术之间没有显著差异</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="专家反馈"><a href="#专家反馈" class="headerlink" title="专家反馈"></a>专家反馈</h3><p>团队与这两位领域专家进行了45分钟的一对一访谈，以收集关于技术的反馈。团队请专家使用原型自行探索。在这个过程中，回答他们的问题，并记录他们的评论和喜好。两位专家都表达了对使用BCT的热情。“BCT技术一开始有点难以理解，但它很容易学习和使用” (E1)，“它提供了交互式工具，帮助我充分自信地探索数据” (E2)。E1和E2也证实了本文的搜索策略和交互建议可以帮助他们识别变异模式。E2是图书馆的一名技术人员，他认为BCT技术是节省空间的好方法，可以使多棵树垂直堆放。“具有交互式辅助工具的原型系统可以帮助决策者预测、准备和跟踪未来行为” (E1)，他们一致认为BCT技术可以很容易地应用于其他涉及多个树的分析任务</p><h2 id="结论与未来方向"><a href="#结论与未来方向" class="headerlink" title="结论与未来方向"></a>结论与未来方向</h2><p>本文介绍了BarcodeTree，这是第一个用于多个浅层和稳定树的可视化技术，它能够比较单一屏幕上100棵树的拓扑结构和节点属性值。本文实验证明了，BCT在理解单个树的拓扑结构(Task1和Task2)上需要比ICICLE多得多的时间，而在比较多个树的拓扑结构(Task3和Task4)上需要比ICICLE多得多的时间。此外，还通过案例研究演示了BCT的效用，这些案例研究包含数百棵树。</p><p>未来的工作可以设计一种方法，在BCT概述和其他树形可视化之间轻松切换，使拓扑更容易理解，并结合两种方法的最佳效果，实验结果还表明，BCTh变体比BCTw更容易理解拓扑，但代价是垂直可压缩性不如BCTw。未来的工作可以设计一种方法在这两种变体之间平滑的动画，允许用户根据当前的需要过渡到其中一种或另一种</p><p>BCT的一些限制是，如果某些节点具有较大的扇出(fan-out)，那么BCT的可读性就会降低，而且BCT不是为比较每个节点都具有大量节点的少量树而设计的。这也可以在今后的工作中加以解决</p><p>树比较需要将一个树中的每个节点与另一个树中的匹配节点相关联。但是，本文工作并没有集中在匹配算法上，而是假设层次数据中的每个节点都有一个唯一的键，所以在多棵树中具有相同键的节点可以在线性时间内完全匹配，TreeJuxtaposer则通过两两相似度评分来计算最佳对应节点，这需要二次的计算时间。对于树匹配算法的研究还有待深入</p><p>在本文的视觉设计中，对角线条纹纹理的符号不能准确反映节点数，但设计它们是为了减少上下文的宽度，帮助用户关注子树。它们还可以为用户提供提示以支持进一步的探索。当可视化一个非常深的树或压缩，值得注意的是，相邻层节点间的宽度/高度差很小，用户可能难以识别拓扑结构。在这些情况下，允许用户选择给定的粒度级别并交互地更新宽度/高度。该方法支持对数值节点值进行编码，并在多个层次数据之间进行比较。未来的工作可以研究多树上多变量属性的比较</p><p>本文方法向用户提供了在屏幕空间中可视化多个树的概述。从概览中，用户还可以了解到每个节点的详细信息。然而，用户可能会被这些信息搞得不知所措，并发现难以探索。在未来，作者计划探索基于BCT对齐结果的自动模式检测算法，以方便用户的探索。</p><div class="btns rounded grid5">            <a class="button" href='http://vis.pku.edu.cn/graphvis/en/barcodetree/index.html' title='演示地址'><i class='fab fa-apple'></i>演示地址</a><a class="button" href='http://vis.pku.edu.cn/research/publication/infovis19_barcodetree.pdf' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
            <tag> 树可视化 </tag>
            
            <tag> TVCG </tag>
            
            <tag> InfoVis </tag>
            
            <tag> comparison </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShapeWordle：阿基米德螺旋感知形状生成词云</title>
      <link href="2020/11/24/shapeWordle/"/>
      <url>2020/11/24/shapeWordle/</url>
      
        <content type="html"><![CDATA[<div class="tip bell"><p>IEEE引用格式：Y. Wang et al., “ShapeWordle: Tailoring Wordles using Shape-aware Archimedean Spirals,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 1, pp. 991–1000, 2020, doi: 10.1109/TVCG.2019.2934783.</p></div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一种新技术<code>ShapeWordle</code>，可以创建形状为界的文字，将文字变成给定的形状。为了在形状内指导单词的放置，扩展了传统的阿基米德螺旋，通过使用形状的距离场以差分的方式来表示螺旋，使其具有形状感知能力。为了处理非凸形状，本文引入了一种多中心Wordle布局方法，该方法将形状分割成可感知形状的螺旋部分，以自适应地填充空间并生成单词位置。此外，还提供了一组编辑交互，以方便创建语义上有意义的文字，最后提供了三个评价：比较本文结果和最先进的技术<code>WordArt</code>，14个用户的案例研究，以及一个展示技术覆盖范围的画廊</p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>词云能够简单而有效地以引人入胜的方式来传达文本的概述，单词的大小表示了其出现的评率，人们可以非常容易地识别出文本的主题，此外词云算法利用字体和颜色产生美观而吸引人的输出，随着词云越来越受欢迎，开始出现各式各样的程序使得人们能够创造富有表现力的文字</p><p>已有的工具比如<code>WordArt</code>以及<code>Tagxedo</code>，允许人们创建指定形状的词云并用单词来填充，然而都不能同时达到高填充率和高数据保真度，如两个<code>WordArt</code>示例所示: 图a单词大小精确地编码了单词的频率，但代价是填充松散，图b通过夸大一些单词的大小来达到紧凑的填充效果。</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-2.png"></p><p>此外，现有的工具也无法做到将话题关联成一个形状的适当部分，这有助于呈现多个主题，并可以增强词云的沟通能力。这就要求词云生成工具具备以下的三个能力</p><ol><li>将不同主题的单词排列成形状的不同部分</li><li>直接操作单个单词</li><li>对词云的形状进行微调</li></ol><p>因此本文提出了<code>ShapeWordle</code>，让人们可以在保持数据保真度的同时创建指定形状的词云。技术的核心是一个能够感知形状(shape-aware)的阿基米德螺旋，用于指导单词在文字中的位置。微分形式的阿基米德螺旋使得能够通过距离场来引导它，产生任意形式的螺旋，从而用几乎等距的文字填充任意形状。</p><p>下图是cd是<code>WordArt</code>和<code>ShapeWordle</code>对同一组输入产生的词云，可以看到c图的顶部和底端几乎都是空的，需要注意的是，为了进行公平的比较，在cd图生成的时候采用了完全相同大小的同一组单词。为了获得高填充率，即使在没有足够的单词时，<code>ShapeWordle</code>也能够均匀地缩放所有的单词来填充形状，同时保留它们的相对权重，如e图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-3.png"></p><p>此外，<code>ShapeWordle</code>通过执行贪心布局策略，在复杂形状的每个部分填充与之相关的单词，可以生成多中心布局。首先采用自动图像/形状分割方法得到有意义的形状部件，然后进行交互式微调</p><p>在词云中实现高填充率的同时允许交互式编辑是一个挑战，为了解决这个问题的，本文开发了一种混合单词表示，允许在云中编辑重要的单词，并在后续步骤填充额外更小的单词。这两组之间的划分可以通过选择使用频率最高的单词的一定比例(那些最大的大小)或者选择所有超过大小阈值的单词来完成。一旦单词被分割，所有重要的单词都被安排好，用户就可以交互操作每个可编辑的单词，改变整体形状，并细化单词和形状部分之间的对应关系。由于该编辑功能，<code>ShapeWordle</code>使用户能够创建语义上有意义的文字，如图中的两个例子，这是现有工具无法轻易实现的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-1.png"></p><p>本文通过计算布局覆盖率、布局均匀性和形状相似度来定量测量结果的质量来评估方法。结果表明，该方法能够产生紧凑的文字与形状高度相似的给定轮廓，此外邀请了14个人来使用<code>ShapeWordle</code>，结果展示了<code>ShapeWordle</code>相对于<code>WordArt</code>等方法的优势</p><p>总结一下，本文的主要贡献有：</p><ol><li>制定了一个可感知形状的阿基米德螺旋来引导和对齐任意给定的形状的布局，并方便创建多中心的文字，其中不同的词被放置在给定形状的不同部分</li><li>引入了一套基于刚体操作和基于像素的放置相结合的可感知形状的词云编辑交互</li><li>对生成的词云的质量进行了定量评估，并对14名用户进行了案例研究，以说明<code>ShapeWordle</code>的表现力</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="词云可视化"><a href="#词云可视化" class="headerlink" title="词云可视化"></a>词云可视化</h3><p>对词云的设计空间的完整回顾超出了本文的范围，推荐阅读<a href="https://www.sci-hub.ren/10.1109/tvcg.2017.2746018">Taking Word Clouds Apart</a>一文来了解，这里集中讨论布局问题，给定一组具有相关权重的单词，创建单词的布局，可选择以下三个选项中的一个:水平、垂直和空间。前两个选项只是按照字母顺序或权重从上到下或从左到右排列单词，相比之下，最后一种选择没有强加任何具体的排列顺序，而是按照各种美学和语义标准来排列。词云工具就是一个典型的例子，它在近几年吸引了大量的用户，其核心是一种贪心算法，沿着一个螺旋顺序排列文字。然而，原来的算法并不能满足设计者在美学和语义上的许多需求，因为它不允许用户操作单个的单词，也不允许将单词打包成目标形状。为此，近年来提出了各种先进的版面设计和编辑方法。</p><h4 id="邻域图"><a href="#邻域图" class="headerlink" title="邻域图"></a>邻域图</h4><p>为了将相关单词排列在一起形成语义布局，通常需要构造一个邻域图，其中包含表示单词的节点和用权重将相关单词连接起来的边。<a href="https://www.sci-hub.ren/10.1109/pacificvis.2010.5429600">Cui et al</a>通过创建一个描述单词之间余弦相似度的距离矩阵，隐式构造这样一个图，然后使用强制定向方案通过矩阵的多维尺度来放置单词，以减少单词之间的空白空间。<a href="https://www.sci-hub.ren/10.1111/j.1467-8659.2011.01923.x">Wu et al</a>改进这个布局，使用接缝雕刻进一步删除空白空间。<a href="https://www.sci-hub.ren/10.1111/j.1467-8659.2012.03107.x">Paulovich et al</a>扩展了该算法，同时实现了文档及其对应词云之间的邻域关系可视化。<a href="https://link.springer.com/chapter/10.1007/978-3-642-54423-1_45">Barth et al</a>直接将邻域图合并到他们的词云中。他们表明，考虑领域关系是一个NP-hard问题。为了克服相关的计算开销，他们提出了几种近似算法，并使用隐式方法进行了定量比较，并表明<code>Wordle</code>是最紧凑的布局。本文的重点是在弱邻接图的情况下，扩展<code>Wordle</code>并将其塑造成目标形状。</p><h4 id="空间信息"><a href="#空间信息" class="headerlink" title="空间信息"></a>空间信息</h4><p>词云集成了两种空间信息:每一个词在云中的地理空间位置和艺术形态的创造，<a href="https://pure.tue.nl/ws/files/90590551/geowordclouds_authorfinal.pdf">Buchin et al</a>设计了地理词云，不仅要尊重词的频率，而且要尊重词之间的相对位置，由于保留了单词之间的空间关系，这些云可以形成地理区域的形状。<code>WordArt</code>是生成任意指定形状的紧凑字云的工具，然而，结果并不尊重实际的单词频率或数据保真度，<a href="https://www.sci-hub.ren/10.1109/tvcg.2015.2440241">Chi et al</a>展示一种替代的方式，以文字的布局作为输入，并使用约束刚体动力学重新安排的文字到一个目标形状，但是，如果初始布局与给定的形状不相似(这是经常的情况)，刚体动力学经常不能改变布局的目标形状。相比之下，本文的<code>ShapeWordle</code>直接使用可感知形状的阿基米德螺旋对给定形状的单词进行布局，允许创建紧凑的布局</p><h4 id="时间连贯性"><a href="#时间连贯性" class="headerlink" title="时间连贯性"></a>时间连贯性</h4><p>时态词云显示了一组时变词的时态变化，同时保留了它们的时态顺序，通过将平行坐标与传统词云相结合，实现了并行。<a href="https://www.sci-hub.ren/10.1109/vast.2009.5333443">TagClouds</a>沿着一个轴排列每个时间步骤中的单词，并通过连接边显示单词的变化，<a href="https://www.sci-hub.ren/10.1109/tvcg.2010.194">SparkClouds</a>通过将火花线集成到多个单词云中来显示它们之间的趋势。虽然这两种方法对于趋势可视化都有很好的表现，但它们都不能生成紧凑的布局。<a href="https://www.sci-hub.ren/10.1109/mcg.2010.102">Cui et al</a>使用多维尺度和强制定向模型来布局单词，创建时间上连贯的单词云，<a href="https://www.sci-hub.ren/10.1109/tvcg.2015.2440241">Chi et al</a>采用附加的形状序列作为输入，提出morphable词云，它们既能将单词排列成目标形状，又能保持单词位置的时间连贯性</p><h4 id="交互式编辑"><a href="#交互式编辑" class="headerlink" title="交互式编辑"></a>交互式编辑</h4><p>词云上的另一种交互形式是允许用户手动定制云的外观，在原始的Wordle工具中，因为只有全局属性可以更改，但单个单词不能更改，Koh等人介绍了<a href="https://www.sci-hub.ren/10.1109/tvcg.2010.175">ManiWordle</a>，它允许用户操作字体、颜色和单个单词的组成，后来，<a href="https://www.sci-hub.ren/10.1109/mcg.2015.113">Jo et al</a>将此方法扩展为多点触摸编辑，虽然<code>ManiWordle</code>提供了灵活的控制，但由于其潜在的放置策略，它可能会产生不一致和不可预测的布局变化，为了克服这个局限性，<a href="https://www.sci-hub.ren/10.1109/tvcg.2017.2745859">Wang et al</a>提出<code>EdWordle</code>在用户编辑时保持布局中单词之间的邻居关系。有了这种功能，用户甚至可以创建不规则形状的语义文字，尽管这样做需要非常繁琐的手工编辑。本文的<code>ShapeWordle</code>不仅根据目标形状自动生成单词云，还为用户提供丰富的交互功能来编辑形状，以及单词和形状中的部分之间的对应。</p><h3 id="基于螺旋的可视化"><a href="#基于螺旋的可视化" class="headerlink" title="基于螺旋的可视化"></a>基于螺旋的可视化</h3><p>螺旋在许多空间布局过程中被用于紧凑地安排对象。在众多不同形式中，阿基米德螺旋是一种被广泛用于可视化的螺旋，因为它可以有效地表示周期性，Gabaglio已经用它来呈现周期数据，<a href="https://www.sci-hub.ren/10.1145/288392.288399">Carlis et al</a>和<a href="http://ieg.ifs.tuwien.ac.at/~aigner/teaching/ws06/infovis_ue/papers/spiralgraph_weber01visualizing.pdf">weber et al</a>独立提出了第一个螺旋显示器的原型，其中颜色和线粗用于编码时间序列数据，之后，<a href="https://wenku.baidu.com/view/4feb50b465ce050876321390.html">Dragicevic和Huot</a>结合了螺旋和时钟隐喻，并开发了一个螺旋锁系统来显示即将到来的事件，通过沿着曲线排列编码多个变量的符号，可以进一步使用一个螺旋来显示多元数据、基于图像的搜索结果以及网络安全数据</p><p>另一方面，阿基米德螺旋被用作潜在的视觉模式来指导视觉项目的放置。两个例子是<a href="https://www.sci-hub.ren/10.1109/tvcg.2009.171">Wordles</a>和<a href="https://wenku.baidu.com/view/2d87079dfd0a79563c1e726e.html">balloon treemaps</a>，其中单词和圆圈沿螺旋排列，使用贪心策略从原点开始。然而，这些例子遵循传统的螺旋形，因此，它们可能无法有效地填充任意目标。本文工作推广了阿基米德螺旋线，以更好地适应目标形状的字的位置。允许优化生成任意形状的<code>Wordles</code></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本节首先回顾<code>Wordle</code>的布局算法，并讨论其限制其塑造一个<code>Wordle</code>能力的两个固有缺陷。然后对阿基米德螺旋公式进行了简要的描述</p><h3 id="Wordle布局算法"><a href="#Wordle布局算法" class="headerlink" title="Wordle布局算法"></a>Wordle布局算法</h3><p>给出一个单词列表和与每个单词相关的权重，Wordle算法调整每个单词的大小与其权重的比例，然后使用基于样条的轮廓线表示每个单词的边界。为了使单词排列紧凑且不与更重要的单词靠近质心重叠，算法首先按权重降序对单词进行排序，然后按照以下两个步骤一次放置一个单词</p><ol><li>初始化：在画布的中心随机选择一个位置</li><li>搜索与更新：从所选的随机位置开始创建一个螺旋，并沿着螺旋搜索放置下一个单词的位置，这样下一个单词不会与任何已经放置的单词重叠; 然后，用单词的位置更新单词云</li></ol><p>能够在水平，垂直或对角线方向放置单词允许创建许多变体。虽然初始位置可以是完全随机的，但最终的<code>Wordle</code>可能不是很紧凑</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-4.png"></p><p>弊端：这两个步骤都严重限制了<code>Wordle</code>在创建任意形状的单词云时的灵活性。首先，阿基米德螺旋总是以圆形的方式寻找新的位置，所以产生了<code>Wordle</code>不能有效的符合目标形状，其次，选择一个中心周围的初始位置会产生一个单件<code>Wordle</code>，阻碍多主题词云的创建。总的来说，这两个因素很大程度上归因于大多数<code>Wordles</code>的臃肿外形。相比之下，讲故事的词云通过将单词排列成复杂的、多部分的形状来传达语义。用户需求和<code>Wordle</code>功能之间存在差距</p><h3 id="阿基米德螺线"><a href="#阿基米德螺线" class="headerlink" title="阿基米德螺线"></a>阿基米德螺线</h3><p>阿基米德螺旋是应用最广泛的欧几里得螺旋之一，在极坐标下很容易定义</p><p>$r(\theta)=m\theta+b$</p><p>$\theta$是极角，$r$是到原点的径向距离，$b = r(0)$是起始点到原点的初始距离，$m$控制连续转弯之间的距离，连续匝间具有均匀间距($2m\pi$)是阿基米德螺线的一个重要而有用的特性，在医学成像、材料设计和数字光处理等许多应用中都有应用，这样的特性促进了有效的(均匀的)空间填充，可创建紧凑的Wordles</p><h2 id="可感知形状的Wordle"><a href="#可感知形状的Wordle" class="headerlink" title="可感知形状的Wordle"></a>可感知形状的Wordle</h2><p>本节中将介绍如何通过扩展阿基米德螺旋以实现可感知形状的<code>Wordle</code>，以及如何支持生成多中心的<code>Wordle</code>布局来实现可感知形状的<code>Wordle</code></p><h3 id="可感知形状的阿基米德螺旋"><a href="#可感知形状的阿基米德螺旋" class="headerlink" title="可感知形状的阿基米德螺旋"></a>可感知形状的阿基米德螺旋</h3><p>阿基米德螺线也可以用三角函数表示为笛卡尔坐标x和y</p><p>$\begin{pmatrix} x \ y \end{pmatrix}=r(\theta)\begin{pmatrix}\cos{\theta} \ \sin{\theta} \end{pmatrix}$</p><p>对上式求导可以得到</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-14.png"></p><p>$(\frac{dx}{d\theta},\frac{dy}{d\theta})$为在$(x,y)$点时的运动方向，记为$U$，将其沿着$N=(\cos\theta,\sin\theta)^T$以及$T=(-\sin\theta,\cos\theta)^T$方向分解</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-5.png"></p><p>其中$N$和$T$是单位法向量和单位切向量，阿基米德螺线的运动方向$U$由$N$和$T$决定，为了使螺旋在连续转弯之间的间距大致恒定，首先计算与输入形状相关的距离场(用$\varphi$表示)，然后，将$N$和$T$与$\varphi$等值线对齐，这样，当从一个形状内的起点构造螺旋时，螺旋可以按照该形状的方式运动，并最终满足形状轮廓</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-6.png"></p><h4 id="计算距离场"><a href="#计算距离场" class="headerlink" title="计算距离场"></a>计算距离场</h4><p>距离场是一种有效的形状表示，已用于边缘捆绑和步道数据可视化，它是一个标量字段，指定由距离变换指定的到形状轮廓的最短距离$R^2 \to R_+$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-7.png"></p><p>$p$是二维空间中的点，$\Omega$是形状轮廓，$q$是$\Omega$上的任意点，注意，$\varphi$在形状轮廓上为零，并向形状的中心或中轴方向逐渐增加，本文使用线性算法计算距离场，时间复杂度为$O(n)$，$n$是二维空间中的点数</p><h4 id="延伸阿基米德螺旋"><a href="#延伸阿基米德螺旋" class="headerlink" title="延伸阿基米德螺旋"></a>延伸阿基米德螺旋</h4><p>要将阿基米德螺旋扩展成可感知形状的螺旋，主要的问题是如何引导螺旋的运动，或如何定义螺旋在给定形状的任意点p上的运动方向。不用明确地构造等值线然后计算$p$点处的法线，而是取距离场的梯度为$N$。该策略可以准确地逼近连续标量场。一旦N可用，T就很容易得到，因为它是一个与N正交的单位向量，然后将式子重写成微分形式</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-8.png"></p><p>其中$r=\sqrt{x^2+y^2}$，然而，在任意形状的每个点上使用相同的q可能是不合适的，因为生成的螺旋可能不能适应高曲率的区域，例如，靠近圣诞树的角落</p><p>为了刻画这种尖锐的特征，考虑了沿螺旋的局部曲率，并通过小的切向运动来近似曲线(用ds表示)垂直于$N$的$Rd\eta$和$rd\theta$，其中$R$是局部曲率半径，$h$是用户指定的角速度参数。这样做，我们可以写</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-9.png"></p><p>注意，Eq(4)中的$r$也可以看作是定义在一般距离场$\varphi$的等值线(同心圆)上的局部曲率半径，$R$是可感知距离场$\varphi$的等值线上定义的局部曲率半径，为了估计$\varphi$中任意点上的$R$，本文使用<code>Hessian</code>矩阵，把所有东西放在一起，可以把Eq(4)重写为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-10.png"></p><p>注意，$R$和$r$在不同的点上是不同的，而$m$和$d\eta$是用户指定的常数参数</p><p>本文使用Eq(6)计算$dx$和$dy$，从原点开始逐步跟踪螺旋，通常设$m = 1, d\eta=p=5$，而$m$和$R$在形状图像上以像素为单位进行测量，由于$m$是一个常数，所产生的螺旋在连续转弯之间可以有接近均匀的间距($2mp$)</p><p>图中显示了一些示例。在直线曲线段R可能过大的情况下，为了避免过度移动，团队经验性地设置了1.5像素单位的最大切向移动距离上界</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-11.png"></p><p>作者在一台四核PC上运行该方法，23寸液晶宽屏，Intel(R) Core(TM) i7-6700K CPU, 16GB RAM。对于一个60个单词的词云，完成不到5秒</p><h4 id="均匀定标"><a href="#均匀定标" class="headerlink" title="均匀定标"></a>均匀定标</h4><p>将形状感知阿基米德螺旋加入到Wordle布局算法中，可以有效地生成形状感知wordle，但是，如果单词总面积远远小于形状总面积，就很难创建一个图形紧凑布局。因此，本文为单词定义了一个统一的缩放参数，以使填充率最大化，同时保留单词之间的相对权重</p><h3 id="多中心布局"><a href="#多中心布局" class="headerlink" title="多中心布局"></a>多中心布局</h3><p>对于包含多个组件的输入形状，本文使用可感知形状的阿基米德螺旋为每个组件生成<code>Wordle</code>布局。图中显示了一个具有三个组件的示例，示例生成了一个多主题，通过在每个组成部分:郁金香，春天和花球中填充一个特定主题的词来Wordle</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-12.png"></p><p>但是，如果一个组件有多个距离字段的局部最大值，为整个组件生成Wordle布局可能无法完全填充它。图中所示的形状有两个分量。在右翼部分只追踪一个从整体最大值开始的单一螺旋，就会错过机翼的顶部，造成大面积的空区</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-13.png"></p><p>为了让Wordle算法适应这种非凸组件，使用一个多中心布局来生成螺旋，并在多个局部最大值周围放置单词。</p><h4 id="形状分割"><a href="#形状分割" class="headerlink" title="形状分割"></a>形状分割</h4><p>给定一个形状，本文做法是检测形状中的连通分量，并为每个分量生成一个距离场，然后使用迭代的梯度下降程序来定位每个组件中的局部最大值和相关的形状区域，这允许隐式地将一个组件分割为几个部分，下图显示了一个例子，其中两个组成部分的鸽子形状被分割成四个部分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-15.png"></p><h4 id="词填充"><a href="#词填充" class="headerlink" title="词填充"></a>词填充</h4><p>给定要填充形状的单词列表，首先对每个单词设置字体大小，使所有单词的总面积占形状总面积的70%，然后使用贪心策略将单词分配给形状的不同部分，记$p_{i,j}$为地$i$个分量的第$j$个部分，$A_{i,j}$为$p_{i,j}$的面积，N是总共输入的单词数量，那么$p_{i,j}$的单词数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-16.png"></p><p>假设权重最大的单词应该分配给最大的部分，定义每个部分中单词的最大权重为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-17.png"></p><p>一旦$n_{i,j}$和$w_{i,j}$被决定下来，同时从输入的单词列表中随机分配单词到每个部分，使得$p_{i,j}$中任意一个单词的权重不超过$w_{i,j}$。如果由于这样的分配耗尽了放置单词的空间，那么一致地缩小所有单词，并重复单词分配过程，通过跟踪每个部分的局部最大值，用文字填充非凸形状，结果如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-18.png"></p><h2 id="ShapeWordle交互式系统"><a href="#ShapeWordle交互式系统" class="headerlink" title="ShapeWordle交互式系统"></a>ShapeWordle交互式系统</h2><p>在本节中将介绍ShapeWordle系统，该系统可以方便用户交互式地创建和编辑任意形状的单词云，同时保持其审美特征。与现有的单词云编辑系统一样，ShapeWordle允许用户通过对单个单词和形状的交互操作来控制布局，在这些之上，如图所示的管道所示，用户可以简单地加载一段文本并加载/选择一个形状(a)，应用一个形状分割(b)，并点击一个按钮来生成一个单词云，完全填充给定的形状</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-19.png"></p><p>在生成布局之前，用户可以手动将语义相关的单词关联到特定的分段部分，从而创建多主题文字处理，如果分割的部分是没有意义的，可以通过交互的方式进行细化，单词云生成后，用户可以通过各种编辑操作进一步操作重要的单词，然后把不太重要的单词填入最后一个单词，下文描述如何用两步布局完全填充一个形状，并执行交互式单词云编辑</p><h3 id="two-step布局"><a href="#two-step布局" class="headerlink" title="two-step布局"></a>two-step布局</h3><p>即使将所有的单词统一缩放，也不一定能够完全填充一个形状，另一方面，用户在浏览单词云时，主要被大单词所吸引，而对小单词的关注较少。为了有效地填充一个形状，本文将输入单词分成两类:核心单词是最上面的N个可以交互操作的重要单词，而边缘单词用于填充空间。为了提供保持一致性的词云编辑，本文用核心词的边界框表示其布局，在编辑阶段将其视为刚体，与核心词相比，每个边缘词都以“1”为前景，“0”为背景的二值掩码图像表示</p><p>使用这个组合表示来生成两个步骤的布局，即：放置核心词，然后边缘词，首先，使用可感知形状的阿基米德螺旋来定位核心单词，以便它们的整体形状更好地与输入形状对齐。注意，如果没有足够的核心单词，布局可能不会被完全填充，为了清楚地显示核心字，本文均匀地扩大他们，直到他们支配形状区域的大部分，与之相反，边缘词则使用传统的阿基米德螺旋，原因有二，首先，大量微小的边缘词主要用于填充形状中剩余的小的空白区域，它们不需要与形状对齐，其次，对大量微小的边缘词计算形状感知的阿基米德螺旋是费时的，也是不必要的</p><h3 id="ShapeWordle编辑"><a href="#ShapeWordle编辑" class="headerlink" title="ShapeWordle编辑"></a>ShapeWordle编辑</h3><p>创建好Wordle后，用户可以在编辑模式下对其进行操作，在编辑模式下，边缘词消失，用户可以交互修改核心词(如移动、旋转、调整大小、删除)，同时保留核心词之间的邻域关系，操作完成后，用户只需点击一个按钮，就可以用边缘文字填充整个形状</p><p>在编辑模式中，每个单词被框为带有质量的刚体，应用自定义刚体动力学对单词进行力的移动。动力学系统允许通过施加非穿透约束来避免词语重叠，自动检测物体之间的碰撞并将相关的物体分开来响应碰撞。这样，在用户移动/调整单词大小后，周围所有相关单词将自动重新定位。为了支持直观的基于形状的编辑，这里使用两个附加约束自定义刚体动力学:</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">边界约束</button></li><li class="tab"><button type="button" data-href="#test-2">一致性约束</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>为了使文字保持在对应的形状部分内，采用边界约束将形状边界像素作为静态刚体。如果一个字与他们接触，它会被弹回来。如果整个单词(或重要部分)超出了边界，那么就假设用户有意地将单词从该部分中取出，因此不会将边界力应用到该单词上</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>删除文字会导致布局中出现大面积的空白区域。为了保持布局的一致性，引入了一个一致性约束来插入虚拟体来表示空白区域，并使用中央力来拉入周围的单词。</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-20.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>本节一共做了三件事情</p><ol><li>定量评估比较<code>ShapeWordle</code>与SOTA模型</li><li>个案研究</li><li>如何扩展<code>ShapeWordle</code>用于制造临时形状的<code>Wordles</code></li></ol><h3 id="定量比较"><a href="#定量比较" class="headerlink" title="定量比较"></a>定量比较</h3><p>有两种现有的工具可以自动生成带有形状的单词云：<code>WordArt</code> 和 <code>Tagxedo</code>，对于<code>Tagxedo</code>，作者发现如果不能适应布局中的单词，可能会丢失重要的单词，与输入数据不相符。因此，文中主要将<code>ShapeWordle</code>与<code>WordArt</code>进行比较，后者是迄今为止生成单词云的最佳工具，但是，由于<code>WordArt</code>的算法和代码是不可访问的，只能从<code>WordArt</code>获得常规RGB图像形式的输出，因此，为了与<code>WordArt</code>进行比较，使用<code>ShapeWordle</code>生成与<code>WordArt</code>相同分辨率的常规RGB图像</p><p>本文使用以下三个度量来定量地评估生成的单词云的质量</p><ul><li>布局覆盖 (Layout coverage，LC)</li></ul><p>LC是对<a href="https://link.springer.com/chapter/10.1007/978-3-642-54423-1_45">Barth et al</a>的扩展，用于测量生成布局中的整体空间比例。为此，本文用文本颜色计算像素的数量和形状内非文本背景色的像素数。因此，LC值越大，越接近1，覆盖率越高</p><ul><li>布局均匀性 (Layout uniformity，LU)</li></ul><p>这个度量从另一个方面度量了布局中单词之间的间隙分布的均匀性，满足了wordles的基本要求。本文根据以下观察来构建LU:如果一个布局中的单词是均匀分布的，那么单词之间的间隔应该很小并且大小相似。因此，给定单词的布局，首先生成一个像素级的距离字段(记为$\varphi$)，每个像素以文本颜色存储到最近像素的距离，因此定义了LU，将每个像素的平方距离值相加，并通过形状内非文本像素的总数对总和进行规范化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-21.png"></p><p>其中$p_i$是形状内的第$i$个像素，在这里，一个小的LU表示一个更好的布局均匀性，用平方距离值来惩罚较大的距离</p><ul><li>形状相似性 (Shape similarity，SS)</li></ul><p>第三个度量标准SS旨在衡量生成的<code>wordle</code>与给定形状的一致性如何，这里作者采用<a href="https://www.sci-hub.ren/10.1016/j.cad.2006.06.007">最小距离模型</a>来度量每个边界像素的距离，对于形状轮廓上的每个像素$\Omega_B$，找到距离(记为$\rho$)到形状中最近的文本颜色像素，这样，可以通过对形状轮廓上每像素的平方距离求和来定义SS，并以形状轮廓上的总像素数($n_contour$)对其求和进行归一化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-22.png"></p><p>与LU类似，小的SS表示更好地匹配输入形状轮廓的布局</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-23.png"></p><p>关于数据保真度，本文没有明确地将其作为一个度量，因为本文方法已经完全尊重了单词的原始权重。为了进行公平的比较，还有意地将<code>WordArt</code>设置为产生充分尊重数据保真度的布局</p><div class="timeline"><div class="timenode"><div class="meta"><p><p>数据</p></p></div><div class="body"><p>本文使用来自<a href="https://link.springer.com/chapter/10.1007/978-3-642-54423-1_45">Brath et al</a>的数据集，其中包括112篇文章摘自英文维基百科，45篇科学论文摘自SEA和ALENEX会议记录，此外，收集了157个不同类别的形状，如动物、植物、运动和数字，然后为每个文档随机分配一个独特的形状，为了检查<code>ShapeWordle</code>如何在单中心和多中心的<code>Wordles</code>中表现，进一步将形状分为两种类型:单部分形状和多部分形状</p></div></div><div class="timenode"><div class="meta"><p><p>设置</p></p></div><div class="body"><p>由于<code>WordArt</code>的算法和代码不可用，本文试图使用更一致的设置来比较<code>ShapeWordle</code>和<code>WordArt</code>，首先，使用对偶字体以水平方向绘制这两个系统中的所有单词。其次，<code>WordArt</code>如何将单词频率(或权重)映射到生成的单词的字体大小是未知的，因此，首先使用<code>WordArt</code>来生成一个单词布局，然后直接将生成的单词的字体大小(在下载的CSS文件中提供)作为<code>ShapeWordle</code>中的输入单词的权重，第三，虽然<code>WordArt</code>和<code>ShapeWordle</code>都可以用大量的小单词完全填充一个给定的形状，但是为了评价一个布局的质量，主要考虑那些更能吸引用户注意力的大的重要单词的布局，此外，使用更少的单词来更均匀地生成形状的单词云实际上更具挑战性，考虑到这些因素，本文将单词数量定为60个，这通常不足以完全填充输入形状</p></div></div><div class="timenode"><div class="meta"><p><p>结果</p></p></div><div class="body"><p>作者使用这些方法和<code>WordArt</code>为整个数据集生成形状单词云，并计算每个结果的LC、LU和SS分数，所有生成的word clouds的截图以及它们的LC、LU和SS分数可以在补充材料中找到。此外，还创建了如图所示的箱线图，以汇总得分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-24.png"></p><p>一般来说，较大的LC值表示布局覆盖率较好，不可能达到接近1的值，因为LC只计算形状中的文本颜色像素。LC值的比较结果如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-25.png"></p><p><code>WordArt</code>是没法通过统一放大单词来提高覆盖率的，但是得益于形状感知的阿基米德螺旋，<code>ShapeWordle</code>可以通过这种方式来提高覆盖率</p><p>另一方面，LU和SS测量像素级的平方距离，以考虑布局的均匀性和形状的相似性。LU值越小，说明布局均匀性越好，结果中单词之间的间隙越小，越均匀;SS值越小，说明单词与形状轮廓的匹配性越好，再次感谢形状感知阿基米德螺旋，它使系统能够生成更加统一的形状感知布局。因此，可以更均匀地分布单词在形状中，同样，<code>ShapeWordle</code>可以达到更低的SS值，因为螺旋更好地符合给定的形状</p><p>此外，比较单中心形状和多中心形状的结果，我们可以看到两者的LC、LU和SS分数都下降了，这是合理的，因为多中心布局通常包含多个较小的部分，在这种情况下，填写与各个部分更好匹配的单词会比较困难。然而，<code>ShapeWordle</code>仍然为单中心和多中心形状生成更紧凑和均匀分布的单词</p></div></div></div><h3 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h3><p>为了探究<code>ShapeWordle</code>的表达能力，作者对来自当地大学不同学校的14名参与者进行了案例研究。在这项研究中，向参与者展示了<code>ShapeWordle</code>的所有功能，并要求他们创建一个自己喜欢的布局，团队仔细观察他们的行为，在他们完成之后，对他们每个人进行了简短的访谈，以收集他们的设计理念和对系统的反馈，每个案例大约需要5-20分钟，包括设计过程和交互。所有的参与者都认为创建过程很有吸引力</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-26.png"></p><p>各个图的设计理念和过程见原文，此处略过</p><h3 id="时态数据的扩展"><a href="#时态数据的扩展" class="headerlink" title="时态数据的扩展"></a>时态数据的扩展</h3><p>最后，本文将该方法扩展到使用时变文本数据生成时态形状文字。<code>Morphable word clouds</code>是生产时态形状文字机的最新技术，但它需要解决一个复杂的刚体动力学系统，多亏了能感知形状的阿基米德螺旋，可以用更简单的策略实现这个目标。给定一段时间内的一组图形，首先准备连续图形之间的对应关系，因此，在为第一个形状生成布局之后，可以参考该布局来指导下一个形状中的单词放置。通过这种方式，可以在考虑时间一致性的同时，随着时间的推移而产生成形状<code>Wordles</code></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/shapeWordle-27.png"></p><p>上图是两者的比较，图a是<code>ShapeWordle</code>，图b是<code>Morphable word clouds</code>，可以看出前者显然更紧凑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了<code>ShapeWordle</code>，一种便于用户创建任意形状<code>Wordles</code>的技术。这项技术的核心是形状感知阿基米德螺旋线，用于引导单词在Wordle内的位置，过将阿基米德螺旋以微分形式表述出来，可以利用该形状的距离场来产生任意形式的螺旋，从而产生可感知形状的涡旋，对于复杂的形状，引入了一种多中心<code>Wordle</code>布局技术，它首先将形状分割成多个部分，然后使用可感知形状的螺旋自适应地将单词放置在每个部分中，为了允许用户交互地编辑单词，同时密集地填充形状，本文进一步开发了一种混合单词表示，它可以编辑云中重要的单词并填充其他的小单词，此外，还提供了一组编辑交互来促进语义上有意义的创建wordle。通过定量比较本文系统和最先进的工具来评估它，进行案例研究，并提出了一个生成时间词云的扩展</p><p>ShapeWordle仍有一些局限性，目前的多中心形状在紧凑性和统一性方面不如单中心形状，其次，虽然目前的方法可以以一种感知形状的方式放置单词，但它不能自动改变单词的方向，并使单词与形状保持一致，比如将鸽子的特征中的单词对齐，需要花费参与者大约7分钟的时间，作者将研究在未来将形状定位纳入螺旋的可能性。最后，将探索更多的应用形状感知阿基米德螺旋可视化的情况</p><div class="btns rounded grid5">            <a class="button" href='http://www.shapewordle.com/' title='演示地址'><i class='fab fa-apple'></i>演示地址</a><a class="button" href='http://www.yunhaiwang.net/infoVis2019/shapewordle/shapewordle.pdf' title='论文地址'><i class='fas fa-book-open'></i>论文地址</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
            <tag> TVCG </tag>
            
            <tag> InfoVis </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习记录：更强大的评论系统</title>
      <link href="2020/11/19/react3/"/>
      <url>2020/11/19/react3/</url>
      
        <content type="html"><![CDATA[<p>我们来继续优化之前写的<a href="/2020/11/17/react2/">评论系统</a></p><details cyan><summary> 功能实现CheckList </summary>              <div class='content'>              <div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>聚焦功能</p>            </div><div class='checkbox'><input type="checkbox" />            <p>组件参数验证</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>用户名记录</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>评论记录</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>发布时间显示</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>评论删除</p>            </div><div class='checkbox'><input type="checkbox" />            <p>代码块引入</p>            </div>              </div>            </details><h2 id="聚焦功能"><a href="#聚焦功能" class="headerlink" title="聚焦功能"></a>聚焦功能</h2><p>首先给评论系统增加一个聚焦功能，具体是，当页面加载完毕之后，会自动聚焦到评论框</p><p>React.js通过<code>ref</code>来获取已经挂载的元素的DOM节点</p><p>我们在textarea中使用<code>ref</code>，<code>ref</code>是一个函数，当元素在页面上挂载完毕的时候，React.js 就会调用这个函数，并且把这个挂载以后的 DOM节点传给这个函数，之后我们就可以通过this.(元素名)来获取这个DOM元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea </span><br><span class="line">    ref=&#123;<span class="function">(<span class="params">textarea</span>) =&gt;</span> <span class="built_in">this</span>.textarea = textarea&#125;</span><br><span class="line">    value=&#123;<span class="built_in">this</span>.state.content&#125;</span><br><span class="line">    onChange=&#123;<span class="built_in">this</span>.handleContentChange.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>然后在class中加入<code>ComponentDidMount</code>生命周期</p><p><a href="https://www.runoob.com/react/react-component-life-cycle.html">React.js生命周期方法</a></p><p><code>ComponentDidMount</code>在第一次渲染后调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>.textarea.focus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react3-1.png"></p><p>刷新页面后，可以看到已经完成了对评论框的聚焦</p><h2 id="组件参数验证"><a href="#组件参数验证" class="headerlink" title="组件参数验证"></a>组件参数验证</h2><p>Javascript是一种非常灵活的语言，灵活体现在其弱类型，高阶函数等语言特性，但是这也意味着特别容易出bug</p><p>这里我突然想起来一则笑话：程序员开发团队写了一个咖啡馆，然后测试员开始对咖啡馆进行测试，他们开始尝试从门口走入咖啡馆，爬窗进入，从下水道进入咖啡馆，坐着，躺着，站着喝咖啡，最后对这个咖啡馆表示满意，结果，咖啡馆上线的第一天，一位顾客进来点了一份炒饭，咖啡馆爆炸了</p><p>嗯，是这样的，你永远没法知道使用者会对组件传入什么奇怪的参数，强类型的语言可以一定程度上规避这个问题，弱类型语言由于限制规则少，安全性是很差的</p><p>我们在写评论组件的时候，传入的props是一个comment数组，如果使用组着的人传入一个数字1，页面不会有任何的报错，但是会显示不正常，所以我们需要定义一个props的类型</p><p>教程上是这么使用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    comment: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我照着使用之后报错了</p><div class="tip warning"><p>PropTypes 自 React v15.5 起被移除，使用 prop-types 第三方库来进行替换</p></div><p>安装这个库之后从prop-types中导入，用法是相同的</p><h2 id="用户名记录"><a href="#用户名记录" class="headerlink" title="用户名记录"></a>用户名记录</h2><p>接下来实现一个功能，让用户在浏览器刷新之后保留上一次填写的用户名</p><p>我们首先监听失去焦点的事件<code>onBlur</code></p><p><code>onBlur</code>和<code>onChange</code>的区别：<code>onBlur</code>是光标焦点只要离开调用方法的文本框就会发生，而<code>onChange</code>则是内容改变才会发生</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">input中加入onBlur</button></li><li class="tab"><button type="button" data-href="#test-2">存储信息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">      value=&#123;<span class="built_in">this</span>.state.username&#125;</span><br><span class="line">      onBlur=&#123;<span class="built_in">this</span>.handleUsernameBlur.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">      onChange=&#123;<span class="built_in">this</span>.handleUsernameChange.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_saveUsername (username) &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;username&#x27;</span>, username)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleUsernameBlur (event) &#123;</span><br><span class="line">    <span class="built_in">this</span>._saveUsername(event.target.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>然后我们在<code>componentWillMount</code>生命周期载入名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>._loadUsername()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_loadUsername () &#123;</span><br><span class="line">    <span class="keyword">const</span> username = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (username) &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; username &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评论记录"><a href="#评论记录" class="headerlink" title="评论记录"></a>评论记录</h2><p>然后我们用相同的方式把评论也持久化，在每次用户提交评论的时候保存评论列表数据，挂载的时候加载起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">        <span class="built_in">this</span>._loadComments()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _loadComments () &#123;</span><br><span class="line">        <span class="keyword">let</span> comments = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;comments&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (comments) &#123;</span><br><span class="line">            comments = <span class="built_in">JSON</span>.parse(comments)</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123; comments &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _saveComments (comments) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;comments&#x27;</span>, <span class="built_in">JSON</span>.stringify(comments))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleSubmitComment (comment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!comment) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (!comment.username) <span class="keyword">return</span> alert(<span class="string">&#x27;请输入用户名&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!comment.content) <span class="keyword">return</span> alert(<span class="string">&#x27;请输入评论内容&#x27;</span>) </span><br><span class="line">        <span class="keyword">const</span> comments = <span class="built_in">this</span>.state.comments</span><br><span class="line">        comments.push(comment)</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; comments &#125;)</span><br><span class="line">        <span class="built_in">this</span>._saveComments(comments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示发布时间"><a href="#显示发布时间" class="headerlink" title="显示发布时间"></a>显示发布时间</h2><p>我们记录发布评论的时间，通过和当前时间的差值来计算</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">CommentInput修改</button></li><li class="tab"><button type="button" data-href="#test-2">Comment中增加时间显示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.onSubmit) &#123;</span><br><span class="line">        <span class="comment">// const &#123; username, content &#125; = this.state</span></span><br><span class="line">        <span class="built_in">this</span>.props.onSubmit(&#123;</span><br><span class="line">            username: <span class="built_in">this</span>.state.username,</span><br><span class="line">            content: <span class="built_in">this</span>.state.content,</span><br><span class="line">            createdTime: +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123; <span class="attr">timeString</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillMount () &#123;</span><br><span class="line">        <span class="built_in">this</span>._updateTimeString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _updateTimeString () &#123;</span><br><span class="line">        <span class="keyword">const</span> comment = <span class="built_in">this</span>.props.comment</span><br><span class="line">        <span class="keyword">const</span> duration = (+<span class="built_in">Date</span>.now() - comment.createdTime) / <span class="number">1000</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            timeString: duration &gt; <span class="number">60</span></span><br><span class="line">            ? <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(duration / <span class="number">60</span>)&#125;</span> 分钟前`</span></span><br><span class="line">            : <span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.max(duration, <span class="number">1</span>))&#125;</span> 秒前`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;comment&#x27;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&#x27;comment-user&#x27;</span>&gt;</span><br><span class="line">                    &lt;span&gt;&#123;<span class="built_in">this</span>.props.comment.username&#125; &lt;/span&gt;：</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="built_in">this</span>.props.comment.content&#125;&lt;/p&gt;</span><br><span class="line">                &lt;span className=<span class="string">&#x27;comment-createdtime&#x27;</span>&gt;</span><br><span class="line">                    &#123;<span class="built_in">this</span>.state.timeString&#125;</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react3-2.png"></p><p>这样就能够显示评论是在几分钟前发布的，但是需要刷新页面才能够更新显示时间</p><p>我们希望评论的时间能自动刷新，所以我们用<code>setInterval</code>设置一个刷新时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount () &#123;</span><br><span class="line">    <span class="built_in">this</span>._updateTimeString()</span><br><span class="line">    <span class="built_in">this</span>._timer = <span class="built_in">setInterval</span>(</span><br><span class="line">        <span class="built_in">this</span>._updateTimeString.bind(<span class="built_in">this</span>),</span><br><span class="line">        <span class="number">5000</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除评论"><a href="#删除评论" class="headerlink" title="删除评论"></a>删除评论</h2><p>我们接着给评论系统增加删除功能，首先在comment.js中增加一个<code>删除</code>按钮，在css中设置被鼠标cover时才能出现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; comment &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&#x27;comment&#x27;</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">&#x27;comment-user&#x27;</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">&#x27;comment-username&#x27;</span>&gt;</span><br><span class="line">                    &#123;comment.username&#125;</span><br><span class="line">                &lt;/span&gt;:</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;p&gt;&#123;comment.content&#125;&lt;/p&gt;</span><br><span class="line">            &lt;span className=<span class="string">&#x27;comment-createdtime&#x27;</span>&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state.timeString&#125;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span className=<span class="string">&#x27;comment-delete&#x27;</span>&gt;</span><br><span class="line">                删除</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个删除按钮时在Comment组件中的，但是存储评论是在CommentApp组件中，我们需要通过CommentList来传递删除的信息</p><p>我们在Comment以及CommentList的props中再设置一个参数onDeleteComment</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Comment.js修改</button></li><li class="tab"><button type="button" data-href="#test-2">CommentList.js修改</button></li><li class="tab"><button type="button" data-href="#test-3">CommentApp.js修改</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleDeleteComment () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.onDeleteComment) &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.onDeleteComment(<span class="built_in">this</span>.props.index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span</span><br><span class="line">    onClick=&#123;<span class="built_in">this</span>.handleDeleteComment.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">    className=<span class="string">&#x27;comment-delete&#x27;</span>&gt;</span><br><span class="line">    删除</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">handleDeleteComment (index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.onDeleteComment) &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.onDeleteComment(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.props.comments.map(<span class="function">(<span class="params">comment, i</span>) =&gt;</span></span><br><span class="line">            &lt;Comment</span><br><span class="line">                comment=&#123;comment&#125;</span><br><span class="line">                key=&#123;i&#125;</span><br><span class="line">                index=&#123;i&#125;</span><br><span class="line">                onDeleteComment=&#123;<span class="built_in">this</span>.handleDeleteComment.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">handleDeleteComment (index) &#123;</span><br><span class="line">    <span class="keyword">const</span> comments = <span class="built_in">this</span>.state.comments</span><br><span class="line">    comments.splice(index, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; comments &#125;)</span><br><span class="line">    <span class="built_in">this</span>._saveComments(comments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span><br><span class="line">            &lt;CommentInput onSubmit=&#123;<span class="built_in">this</span>.handleSubmitComment.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">            &lt;CommentList</span><br><span class="line">                comments=&#123;<span class="built_in">this</span>.state.comments&#125;</span><br><span class="line">                onDeleteComment=&#123;<span class="built_in">this</span>.handleDeleteComment.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>看看这些代码，会觉得其实非常套娃，当用户点击删除按钮的时候<code>Comment</code>组件会调用<code>props.onDeleteComment</code>，其对应<code>CommentList</code>中的<code>handleDeleteComment</code>，在这个函数中，调用了<code>commentList</code>的<code>props.onDeleteComment</code>，其对应的是<code>CommentApp</code>组件中的<code>handleDeleteComment</code>，这就把参数index逐层传递了上来</p><p>快乐删除，并得到了一个报错</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react3-3.png"></p><p>这是因为我们评论的计时器没有删除掉，我们在Comment组件中新增生命周期commentWillUnmount，在组件销毁时清除定时器，类似于C++的析构函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>._timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip success"><p>删除功能完成 </p></div><div class="btns rounded grid5">            <a class="button" href='https://forever97.github.io/comment-app/' title='演示地址'><i class='fab fa-apple'></i>演示地址</a><a class="button" href='https://github.com/forever97/comment-app/tree/master' title='下载源码'><i class='fas fa-download'></i>下载源码</a>          </div>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：贪心策略中的等值性</title>
      <link href="2020/11/17/Re0-6/"/>
      <url>2020/11/17/Re0-6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>USACO Training 1.3的题目中出现了两题涉及到贪心思想，思路都比较简单，但是贪心策略呢，还是蛮难的一个东西，本文主要稍微介绍一下贪心中的一个比较重要的思想：等值性，当然还有一些题目会涉及等价性，但是通过转化还是会变成一个等值性的问题，我尽量挑选一些比较简单的题目阐释一下什么是等值性，以及这个性质在解题过程中一般会有什么用</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Mixing Milk]</p><p>给出牛奶制造公司每日的牛奶需求，以及每个农民的可提供的牛奶量和每加仑的价格，计算牛奶制造公司所要付出钱的最小值</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>拿到这个题，可能非常容易得到思路，将牛奶价格从低到高排序，依次购买</p><p>原理呢，就是等值性，所有牛奶都是一加仑一加仑出售的，如果买了价格高的一加仑，为何不用价格低的一加仑去替代呢，可能对贪心有所涉猎的同学会知道，这还有一个解释，就是等值性符合贪心的法则，局部最优解导向全局最优解</p><p>那如果每个农民的牛奶是盒装的，每个农民的包装盒大小不一，必须整盒购买，那这个时候还能采用这种贪心策略么，肯定就不行了，因为不具备等值性的情况下这种贪心策略无法保证无后效性，子问题的决策影响了全局最优解，举个极端的例子，你买最便宜的牛奶，结果一盒容量特别大，导致超出了你的牛奶需求，虽然单价便宜，但是花费的总价格还是多的，这种问题是动态规划中的背包问题，有兴趣的同学可以自己先了解，此处不详细展开</p><h2 id="更多的例题"><a href="#更多的例题" class="headerlink" title="更多的例题"></a>更多的例题</h2><h3 id="酸奶工厂"><a href="#酸奶工厂" class="headerlink" title="酸奶工厂"></a>酸奶工厂</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>奶牛们收购了一家世界著名的酸奶工厂YuckyYogurt. 在接下来的N周, 牛奶和人工的价格每周会波动，第$i$周公司能够以$C_i$美分一单位的价格来生产酸奶。Yuckyfactory被奶牛们照顾得很好，所以每周可以生产很多单位的酸奶，YuckyYogurt 拥有一个仓库，可以以<strong>S美分每单位每周</strong>的价格储存没用的酸奶。神奇的是，酸奶不会变质。而且仓库十分巨大，可以容纳很多牛奶，YuckyYogurt 每周要交付$Y_i$单位的酸奶给它的客户。请你帮助奶牛们减少整个N-week期间的支出. 第i周生产的牛奶和之前储存的牛奶都可以用来交第i周的货</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先我们寻找题目中的等值性。需要交付的酸奶，这是等值的，也就是说，我只要知道，每单位酸奶在<strong>交付那个时刻的最小成本</strong>就可以了。</p><p>那么交付时刻的成本是怎么计算的呢，是酸奶生产时的价格$C_j$，加上生产时刻$j$到交付时刻$i$的保存时长所产生的费用$S*(i-j)$</p><p>我们其实可以按周维护这个最小成本，比如说，第$i$周最小成本为$x$，那么第$i+1$周的最小成本，不是$x+s$就是$C_{i+1}$，则可以对最小成本进行更新$x=min(x+s,C_{i+1})$，每周按照更新的最小成本计算交付代价即可</p><h3 id="日光浴"><a href="#日光浴" class="headerlink" title="日光浴"></a>日光浴</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>有$C$头奶牛日光浴，第$i$头奶牛需要$minSPF_i$和$maxSPF_i$ 单位强度之间的阳光，第$i$头奶牛在日光浴之前必须涂抹防晒霜，一共有$L$种防晒霜，涂上第$i$种晒到身上的阳光强度就会稳定为$SPF_i$，第$i$种防晒霜有$t_i$瓶, 问最多可以满足多少头奶牛日光浴</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们先简化一下题意，题目的本质是用$C$个区间去匹配$L$种点，每种点有$t_i$个，最多能匹配几对</p><p>贪心问题很多都会涉及到区间，一般的处理方法是，先对区间进行排序（左端点，右端点，或者双关键字等）</p><p>这道题期望的是最多的奶牛能够日光浴，也就是说最多的区间被匹配，即<strong>区间等值</strong>，那我们先随便定一个顺序：从左到右去利用这些点匹配，那么区间排序要按照<strong>右端点从小到大</strong>排序，每次直接选取<strong>区间内最小</strong>的点去匹配</p><p>其实上述的语句就是这道题的题解了，为什么呢</p><ol><li>假设区间内两点坐标 x &lt; y，则随着区间右端点的递增，只会出现 x 不能匹配而 y 依然能匹配的情况，不会出现 y 不能匹配而 x 依然能匹配的情况，因此选择 x 更优</li><li>因为区间的被满足是等值的，因此能够匹配上就直接匹配，对答案贡献均为1</li></ol><p>如果难以理解，可以尝试画图，可能更容易理解区间之间的关系</p><h3 id="工作安排"><a href="#工作安排" class="headerlink" title="工作安排"></a>工作安排</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一共有N件工作，完成每件工作均只需要一单位时间，每件工作都有对应的Deadline和报酬，问能取得的最大报酬</p><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>先直接讲一下做法</p><p>按照Deadline进行排序，如果一个任务能够在Deadline之前被执行那么执行并得到其价值，当发现当前处理到的时间点迟于一个任务的Deadline，找到之前执行任务中价值比其小的价值最小的任务放弃，选择完成当前任务即可</p><p>可能你已经有点感觉，为什么可以替换任务呢，因为任务<strong>等价</strong>，这里的价指代价，即一单位时间。条件允许的情况下，相同的时间，可以用来换取更高的价值</p><p>这个替换操作，用优先队列(STL::priority_queue)维护选取的任务即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于等值性和等价性的贪心问题其实有不少，有的时候也会掺杂在其它的算法问题中作为一个子问题，用优先队列去做退流操作也比较常见 （有的情况甚至会需要双优先队列或者是更高级的数据结构来维护这种等值性），需要注意的是，等值并非只有单个点的替换，有时也会有多点等值替换的情况（BZOJ 2151）</p>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React学习记录：实现一个简单的评论系统</title>
      <link href="2020/11/17/react2/"/>
      <url>2020/11/17/react2/</url>
      
        <content type="html"><![CDATA[<h2 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h2><p>跟着教程开始做第一个React项目，教程见<a href="http://huziketang.mangojuice.top/books/react/">[react小书]</a></p><p>目标是实现如下图所示的一个评论系统</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-1.png"></p><h2 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h2><p>在React.js中所有的功能都是组件，因此我们要实现一个项目，首先要对项目进行组件的划分，任何可能复用到其它地方的部分，都可以抽离出来作为一个组件，我们对项目进行如下的组件划分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-2.png"></p><p>CommentApp组件表示整个评论的应用</p><p>CommentInput负责处理用户输入的区域</p><p>而Comment则负责每一条评论，通过CommetList组织</p><p>项目的组件树如图所示，我们按照组件树自上而下的原则来依次实现组件</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-3.png"></p><h2 id="组件框架"><a href="#组件框架" class="headerlink" title="组件框架"></a>组件框架</h2><p>首先我们用creat-react-app来创建一个项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creat-react-app comment-app</span><br></pre></td></tr></table></figure><p>在src的文件夹下创建四个组件的类文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line">    CommentApp.js</span><br><span class="line">    CommentInput.js</span><br><span class="line">    CommentList.js</span><br><span class="line">    Comment.js</span><br></pre></td></tr></table></figure><p>然后我们先自上而下地来实现前三个组件</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">CommentApp.js</button></li><li class="tab"><button type="button" data-href="#test-2">CommentInput.js</button></li><li class="tab"><button type="button" data-href="#test-3">CommentList.js</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CommentInput <span class="keyword">from</span> <span class="string">&#x27;./CommentInput&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CommentList <span class="keyword">from</span> <span class="string">&#x27;./CommentList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;CommentInput /&gt;</span><br><span class="line">                &lt;CommentList /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CommentApp</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;CommentInput&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CommentInput</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;CommentList&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CommentList</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在React中每个组件都必须从组件父类 Component 继承，并实现对应的render方法，返回组件的html结构，而这里并不像js中实现的返回html是个字符串，而是看起来就是html代码直接嵌入到js中，这种在Javascript中直接用标签写代码的语法叫JSX，JSX语法能够支持在js代码中编写类似html的语法，使得实现方便很多，在编译的过程中JSX结构会转化成Javascript的对象结构</p><p>需要注意的是，返回的必须是一个整体，也就是说如果你有两个div，得用一个div打包，然后作为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;CommentInput /&gt;</span><br><span class="line">    &lt;CommentList /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>JSX对象到页面的过程如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-4.png"></p><p>所以我们现在要做的事就是用ReactDOM将组件渲染到页面上，如下修改index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CommentApp <span class="keyword">from</span> <span class="string">&#x27;./CommentApp&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;CommentApp /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们就可以看到组件的简单架构了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-5.png"></p><p>然后加上一些简单的样式</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">CommentApp.js</button></li><li class="tab"><button type="button" data-href="#test-2">index.css</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span><br><span class="line">                &lt;CommentInput /&gt;</span><br><span class="line">                &lt;CommentList /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f1f1f1</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-6.png"></p><h2 id="评论输入组件"><a href="#评论输入组件" class="headerlink" title="评论输入组件"></a>评论输入组件</h2><p>我们先对组件CommentInput进行完善</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">CommentInput render返回值修改</button></li><li class="tab"><button type="button" data-href="#test-2">评论框样式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;comment-input&#x27;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;comment-field&#x27;</span>&gt;</span><br><span class="line">            &lt;span className=<span class="string">&#x27;comment-field-name&#x27;</span>&gt;用户名：&lt;/span&gt;</span><br><span class="line">            &lt;div className=<span class="string">&#x27;comment-field-input&#x27;</span>&gt;</span><br><span class="line">                &lt;input /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;comment-field&#x27;</span>&gt;</span><br><span class="line">            &lt;span className=<span class="string">&#x27;comment-field-name&#x27;</span>&gt;评论内容：&lt;/span&gt;</span><br><span class="line">            &lt;div className=<span class="string">&#x27;comment-field-input&#x27;</span>&gt;</span><br><span class="line">                &lt;textarea /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;comment-field-button&#x27;</span>&gt;</span><br><span class="line">            &lt;button&gt;</span><br><span class="line">                发布</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment-input</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f1f1f1</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="comment">/* 采用弹性盒子，默认不换行 */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field</span> <span class="selector-class">.comment-field-name</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field</span> <span class="selector-class">.comment-field-input</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field-input</span> <span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-class">.comment-field-input</span> <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e6e6e6</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="comment">/* 去除选中特效 */</span></span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">resize</span>: none;</span><br><span class="line">    <span class="comment">/* 子元素长度适配 */</span></span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field-input</span> <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field-button</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field-button</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00a3cf</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment-field-button</span> <span class="selector-tag">button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#13c1f1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-7.png"></p><p>看起来已经基本有个样子了，接下来我们要做的事情是把输入的文本记录到状态里面，方便之后在评论列表中显示</p><h3 id="记录状态"><a href="#记录状态" class="headerlink" title="记录状态"></a>记录状态</h3><p>在React.js中每个组件可以拥有自己的状态，通过state来记录</p><p>我们在class中加入构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        username: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改input标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value&#x3D;&#123;this.state.username&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>使得其值为username，textarea如法炮制，这时候输入区域和状态就绑定了，同时我们发现，我们没法在框内输入东西了，因为在react中所有的状态都是由state控制的，永远以被设置的值为准</p><p>如果希望用输入的值来更新state，则必须使用setState来更新组件的状态，那么要实现这个功能，做法是监听onChange，获取内容，用setState来更新state</p><p>先写一个改变状态的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleUsernameChange (event) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        username: event.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在input中加入监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">    value=&#123;<span class="built_in">this</span>.state.username&#125;</span><br><span class="line">    onChange=&#123;<span class="built_in">this</span>.handleUsernameChange.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>content的实现方法相同</p><p>这里用bind是因为，React中实例方法的this并不指向实例本身，因为React.js调用方法并非通过对象方法的方式调用而是直接通过函数调用，所以事件监听函数内不能通过this来获取实例，需要手动将实例方法bind到当前实例</p><h3 id="信息传递"><a href="#信息传递" class="headerlink" title="信息传递"></a>信息传递</h3><p>现在我们在CommentInput中记录了输入的状态，我们希望把信息传递到CommentList中渲染，这时候我们就要通过父组件来将两个组件联系起来，这个功能需要父组件向子组件传入一个回调函数，当用户点击发布按钮时，将state传入函数</p><p>这在React.js中是用props来实现的，每个组件都可以接受一个 props 参数，它是一个对象，包含了所有对这个组件的配置</p><p>我们在发布按钮上添加点击事件，加上对应的事件函数</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">添加点击事件</button></li><li class="tab"><button type="button" data-href="#test-2">事件函数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">    发布</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.props.onSubmit) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; username, content &#125; = <span class="built_in">this</span>.state</span><br><span class="line">        <span class="built_in">this</span>.props.onSubmit(&#123;username, content&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">content</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>这里我们只将content清除，保留state中的用户名，符合正常用户的使用习惯</p><p>然后我们在CommentApp上做一个测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleSubmitComment (comment) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(comment)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span><br><span class="line">                &lt;CommentInput</span><br><span class="line">                    onSubmit=&#123;<span class="built_in">this</span>.handleSubmitComment.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">                &lt;CommentList /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件成功获取了子组件的状态信息</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-8.png"></p><h2 id="评论与列表组件"><a href="#评论与列表组件" class="headerlink" title="评论与列表组件"></a>评论与列表组件</h2><p>接着我们来撰写评论和列表组件</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">评论组件</button></li><li class="tab"><button type="button" data-href="#test-2">评论css</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;comment&#x27;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&#x27;comment-user&#x27;</span>&gt;</span><br><span class="line">                    &lt;span&gt;&#123;<span class="built_in">this</span>.props.comment.username&#125; &lt;/span&gt;：</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="built_in">this</span>.props.comment.content&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Comment</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.comment</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#f1f1f1</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-class">.comment-user</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00a3cf</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>这里我们在列表中预设了comment数组方便测试效果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-9.png"></p><p>显示正常，接下来我们将数组替换成props传入的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.comments.map(<span class="function">(<span class="params">comment, i</span>) =&gt;</span></span><br><span class="line">                    &lt;Comment comment=&#123;comment&#125; key=&#123;i&#125; /&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意需要设置一个defaultProps，否则在没有comment传入的时候会报错</p><p>最后我们将这个部分和CommentApp联动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CommentInput <span class="keyword">from</span> <span class="string">&#x27;./CommentInput&#x27;</span></span><br><span class="line"><span class="keyword">import</span> CommentList <span class="keyword">from</span> <span class="string">&#x27;./CommentList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            comments: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleSubmitComment (comment) &#123;</span><br><span class="line">        <span class="built_in">this</span>.state.comments.push(comment)</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            comments: <span class="built_in">this</span>.state.comments</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;wrapper&#x27;</span>&gt;</span><br><span class="line">                &lt;CommentInput onSubmit=&#123;<span class="built_in">this</span>.handleSubmitComment.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">                &lt;CommentList comments=&#123;<span class="built_in">this</span>.state.comments&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> CommentApp</span><br></pre></td></tr></table></figure><p>就彻底完成了这个项目</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react2-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习记录：基本环境安装 (填坑记录)</title>
      <link href="2020/11/16/react1/"/>
      <url>2020/11/16/react1/</url>
      
        <content type="html"><![CDATA[<p>React.js并不能像D3.js一样直接在js里面包含一个文件即可，而是需要一堆工具和库来辅助，这里呢，有一个非常方便的工具<a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>，可以直接一键生成需要的工具目录，免去全家桶的安装和配置</p><p>根据官方文档先安装了creat-react-app</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p>接着就可以按照文档说明创建一个react工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="npm-start失败"><a href="#npm-start失败" class="headerlink" title="npm start失败"></a>npm start失败</h2><p>然后，执行到这一步的时候就挂了，npm start失败了，报错信息是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! code ELIFECYCLE</span><br></pre></td></tr></table></figure><p>在项目的Issues里面找到了这个问题的解决方案</p><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Following the steps</button></li><li class="tab"><button type="button" data-href="#test-2">If this has not helped</button></li><li class="tab"><button type="button" data-href="#test-3">If nothing else helps</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><ol><li>Delete package-lock.json (not package.json!) and/or yarn.lock in your project folder.</li><li>Delete node_modules in your project folder.</li><li>Remove “babel-loader” from dependencies and/or devDependencies in the package.json file in your project folder.</li><li>Run npm install or yarn, depending on the package manager you use.</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><ol start="5"><li>If you used npm, install yarn (<a href="http://yarnpkg.com/">http://yarnpkg.com/</a>) and repeat the above steps with it instead.This may help because npm has known issues with package hoisting which may get resolved in future versions.</li><li>Check if /Users/Dylan/myapp/node_modules/babel-loader is outside your project directory.For example, you might have accidentally installed something in your home folder.</li><li>Try running npm ls babel-loader in your project folder.This will tell you which other package (apart from the expected react-scripts) installed babel-loader.</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-3"><p>If nothing else helps, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project. That would permanently disable this preflight check in case you want to proceed anyway.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>结果是，都没有用</p><p>网上的解决方案也是如出一辙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Step1：npm cache clean --force</span><br><span class="line">Step2：rm -rf node_modules</span><br><span class="line">Step3：rm -rf package-lock.json</span><br><span class="line">Step4：npm install</span><br><span class="line">npm install 成功之后再次启动 npm start</span><br></pre></td></tr></table></figure><p>也没有效果，当时我是感觉，完蛋了，要去装React全家桶了，最后在<a href="https://stackoverflow.com/">stackoverflow</a>上找到了不太一样的答案</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react1-2.png"></p><p>我觉得应该是破案了，刚前几天做一个东西的时候把node.js版本从10.16更新到了12.0，大家的回复表示这个版本的node应该是会有一些奇怪的bug的，那现在需要的就是一个node.js的版本回退了</p><h2 id="nvm装完npm无效"><a href="#nvm装完npm无效" class="headerlink" title="nvm装完npm无效"></a>nvm装完npm无效</h2><p>想着node.js的版本可能以后还得切，所以干脆装个包管理工具，于是装了个nvm</p><p>surprise，新锅出现了，我的npm没了……</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react1-3.png"></p><p>这个问题好像就比较普遍了，但是错误原因也是花里胡哨的</p><p>最后是通过这个方法解决的：<a href="https://blog.csdn.net/fenfeidexiatian/article/details/96993384">[博客链接]</a></p><p>这个时候再start一下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react1-1.png"></p><p>看到这个react的图标，算是真的完成了环境搭建</p><p>在src文件中就是我们可以修改的页面了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/react1-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🎨React染坊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2016网络赛 青岛站 H XM Reserves [FFT建模]</title>
      <link href="2020/11/10/icpc2016netqdH/"/>
      <url>2020/11/10/icpc2016netqdH/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个方格图，每个点上都有一个值$p_{i,j}$，两个格子之间的距离d被定义为格点中心的欧氏距离，现在给出一个分数的定义，每个格点的分数被定义为所有距离在r以内的格点的p/(d+1)的值，求得分最大的格点的分数</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>基本做法是求解每个格点的分数，然后得到其中的最大值</p><p>所以对于每个$i$，需要求出$\sum_{d&lt;r}(\frac{p_{x_i-d_x,y_i-d_y}}{\sqrt{d_x^2+d_y^2}+1})$</p><p>所有需要对点$i$产生贡献的点$j$的坐标和偏移量$d$满足$x_j+d_x=x_i$，$y_j+d_y=y_i$</p><p>构造$A_{i∗M+j}=p_{i,j}$，$B_{d_x * M + d_y} = \frac{1}{\sqrt{d_x^2+d_y^2} +1}$</p><p>对于条件距离$r$可以在$B$的赋值时做判断处理</p><p>考虑到$d_x$和$d_y$的取值范围为$[R,-R]$，我们对偏移量做偏移处理</p><p>即$B_{(i + R) * M + j + R} = \frac{1}{\sqrt{i ^ 2 + j ^ 2} +1}$</p><p>则$A$和$B$的卷积$C_{(i + R) * M + j + R}$即格点$(i,j)$的得分</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2097152</span>;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">namespace</span> FFT &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i;</span><br><span class="line">    comp(<span class="keyword">double</span> _r = <span class="number">0</span>, <span class="keyword">double</span> _i = <span class="number">0</span>) : r(_r), i(_i) &#123;&#125;</span><br><span class="line">    comp <span class="keyword">operator</span>+(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r + x.r, i + x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>-(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r - x.r, i - x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>*(<span class="keyword">const</span> comp &amp;x) &#123;</span><br><span class="line">        <span class="keyword">return</span> comp(r * x.r - i * x.i, i * x.r + r * x.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">comp <span class="title">conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> comp(r, -i); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(comp a[], <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (pos[i] &gt; i) swap(a[i], a[pos[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; d) &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; d, m2 = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> o = pi * <span class="number">2</span> / m2 * t;</span><br><span class="line">        comp _w(<span class="built_in">cos</span>(o), <span class="built_in">sin</span>(o));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m2) &#123;</span><br><span class="line">            <span class="function">comp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                comp &amp;A = a[i + j + m], &amp;B = a[i + j], t = w * A;</span><br><span class="line">                A = B - t;</span><br><span class="line">                B = B + t;</span><br><span class="line">                w = w * _w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i].r /= n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace FFT</span></span><br><span class="line">FFT::comp A[N], B[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>, &amp;n, &amp;m, &amp;r)) &#123;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">ceil</span>(r), M = max(n + <span class="number">2</span> * R, m + <span class="number">2</span> * R);</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &lt; M * M) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = B[i] = FFT::comp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                A[i * M + j] = FFT::comp(x, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">auto</span> dis = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y); &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -R; i &lt;= R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = -R; j &lt;= R; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis(i, j) &lt; r)</span><br><span class="line">                    B[(i + R) * M + j + R] =</span><br><span class="line">                        FFT::comp(<span class="number">1.0</span> / (dis(i, j) + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = __builtin_ctz(N) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            pos[i] = pos[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i &amp; <span class="number">1</span>) &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">        FFT::FFT(A, N, <span class="number">1</span>);</span><br><span class="line">        FFT::FFT(B, N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) A[i] = A[i] * B[i];</span><br><span class="line">        FFT::FFT(A, N, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                ans = max(ans, A[(i + R) * M + j + R].r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIS2019论文整理(3)</title>
      <link href="2020/11/10/VIS2019-3/"/>
      <url>2020/11/10/VIS2019-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[V] VAST，[I] InfoVis，[S] SciVis </p></blockquote><p>VIS2019论文整理系列的最后一篇</p><p>之前的内容见：</p><p><a href="/2020/10/21/VIS2019-1/">[VIS2019论文整理(1)]</a></p><p><a href="/2020/11/02/VIS2019-2/">[VIS2019论文整理(2)]</a></p><hr><h2 id="Volume-Visualization"><a href="#Volume-Visualization" class="headerlink" title="Volume Visualization"></a>Volume Visualization</h2><div class="note default modern"><p><strong>[S] Void-and-Cluster Sampling of Large Scattered Data and Trajectories <a href="http://momentsingraphics.de/Media/Vis2019/Trapp2019-BlueNoiseSampling.pdf">[PDF]</a></strong></p></div><p>本文提出了一种基于统计抽样的分散数据的数据约简技术。该空隙和聚类采样技术找到一个代表子集，最优分布在空间领域的蓝色噪声。此外，它可以适应给定的密度函数，作者使用它来采样多变量值域中的高复杂度区域更多的人口。此外，该采样技术隐式地定义了样本的顺序，从而支持渐进式数据加载和连续的详细级别表示。并将技术扩展到采样时间依赖的轨迹，例如在一个时间间隔内的路径线，使用一种有效的迭代方法。此外，团队引入了一个局部和连续的误差度量来量化一组样本代表原始数据集的程度，在抽样时应用这个误差测量来指导抽样的数量。最后，作者团队使用这个误差度量和其他量来评估算法的质量、性能和可扩展性。</p><div class="note default modern"><p><strong>[S] FeatureLego: Volume Exploration Using Exhaustive Clustering of Super-Voxels <a href="https://arxiv.org/pdf/1810.05220">[PDF]</a></strong></p></div><p>本文提出了一个体积探索框架，FeatureLego，它使用一种新的体素聚类方法来有效地选择语义特征。团队将输入量划分为一组紧凑的超级体素，它们代表了最佳的选择粒度。然后使用基于图的聚类方法对这些超级体素进行详尽的聚类。与常用的参数采样方法不同，本文提出了一种有效的算法来执行这种穷举聚类。通过计算一组详尽的集群，目标是捕获尽可能多的边界，并确保用户有足够的选项来有效地选择语义相关的特征。此外，作者团队将所有经过计算的集群合并到一个元集群树中，该元集群可以用于分层探索。团队实现了一个直观的用户界面，使用本文的集群方法交互地探索卷。最后，在多个不同模式的真实数据集上展示了框架的有效性</p><div class="note default modern"><p><strong>[S] Interactive Visualization and On-Demand Processing of Large Volume Data: A Fully GPU-Based Out-Of-Core Approach  <a href="https://hal.univ-reims.fr/hal-01705431/document">[PDF]</a></strong></p></div><p>在广泛的科学领域，3D数据集的生产能力近年来得到了广泛的发展，特别是随着其规模的快速增长。因此，许多大型应用程序，包括可视化或处理，都变得难以处理。解决这个问题的一个办法是提供核外算法，专门设计来处理比内存大得多的数据集。</p><p>本文提出了一种新的方法，它扩展了在gpu上的核外体积渲染领域中已经建立的广泛的交互式寻址原则，以允许在可视化阶段进行按需处理。本文提出设计一个管道，用于管理数据作为规则的3D网格，而不考虑底层的应用程序。它依赖于缓存方法与虚拟内存寻址系统耦合到GPU上的有效并行管理，以在交互时间提供有效的访问数据。它允许任何可视化或处理应用程序通过管理多模态数据集来利用其结构的灵活性。此外，作者证明，系统在单一标准PC上提供了良好的性能与GPU低内存预算</p><hr><h2 id="Geovisualization"><a href="#Geovisualization" class="headerlink" title="Geovisualization"></a>Geovisualization</h2><div class="note default modern"><p><strong>[V] A Visual Analytics System for Exploring, Monitoring, and Forecasting Road Traffic Congestion <a href="https://chungyi347.github.io/file/TVCG2019.pdf">[PDF]</a></strong></p></div><p>本文提出了一个交互式的视觉分析系统，用于交通拥堵的探索，监视和预测基于车辆检测数据。通过领域专家的协作，团队提取了任务需求，合并了长时间的需求利用短时记忆模型进行拥塞预测，并设计了一种加权方法来检测拥塞产生的原因和拥塞的传播方向。本文的视觉分析系统旨在使用户探索拥堵的原因、方向和严重程度。一个城市的拥堵情况使用容积-速度河流(VSRivers)可视化，同时显示交通量和速度。为了评估系统，团队报告性能比较结果，其中本文的模型比其他预测算法更准确。本文通过三个案例研究和领域专家反馈来证明系统在交通管理和拥塞广播领域的有用性</p><div class="note default modern"><p><strong>[V] Semantics-Space-Time Cube: A Conceptual Framework for Systematic Analysis of Texts in Space and Time <a href="http://openaccess.city.ac.uk/21109/1/semantics-space-time.R1.pdf">[PDF]</a></strong></p></div><p>本文提出了一种分析数据的方法，其中文本与空间和时间参考相关联，目的是了解文本语义如何随时间和空间变化。为了表示语义，采用概率主题建模。在提取一组代表文本主题和主题权重向量后，团队汇总数据与对应的维度数据立方体的话题，空间位置的集合(例如，区域)，和时间分成合适的间隔根据计划的规模分析。每个多维数据集单元格对应于一个组合(主题、位置、时间间隔)，并包含用于描述与此主题相关的文本子集的聚合度量，并在这些位置和间隔内拥有空间和时间引用。在此基础上，系统地描述了分析任务的空间，探讨了语义、空间和时间这三个异构信息面之间的相互关系。本文介绍了立方体的投影和切片操作，这些操作用于将复杂任务分解为较简单的子任务。然后，展示了可视化分析系统的设计，旨在支持这些子任务。为了降低用户界面的复杂性，本文应用了结构、视觉和操作一致性的原则，同时尊重每个方面的具体属性。聚合的数据以三个平行视图表示，它们对应于这三个方面，并提供数据的不同互补视图。在方面细节允许的范围内，视图具有相似的外观和感觉。适用于任何视图的统一交互操作支持在facet之间建立链接。均匀性原理也应用于支持数据立方体上的投影和切片操作。本文通过将其应用于两种分析场景来评估该方法的可行性和实用性，使用地理定位的社交媒体数据来研究人们对不同时空尺度的社会和自然事件的反应。</p><hr><h2 id="Ensembles-amp-Uncertainty"><a href="#Ensembles-amp-Uncertainty" class="headerlink" title="Ensembles &amp; Uncertainty"></a>Ensembles &amp; Uncertainty</h2><div class="note default modern"><p><strong>[I] Uncertainty-Aware Principal Component Analysis <a href="https://arxiv.org/pdf/1905.01127">[PDF]</a></strong></p></div><p>本文提出了一种技术，对受不确定性影响的数据进行降维。该方法是对传统主成分分析(PCA)的推广，以多元概率分布。与非线性方法相比，线性降维技术具有投影后概率分布特征保持不变的优点。团队推导了基于每个输入的潜在不确定性的主成分分析样本协方差矩阵的表示，为新方法——不确定性感知主成分分析——建立了数学基础。除了通过基于采样策略的方法获得的准确性和性能之外，公式允许数据中的不确定性进行敏感性分析。为此，作者建议将因子轨迹作为一种新颖的可视化方法，能够更好地理解不确定性对所选主成分的影响。本文提供了多个使用真实数据集的技术示例。作为一个特例，本文展示了如何通过闭形式的PCA来传播多元正态分布。此外，讨论了方法的扩展和局限性</p><div class="note default modern"><p><strong>[S] A Structural Average of Labeled Merge Trees for Uncertainty Visualization <a href="https://arxiv.org/pdf/1908.00113">[PDF]</a></strong></p></div><p>科学和工程中的物理现象经常用标量场来建模。在标量场拓扑中，常用基于图的拓扑描述符，如归并树、轮廓树和Reeb图来表征标量场(子)层集合的拓扑变化。推进基于拓扑的可视化的最大挑战和机遇之一是理解并将不确定性纳入到这种拓扑描述符中，从而有效地推断其基础数据</p><p>本文研究了一组标记合并树的结构平均，并利用它对数据中的不确定性进行编码。具体地说，计算一个1-中心树，它在一个定义良好的度量称为交错距离的条件下最小化它与集合中任何其他树的最大距离，本文提供启发式策略来计算标签不完全一致的合并树的结构平均值，进一步提供了一个交互式可视化系统，它类似于一个数字计算器，以一组合并树作为输入，并输出一棵树作为它们的结构平均值。还强调了输入和平均值之间的结构相似性，并将不确定性信息用于视觉探索。通过输入树的度量空间视图，团队开发了一种新的不确定性度量，称为一致性。最后，通过从标量域集合中产生的合并树演示了框架的应用。本文的工作是第一个使用交叉距离和一致性来研究一个全局的，数学上严格的，不确定性可视化背景下的结构平均归并树</p><div class="note default modern"><p><strong>[S] Multiscale Visual Drilldown for the Analysis of Large Ensembles of Multi-Body Protein Complexes <a href="https://arxiv.org/pdf/1907.04112">[PDF]</a></strong></p></div><p>在研究多体蛋白质复合物时，生物化学家使用计算工具，可以提出数百或数千种可能的空间构型。然而，这难以被实验验证</p><p>本文提出了一种新的多尺度视觉钻取方法，该方法是与蛋白质组学专家紧密合作设计的，能够系统地探索构型空间。本文的方法利用了数据的层次结构——从蛋白质复杂构型的整个集合到单个构型，它们的接触界面，以及相互作用的氨基酸。本文的新解决方案基于交互链接的2D和3D视图，在每个层次上，提供一组选择和过滤操作，使用户能够缩小需要手动检查的配置数量。此外，团队提供了一个专用的过滤界面，它为用户提供了应用过滤操作的概述，并使他们能够检查它们对已探索的集成的影响。通过这种方式，维护了探索过程的历史，从而使用户能够返回到探索的早期点。本文通过与蛋白质组学专家合作进行的两个案例研究证明了方法的有效性。</p><div class="note default modern"><p><strong>[S] eFESTA: Ensemble Feature Exploration with Surface Density Estimates <a href="https://www.mcs.anl.gov/~hguo/publications/HeGSP19-small.pdf">[PDF]</a></strong></p></div><p>本文提出地表密度估计(SDE)来模拟三维集成模拟数据中的地表特征(等值面、山脊面和流面)的空间分布。SDE计算的输入为以多边形网格表示的地物，不需要场数据集(例如标量场或向量场)。SDE定义为输入曲面上无穷多点集的核密度估计，通过累积三角形斑块的表面密度来逼近。本文还提出了一个算法来指导选择合适的核带宽进行SDE计算。提出了基于表面密度估计(eFESTA)的探测方法来提取和可视化集成地物的主要趋势。对于表面特征的集合，每个表面首先根据其对SDE的贡献转换成密度场，然后根据密度场之间的成对距离将密度场组织成层次表示。然后使用分层表示法来指导密度场以及下垫面特征的视觉探索。本文证明了方法在系综标量场中的应用，不确定非定常流中的拉格朗日相干结构，以及系综流体流中的流面。</p><div class="note default modern"><p><strong>[S] Visualization and Visual Analysis of Ensemble Data: A Survey <a href="https://vis.uib.no/wp-content/papercite-data/pdfs/Kehrer13VisualizationAnd.pdf">[PDF]</a></strong></p></div><p>可视化和可视化分析在探索、分析和呈现科学数据方面发挥着重要作用。在许多学科中，数据和模型场景正变得多面化:数据常常是时空和多变量的;它们来自不同的数据源(多模态数据)，来自多个模拟运行(多运行/集成数据)，或者来自交互现象的多物理模拟(耦合模拟模型产生的多模型数据)。此外，数据可以具有不同的维度，或者在各种类型的网格上结构化，这些网格需要在可视化中关联或融合。数据特征的这种异质性为可视化研究带来了新的机遇和技术挑战。因此，可视化和交互技术经常与计算分析相结合。在本调查中，团队研究现有的方法可视化和交互式视觉分析的多面科学数据。基于一个彻底的文献回顾，一个分类的方法被提出。本文涵盖了广泛的领域，并讨论了不同的挑战在何种程度上与可视化和可视化分析的现有解决方案相匹配。这就引出了关于有前途的研究方向的结论，例如，为多运行和多模型数据寻求新的解决方案，以及支持多个方面的技术</p><div class="note default modern"><p><strong>[V] Exploring the Sensitivity of Choropleths under Attribute Uncertainty <a href="https://zhaosongh.github.io/publication/GeoUncertainty.pdf">[PDF]</a></strong></p></div><p>choropleth地图是空间数据分析的重要工具。然而，空间单元的基本属性值对生成choropleth地图的统计分析和地图分类过程有很大的影响。如果属性值包含一系列的不确定性，一个关键的任务就是确定不确定性对地图可视化和统计分析的影响有多大。</p><p>本文提出了一个可视化分析系统，它增强了对属性不确定性对数据可视化和数据统计分析的影响的理解。该系统包括基于平行坐标的不确定度规范视图、基于区域和基于仿真分析的冲击河和冲击矩阵可视化，以及用于可视化属性值不确定性范围内分类和空间自相关变化的双索线图和t-SNE图。本文通过三个用例来说明属性不确定性对地理分析的影响</p><hr><h2 id="Interactive-Machine-Learning"><a href="#Interactive-Machine-Learning" class="headerlink" title="Interactive Machine Learning"></a>Interactive Machine Learning</h2><div class="note default modern"><p><strong>[I] Illusion of Causality in Visualized Data <a href="https://zhaosongh.github.io/publication/GeoUncertainty.pdf">[PDF]</a></strong></p></div><p>经常吃早餐的学生平均分往往更高。从这些数据中，许多人可能会自信地说，上学前的早餐计划会带来更高的分数。这是一个推理错误，因为相关性并不一定表明因果关系——X和Y可以相互关联，而不直接导致另一个。虽然这种错误是普遍存在的，但它的普遍性可能会被放大或缓解的方式的数据呈现给观众。通过三个众包实验，作者团队检验了简单的数据关系如何被呈现，是否会减少这种推理错误。第一个实验测试了类似于早餐- gpa关系的例子，但因果关系的似然性有所不同。让参与者评价他们对相关关系的认同程度，他们认为这是适当的高。然而，参与者也对数据的因果解释表示高度一致。对因果解释的支持程度在各种可视化类型中并不相同:文本描述和柱状图的因果关系评分最高，但散点图的因果关系评分较低。但是，这种效果是由条形图将数据聚合为两组驱动的，还是由视觉编码类型驱动的呢? 本文分离了数据聚合和视觉编码类型，并检查了他们各自对感知因果关系的影响。总的来说，不同的可视化设计对相同的数据提供不同的认知推理启示。高水平的图表数据聚集往往与较高的感知因果关系的数据。参与者认为线和点的视觉编码比条形编码更具有因果性。研究结果表明，一些可视化设计是如何触发更强的因果关系的，而选择其他的可以帮助减轻对因果关系的不合理的看法。</p><div class="note default modern"><p><strong>[V] Ablate, Variate, and Contemplate: Visual Analytics for Discovering Neural Architectures <a href="https://arxiv.org/pdf/1908.00387">[PDF]</a></strong></p></div><p>深度学习模型需要多个层次和参数的配置，才能获得较好的效果。然而，目前很少有关于如何配置成功模型的系统指导方针。这意味着模型构建者通常必须通过手工编程不同的架构(这是乏味和耗时的)来试验不同的配置，或者依赖于纯自动化的方法来生成和培训架构(这是昂贵的)。</p><p>在本文中，作者团队对模型架构和参数，或REMAP，一个可视化分析工具，允许模型构建者通过探索和快速实验的神经网络架构快速发现深度学习模型。在REMAP中，用户使用全局检查和局部实验相结合的方法来探索神经网络结构的大而复杂的参数空间。通过一组模型的可视化概述，用户可以识别出感兴趣的架构集群。基于他们的发现，用户可以运行消融和变化实验，以确定在给定架构中添加、删除或替换层的影响，并相应地生成新的模型。他们还可以使用简单的图形界面手工制作新的模型。因此，模型构建器可以快速、高效地构建深度学习模型，而无需手工编程。团队通过四名深度学习模型构建器的设计研究来设计REMAP。本文通过一个用例演示了REMAP允许用户通过模型空间使用视觉探索和用户定义的半自动搜索有效地发现性能神经网络架构</p><div class="note default modern"><p><strong>[V] VASSL: A Visual Analytics Toolkit for Social Spambot Labeling <a href="https://arxiv.org/pdf/1907.13319">[PDF]</a></strong></p></div><p>社交媒体平台充斥着社交垃圾邮件。检测这些恶意帐户是必要的，但具有挑战性，因为他们不断演变，以逃避检测技术</p><p>本文介绍了VASSL，一个可视化分析系统，可以帮助检测和标记垃圾邮件机器人。该工具提供了多个连接视图，并利用维数减少、情感分析和主题建模，从而提高了人工标记的性能和可伸缩性，从而为识别垃圾邮件机器人提供了洞察。该系统允许用户以交互的方式选择和分析帐户组，从而能够检测到在单独检查时可能无法识别的垃圾邮件机器人。本文提出了一项用户研究，以客观地评估VASSL用户的性能，以及获取关于工具的有用性和易用性的主观意见。</p><div class="note default modern"><p><strong>[V] Visual Interaction with Deep Learning Models through Collaborative Semantic Inference <a href="https://arxiv.org/pdf/1907.10739">[PDF]</a></strong></p></div><p>当人类在决策过程中失去代理权时，任务的自动化会产生重要的后果。深度学习模型尤其容易受到影响，因为目前的黑箱方法缺乏可解释的推理。作者认为，深度学习系统的视觉界面和模型结构都需要考虑交互设计。本文提出了一个协作语义推理(CSI)框架，用于交互和模型的协同设计，以实现人与算法之间的可视化协作。该方法揭示了模型的中间推理过程，允许与问题的可视隐喻进行语义交互，这意味着用户可以理解和控制模型推理过程的各个部分。文章中通过一个共同设计的文件摘要系统的案例研究来论证CSI的可行性</p><div class="note default modern"><p><strong>[V] ICE: An Interactive Configuration Explorer for High Dimensional Parameter Spaces <a href="https://arxiv.org/pdf/1907.12627">[PDF]</a></strong></p></div><p>在许多应用程序中，用户试图探索几个分类变量的设置对一个因变量的影响。例如，计算机系统分析人员可能希望研究文件系统或存储设备的类型如何影响系统性能。一种常用的方法是采用并行集的方法来可视化多元范畴变量。然而，作者发现参数对数值变量的影响程度在这里不容易观察到。团队也尝试了一种基于多重对应分析的降维方法，但发现svd生成的2D布局导致了信息的丢失。因此，本文提出了一种新的方法，交互式配置浏览器(ICE)，它直接解决了分析人员了解因变量如何受到给定多个优化目标的参数设置的影响的需求。没有任何信息丢失，因为ICE显示了在每个分类变量的背景下的因变量的完整分布和统计。分析人员可以交互地过滤变量，以优化特定的目标，如实现一个具有最大性能、低方差等的系统。本文的系统是在与一组系统性能研究人员的紧密合作下开发的，它的最终有效性是通过专家访谈、比较用户研究和两个案例研究来评估的。</p><div class="note default modern"><p><strong>[V] Interactive Correction of Mislabeled Training Data  <a href="http://shixialiu.com/publications/datadebugger/paper.pdf">[PDF]</a></strong></p></div><p>在本文中，团队开发了一种可视化的分析方法来交互地提高标记数据的质量，这对于监督和半监督学习的成功至关重要。通过使用用户选择的可信项来提高质量。为了精确匹配可信项的标签，使训练损失最小化，团队采用了双层优化模型。在此基础上，开发了一种可扩展的数据校正算法，有效地处理成千上万的标注数据。增加的tSNE有助于可信项的选择，提高了计算效率和布局稳定性，确保不同级别之间的平稳过渡。通过定量评价和案例研究，在真实数据集上评估了本文的方法，结果普遍良好。</p><hr><h2 id="Infographics-amp-Storytelling"><a href="#Infographics-amp-Storytelling" class="headerlink" title="Infographics &amp; Storytelling"></a>Infographics &amp; Storytelling</h2><div class="note default modern"><p><strong>[I] Text-to-Viz: Automatic Generation of Infographics from Natural Language Statements <a href="https://arxiv.org/pdf/1907.09091">[PDF]</a></strong></p></div><p>通过将数据内容与视觉装饰结合起来，信息图可以有效地以一种引人入胜、令人难忘的方式传递信息。各种创作工具已经被提议来促进信息图的创建。然而，使用这些创作工具创建专业的信息图仍然不是一件容易的任务，需要大量的时间和设计专业知识。因此，这些工具通常对普通用户没有吸引力，他们要么不愿意花时间学习这些工具，要么缺乏创建专业信息图的设计专业知识</p><p>在本文中，探索了一种替代的方法:从自然语言语句中自动生成信息图。首先对信息图的设计空间进行了初步的研究。在初步研究的基础上，建立了一个概念证明系统，该系统可以自动地将简单的比例相关统计信息转换为一组预先设计样式的信息图。最后，通过样本结果、展示和专家评审来演示系统的可用性和有用性。</p><div class="note default modern"><p><strong>[I] Towards Automated Infographic Design: Deep Learning-based Auto-Generation of Extensible Timeline <a href="https://arxiv.org/pdf/1907.13550">[PDF]</a></strong></p></div><p>设计人员在创建信息图时，不仅要考虑感知效果，还要考虑视觉风格。对于专业设计师来说，这个过程既困难又耗时，更不用说非专业用户了，这就导致了对自动信息图设计的需求。作为第一步，本文关注时间线信息图，它已经被广泛使用了几个世纪。本文提供了一种端到端的方法，可以从位图图像中自动提取可扩展的时间轴模板。本文的方法采用了解构和重构的范式。在解构主义阶段，本文提出一个多任务同时深层神经网络解析两种类型的信息从位图时间表:1)全球信息，即表示，规模、布局，和方向的时间表，和2)当地的信息，例如，位置、类别、像素时间轴上的每一个视觉元素。在重构阶段，本文提出了三种技术的管道，即非最大合并、冗余利用解构结果，从信息图中提取可扩展模板。为了评估方法的有效性，本文合成了一个时间轴数据集(4296幅图像)，并从互联网上收集了一个真实的时间轴数据集(393幅图像)。本文首先报告定量评估结果，方法在两个数据集。然后，给出了自动提取模板和基于这些模板自动生成时间线的例子，以定性地展示性能。结果表明，本文方法可以有效地从现实的时间轴信息图中提取可扩展模板</p><div class="note default modern"><p><strong>[V] EmoCo: Visual Analysis of Emotion Coherence in Presentation Videos <a href="https://arxiv.org/pdf/1907.12918">[PDF]</a></strong></p></div><p>情感在人类交流和公众演讲中扮演着关键的角色。人类的情感通常是通过多种方式表达的。因此，探索多模态情绪及其连贯性，对于理解表达中的情绪表达，提高表达技巧具有重要价值。然而，手动观看和学习演示视频往往是乏味和费时的。缺乏工具的支持来帮助进行有效和深入的多层次分析。因此，本文中介绍了EmoCo，一个交互式的视觉分析系统，以促进高效的分析情绪连贯性的面部，文本和音频模式的演示视频。该可视化系统具有通道连贯视图和句子聚类视图，这两个视图共同使用户能够快速获得情感连贯及其时间演化的概况。此外，细节视图和词视图可以分别从句子层次和词层次进行详细的探索和比较。本文通过基于TED Talk视频的两个使用场景和与两位领域专家的访谈，对提出的系统和可视化技术进行了全面的评估。结果证明了系统在理解表达中的情感连贯性方面的有效性。</p><div class="note default modern"><p><strong>[V] Multimodal Analysis of Video Collections: Visual Exploration of Presentation Techniques in TED Talks <a href="https://awuac.student.ust.hk/pdf/2018VisTED.pdf">[PDF]</a></strong></p></div><p>虽然许多教育领域的研究已经揭示了许多演示技巧，但它们经常是重叠的，有时甚至是矛盾的。探索在TED演讲中使用的演示技巧可以为实际指导提供证据。本研究旨在探讨从TED演讲中收集的语言和非语言表达技巧。然而，这种分析具有挑战性，因为分析由帧图像、文本和元数据组成的多模态视频集合非常困难。本文提出了一种视频集合中多模态内容的可视化分析系统。该系统具有三种不同层次的视图:带有新颖符号的投影视图，便于对表示风格进行聚类分析;比较视图显示时间分布和表示技术的并发性，支持聚类内分析;以及视频视图，以实现对视频的情境化探索。作者团队与语言教育专家和大学生一起进行案例研究，为方法的有效性提供轶事证据，并报告有关TED演讲中演讲技巧的新发现。来自用户研究的定量反馈证实了本文的视觉系统对视频采集的多模态分析的有用性</p><div class="note default modern"><p><strong>[V] Supporting Story Synthesis: Bridging the Gap between Visual Analytics and Storytelling <a href="http://geoanalytics.net/and/papers/tvcg19-storySynthesis.pdf">[PDF]</a></strong></p></div><p>视觉分析通常处理复杂的数据，并使用复杂的算法、视觉和交互技术来支持分析。分析的结果和结果通常需要向缺乏视觉分析专业知识的受众进行交流。这要求分析结果以比通常在视觉分析系统中使用的更简单的方式呈现。然而，不仅分析性可视化对于目标受众来说过于复杂，而且需要呈现的信息也过于复杂。分析结果可能由多个组件组成，这些组件可能涉及多个异构方面。因此，在从获得分析结果到传达分析结果的过程中存在着差距，其中存在两个主要的挑战:信息复杂性和显示复杂性。</p><p>为了解决这个问题，本文提出了一个通用框架，在这个框架中，数据分析和结果展示通过故事合成连接起来，在这个框架中，分析师创建并组织故事内容。与以前的研究不同，在以前的研究中，分析结果由存储的显示状态表示，作者将其视为数据构造。本文专注于选择、聚集和组织研究结果以进行进一步的展示，而不是跟踪分析历史和启用数据显示的双重(即探索性和交流性)使用。在故事合成中，研究结果被选择、组合和安排在有意义的布局中，这些布局考虑到信息的结构及其组成部分的内在属性。本文提出了一个工作流，用于在设计视觉分析系统时应用所提出的概念框架，并通过将其应用于两个不同的领域(社交媒体和运动分析)来演示该方法的通用性</p><hr><h2 id="Visualization-in-Medicine"><a href="#Visualization-in-Medicine" class="headerlink" title="Visualization in Medicine"></a>Visualization in Medicine</h2><div class="note default modern"><p><strong>[I] CerebroVis: Designing an Abstract yet Spatially Contextualized Cerebral Arteries Network Visualization <a href="https://arxiv.org/pdf/1907.12663">[PDF]</a></strong></p></div><p>人类大脑中的血液循环是通过大脑动脉网络提供的。如果临床医生怀疑病人有中风或其他脑血管疾病，他们会要求进行影像学检查。神经放射学家会对扫描结果进行视觉检查，看是否有异常。它们的视觉搜索任务对应于浏览和路径跟踪等抽象的网络分析任务。</p><p>为了协助神经放射学家识别脑动脉异常，本文设计了一种新的脑动脉网络可视化抽象方法——脑动脉网络可视化。在这项设计研究中，团队根据网络理论对大脑动脉系统提出了一个新的框架和定义，并将神经放射学家的领域目标描述为抽象的可视化和网络分析任务。通过一个迭代的，以用户为中心的设计过程，团队开发了一种抽象的网络布局技术，它结合了大脑动脉的空间脉络。抽象可视化能够提高三维几何表示的域任务性能，而包含空间上下文有助于保存用户对底层几何图形的心理映射。团队提供了网络布局技术和脑动脉可视化工具原型的开源实现。通过成功地布置出61个开源大脑扫描来证明技术的健壮性。本文通过与三位神经放射学家的混合方法研究来评估布局的有效性。在形成性对照实验中，研究参与者使用脑血管成像和传统3D可视化检查真实的脑动脉成像数据，以确定模拟颅内动脉狭窄。参与者更准确地识别狭窄使用脑血管病(绝对危险差13%)</p><div class="note default modern"><p><strong>[S] Cohort-based T-SSIM Visual Computing for Radiation Therapy Prediction and Exploration <a href="https://arxiv.org/pdf/1907.05919">[PDF]</a></strong></p></div><p>本文描述了一种基于队列患者空间相似性的放射治疗(RT)计划的视觉计算方法。在头颈部癌症的放射治疗中，肿瘤周围危险器官的剂量是造成治疗毒性的主要原因。随着患者资源库的可用性，这种情况使得临床医生有兴趣基于以前治疗过的类似患者来理解和预测RT结果。为了实现这类分析，本文引入了一种新的基于拓扑的空间相似度度量T-SSIM，以及基于这种相似度度量的预测算法。将算法与视觉导向界面相结合，该界面将空间数据和统计结果的视觉编码交织在一起，包括一种新颖的可感知空间的平行标记编码。本文报告了165名患者队列的定量结果，以及与正在远程合作的放射肿瘤学、数据管理、生物统计学和医学影像领域专家的定性评估。</p><div class="note default modern"><p><strong>[S] DeepOrganNet: On-the-Fly Reconstruction and Visualization of 3D / 4D Lung Models from Single-View Projections by Deep Deformation Network <a href="https://arxiv.org/pdf/1907.09375">[PDF]</a></strong></p></div><p>本文介绍了一种基于深度神经网络的方法，即DeepOrganNet，来实现完全高保真度的生成和可视化基于复杂背景的单视图医学图像的3D/4D器官几何模型。统的3D / 4D医学图像重建需要近数百个投影，这将耗费难以忍受的计算时间，并给人体受试者带来令人不快的高成像/辐射剂量。此外，后续要分割或提取出准确的三维器官模型，还需要进一步操作。减少投影次数可以减少计算时间和成像剂量，但重构图像的质量会相应下降。</p><p>据本文作者所知，目前还没有一种方法可以直接、明确地从一幅二维医学灰度图像中实时重建多个三维器官网格。对于单视图的二维医学图像，如3D / 4D-CT投影或x射线图像，本文的端到端深度网络框架可以有效地重建图像，通过学习基于三元张量积变形技术的多个模板的平滑变形场，利用从输入的二维图像中提取的具有信息的潜在描述符，建立具有各种几何形状的3D/4D肺模型。该方法能够保证3D/4D肺模型生成高质量、高保真度的多种网格;而目前所有基于单一图像形状重建的深度学习方法都不能。这项工作的主要贡献是在二维单视图投影中精确地重建三维器官形状，显著地提高了实现实时可视化的程序时间，并显著地降低了人体受试者的成像剂量。实验结果评估和比较与传统的重建方法和先进的深度学习，通过使用广泛的3D和4D示例，包括合成的幻影和真实的患者数据集。该方法在实时图像引导放射治疗(IGRT)中具有很大的应用潜力，只需数毫秒即可生成顶点为10K的器官网格。在实时图像引导放射治疗(IGRT)中有很大的应用潜力</p><div class="note default modern"><p><strong>[V] Motion Browser: Visualizing and Understanding Complex Upper Limb Movement Under Obstetrical Brachial Plexus Injuries <a href="https://arxiv.org/pdf/1907.09146">[PDF]</a></strong></p></div><p>臂丛是一个复杂的外周神经网络，它能够感知和控制手臂和手的运动。如今，肌肉之间产生简单运动的协调性仍然没有被很好地理解，阻碍了如何最好地治疗这类周围神经损伤患者的知识的探索。为了获得足够的信息用于医疗数据分析，医生对患者进行运动分析评估，以产生丰富的数据集，这些数据来自于真实任务中记录的多个关节运动的肌肉。但是，目前还没有以简洁和可解释的方式分析和可视化数据的工具。由于无法在一个平台上集成、比较和计算多个数据源，医生只能通过简单的统计值来模糊地描述患者的行为，从而限制了回答临床问题和生成研究假设的可能性。为了应对这一挑战，本文提出了运动浏览器，一个交互式的视觉分析系统，它提供了一个有效的框架来提取和比较肌肉活动模式从病人的四肢和协调视图，以帮助用户分析肌肉信号，运动数据和视频信息，以解决不同的任务。该系统是计算机科学家、骨科医生和康复医生共同努力的结果。目前的案例研究表明，医生可以利用这些信息来理解个体如何协调他们的肌肉来发起适当的治疗，并为未来的研究产生新的假设。</p><hr><h2 id="Words-amp-Documents"><a href="#Words-amp-Documents" class="headerlink" title="Words &amp; Documents"></a>Words &amp; Documents</h2><div class="note default modern"><p><strong>[V] LDA Ensembles for Interactive Exploration and Categorization of Behaviors <a href="http://openaccess.city.ac.uk/21875/1/LDA_Ensembles_for_Interactive_Exploration_and_Categorization_of_Behaviors.pdf">[PDF]</a></strong></p></div><p>本文将行为定义为某个参与者在一段时间内执行的一组动作。考虑分析多个参与者的大量行为集合的问题，更具体地说，识别典型行为和发现异常行为。文中提出了一种利用主题建模技术——LDA(潜在Dirichlet分配)集合——来表示通过对行为集合进行主题建模而获得的典型行为类别。当将这些方法应用于自然语言文本时，通常根据与主题相关的术语的语义相关性来判断所提取主题的质量。然而，这个标准并不一定适用于从非文本数据中提取的主题，比如动作集，因为动作之间的关系可能并不明显。</p><p>本文开发了一套可视化和交互式技术，支持基于其他标准(如行为集的独特性和覆盖范围)构建适当的主题组合。两个分析安全管理系统运行行为和游乐园参观行为的案例，以及专家对第一个案例的评价证明了方法的有效性</p><div class="note default modern"><p><strong>[I] ShapeWordle: Tailoring Wordles using Shape-aware Archimedean Spirals <a href="http://www.yunhaiwang.net/infoVis2019/shapewordle/shapewordle.pdf">[PDF]</a></strong></p></div><p>本文提出了一种新技术，可以创造形状为界的文字，作者称其为ShapeWordle，可以把文字变成一个给定的形状。为了在形状内指导单词的放置，本文扩展了传统的阿基米德螺旋，通过使用形状的距离场以差分形式表示螺旋，使其具有形状感知能力。为了处理非凸形状，本文引入了一种多中心Wordle布局方法，该方法将形状分割成可感知形状的螺旋部分，以自适应地填充空间并生成单词位置。此外，还提供了一组编辑交互，以方便创建语义上有意义的文字。最后，文中提供了三个评价: 比较本文的结果与最先进的技术(WordArt)，14个用户的案例研究，以及一个展示技术覆盖范围的画廊</p><div class="note default modern"><p><strong>[V] Semantic Concept Spaces: Guided Topic Model Refinement using Word-Embedding Projections <a href="http://kops.uni-konstanz.de/bitstream/handle/123456789/47042/El-Assady_2-112hj6g6w8rj81.pdf?sequence=1&isAllowed=y">[PDF]</a></strong></p></div><p>本文提供了一个框架，该框架允许用户合并他们的领域知识的语义来细化主题模型，同时保持模型不可知。该方法使用户能够(1)理解模型的语义空间，(2)识别潜在冲突和问题的区域，(3)根据概念的理解重新调整概念的语义关系，直接影响主题建模。这些任务由交互式可视化分析工作空间支持，该工作空间使用文字嵌入投影来定义概念区域，然后可以细化概念区域。用户改进的概念独立于特定的文档集合，可以转移到相关的语料库中。概念空间内的所有用户交互直接影响基础向量空间模型的语义关系，进而改变主题建模。除了直接操作之外，本文的系统通过推荐的交互来指导用户的决策过程，指出潜在的改进。他的目标细化旨在最小化有效的人在循环过程所需的反馈。团队在两项用户研究中证实了方法所取得的进步，这两项研究显示，通过视觉知识外部化和学习过程，主题模型的质量得到了提高</p><div class="note default modern"><p><strong>[V] VIANA: Visual Interactive Annotation of Argumentation <a href="https://arxiv.org/pdf/1907.12413">[PDF]</a></strong></p></div><p>摘要论证挖掘解决的是识别论证文本片段的边界并提取它们之间的关系这一具有挑战性的任务。完全自动化的解决方案不能达到令人满意的准确性，因为它们没有充分地结合语义和领域知识。因此，专家目前依赖于耗时的手工注释。</p><p>本文提出了一个可视化的分析系统，通过自动建议哪些文本片段需要注释来增强手工注释的过程。随着时间的推移，通过结合语言知识和语言建模，从用户交互中学习论证相似度的度量，这些建议的准确性得到了提高。基于与领域专家的长期协作，团队确定并建模5个高级分析任务。可以仔细阅读和做笔记，注释论点，论点重建，提取论点关系，和探索论点图。为了避免上下文切换，团队通过无缝变形在所有视图之间转换，在视觉上锚定所有基于文本和图形的层。团队通过基于总统辩论语料库的两阶段专家用户研究来评估我们的系统。结果显示，与现有的解决方案相比，专家更喜欢本文的系统，因为自动建议提供了加速，并且文本和图形视图之间的紧密集成。</p><div class="note default modern"><p><strong>[I] An Evaluation of Semantically Grouped Word Cloud Designs <a href="http://people.ischool.berkeley.edu/~hearst/papers/HearstWordzonesTVCG.pdf">[PDF]</a></strong></p></div><p>：词云仍然是总结文本信息的流行工具，尽管它们在分析任务方面存在文档化的缺陷。它们的受欢迎程度很大程度上取决于它们有趣的视觉吸引力。本文中展示了一系列控制实验的结果，这些实验表明，与标准的单词云布局相比，将单词排列成语义和视觉上截然不同的区域的布局对于理解底层主题更有效。与标准的文字布局相比，留白分隔符和/或空间分组的颜色编码能够显著增强对基本主题的理解，同时在审美上也获得更高的评分。这项工作是之前关于词云语义布局研究的一个进步，因为之前的研究没有确保不同的语义组在视觉上或语义上是不同的，或者没有进行可用性研究。这项工作的另一个贡献是为语义类别识别任务开发了一个数据集，该数据集可用于这些结果的复制或词云设计的未来评估</p><hr><h2 id="What’s-the-Difference"><a href="#What’s-the-Difference" class="headerlink" title="What’s the Difference?"></a>What’s the Difference?</h2><div class="note default modern"><p><strong>[I] The Perceptual Proxies of Visual Comparison <a href="http://users.umiacs.umd.edu/~elm/projects/perceptual-proxies/perceptual-proxies.pdf">[PDF]</a></strong></p></div><p>视觉化中的感知任务通常涉及比较。在两个图表中描述的两组值中，哪一组的值总体上最高?哪个范围最广?之前的经验研究发现，在不同的视觉比较任务(如“最大的delta”、“最大的相关性”)中，不同的标记组合和空间安排的表现差别很大。</p><p>本文在两个新的比较任务的经验评价中扩展了这些组合，两组值之间的“最大平均值”和“最大范围”。团队使用阶梯程序滴定数据比较的困难程度，以评估哪个安排对每个任务产生最精确的比较。作者发现，一些图表安排比其他图表更支持最大平均值和最大范围的可视化比较，而且这个模式与其他任务的模式有本质上的不同。为了综合这些不和谐的发现，作者认为必须理解可视化的哪些特征实际上被人类视觉系统用来解决给定的任务。文中称之为感知代理。例如，当比较两个柱状图的平均值时，视觉系统可能会使用“平均长度”代理来隔离柱状图的实际长度，然后在这些长度上构造一个真正的平均值。或者，它可以使用“船体面积”代理，感知每个图表的条形框所限定的隐含船体，然后比较这些船体的面积。本文提出了一系列跨越不同任务、标记和空间安排的潜在代理。这些代理的简单模型可以通过在这些标记、安排和任务中匹配它们的性能和人类性能来对其解释力进行实证评估。团队使用这个过程来突出感知代理的候选，这些代理可能扩展到更广的范围来解释视觉比较中的表现。</p><div class="note default modern"><p><strong>[I] BarcodeTree: Scalable Comparison of Multiple Hierarchies <a href="http://vis.pku.edu.cn/people/guozhengli/docs/infovis19_barcodetree.pdf">[PDF]</a></strong></p></div><p>本文提出了一种新的可视化技术BarcodeTree (BCT)，用于比较多棵树的拓扑结构和节点属性值。BCT可以同时提供100个浅层且稳定的树的概览，而不需要聚合单个节点。每个BCT使用类似于条形码的样式在单行中显示，允许树垂直堆叠，匹配节点水平排列，以方便比较并保持空间效率。团队设计了一些视觉线索和交互技术来帮助用户理解树的拓扑结构和比较树。在两种BCT变异与冰柱图的比较实验中，结果表明BCT降低了不同树之间的垂直距离，使树之间的比较更加直观。文中还提供了两个案例研究，涉及数百棵树的数据集，以演示BCT的效用。</p><div class="note default modern"><p><strong>[I] Comparison of Radial and Linear charts for Visualizing Daily Patterns <a href="https://publik.tuwien.ac.at/files/publik_282792.pdf">[PDF]</a></strong></p></div><p>通常认为径向图不如线性图有效。也许唯一的例外是可视化周期依赖时间的数据，这被认为是自然支持径向布局。事实证明，径向图的缺点超过了这种自然制图的优点。作为一种特殊情况，日常模式的可视化还没有系统地利用放射状图进行评价。与每年或每周的循环趋势相比，在放射状图上分析每日模式可能得益于文化中普遍存在的放射状时钟方面训练有素的技能。在一项有92名非专家用户参与的众源实验中，团队评估了用于可视化日常交通事故模式的径向图和线性图的准确性、效率和主观评分。团队系统地比较并列的12小时变体和单一的24小时变体在四个低级任务和一个高级解释任务中两个布局。结果表明，在所有的任务中，最基本的24小时线性柱状图是最准确和有效的，也是用户的首选。这为线性布局的使用提供了有力的证据——即使是为了可视化每天的周期模式。</p><div class="note default modern"><p><strong>[I] Aggregated Dendrograms for Visual Comparison Between Many Phylogenetic Trees <a href="http://www.cs.ubc.ca/labs/imager/tr/2019/adview/adview-tvcg-preprint.pdf">[PDF]</a></strong></p></div><p>本文处理在进化生物学中出现的多种系统发育树的视觉比较，特别是在一个参考树和几十到数百个其他树的集合之间。团队将系统发育树比较的领域问题抽象为寻找假设的支持或冲突证据的任务，这些假设需要在树集的不同细节层次上检查拓扑结构和属性值。本文引入了聚合树状图的新的视觉编码习惯，以根据有生物学意义的标准简明地总结交互选择的焦点子树之间的拓扑关系，并提供了一种自动适应可用屏幕空间的布局算法。</p><p>本文设计并实现了ADView系统，它在多个视图的多个详细层次上表示树:整个集合、树的子集、单个树、感兴趣的特定子树和单个分支层。团队将ADView开发的算法作为基准，将其信息密度与以前的工作进行比较，并通过使用最近发表的系统发育分析数据和专家使用真实数据的案例研究(从总结性访谈研究中提取)，展示其在快速收集关于生物学假设证据方面的效用</p><hr><h2 id="Influencers"><a href="#Influencers" class="headerlink" title="Influencers"></a>Influencers</h2><div class="note default modern"><p><strong>[V] Influence Flowers of Academic Entities <a href="https://arxiv.org/pdf/1907.12748">[PDF]</a></strong></p></div><p>本文呈现“影响力之花”，这是一个新的视觉隐喻，用于描述学术实体的影响力，包括人物、项目、机构、会议和期刊。虽然许多工具都对影响进行了量化，但本文的目标是暴露实体之间的影响流。“影响之花”是一个以自我为中心的图，查询实体位于中心。花瓣的样式反映了同类型或不同类型的其他实体之间的影响力。例如，人们可以通过研究主题来分解研究实验室的传入和传出影响。“影响力花”使用了微软学术图的最近快照，包括2.12亿作者，1.76亿出版物，12亿次引用。交互式网络应用“影响力地图”(Influence Map)就是围绕这个搜索和策划可视化的中心隐喻而构建的。本文还提出了一种可视化的比较方法，可以突出影响模式随时间的变化。团队通过几个案例研究证明，影响花支持以下数据驱动的调查:研究人员的职业生涯;论文和项目，包括那些被延迟承认的项目;研究机构的跨学科特征;以及会议上不断变化的话题趋势。通过对比研究人员的学术活动和Twitter活动，团队还将该工具用于学术引用以外的影响力数据。</p><div class="note default modern"><p><strong>[V] WeSeer: Visual Analysis for Better Information Cascade Prediction of WeChat Articles <a href="http://www.cse.ust.hk/~huamin/tvcg_quan_2019.pdf">[PDF]</a></strong></p></div><p>社交媒体，如Facebook和微信，使数百万用户能够以前所未有的规模创造、消费和传播在线信息。社交媒体上丰富的信息使得微信公职人员的竞争更加激烈——由于注意力的零和本质——吸引用户注意力的文章(即帖子)。因此，只有一小部分的信息会变得非常流行，而其余的信息会被忽视或者很快消失。这种典型的“长尾”现象在社交媒体中非常普遍。因此，近年来，人们对预测未来社交媒体帖子的流行趋势，了解影响帖子流行的因素越来越感兴趣。然而，现有的预测模型要么依赖繁琐的特征工程，要么依赖复杂的参数调整，难以理解和改进。</p><p>在本文中，团队研究并改进了一个基于点过程的预测模型，结合可视化推理支持用户与预测模型之间的通信，以获得更好的预测结果。该系统可帮助用户揭示模型背后的工作机制，并根据所获得的信息提高预测精度。团队使用真实的微信文章来证明该系统的有效性，并在大量微信文章中验证改进的模型。还总结了来自微信领域专家的反馈</p><div class="note default modern"><p><strong>[V] R-Map: A Map Metaphor for Visualizing Information Reposting Process in Social Media <a href="http://vis.pku.edu.cn/research/publication/vast19_rmap.pdf">[PDF]</a></strong></p></div><p>本文提出R-Map (repost Map)，一种可视化的分析方法，使用地图隐喻来支持对社交媒体中信息转发过程的交互式探索和分析。一篇原创的社交媒体帖子会在网络上引发大量转发(也就是转发)，涉及数千甚至数百万持不同意见的人。这种重发行为形成了重发树，其中节点表示消息，链接表示重发关系。在R-Map中，重发树结构可以用突出显示的关键角色和平铺节点来空间化。将虚拟地理空间中重要的转发行为、下列关系和语义关系分别表示为河流、路线和桥梁。R-Map支持使用语义对大量信息重发进行可伸缩的概述。在地图上提供额外的交互，以支持调查时间模式和用户在信息扩散过程中的行为。本文用两个用例和一个正式的用户研究来评估我们系统的可用性和有效性。</p><hr><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><div class="note default modern"><p><strong>[I] Estimating color-concept associations from image statistics <a href="https://arxiv.org/pdf/1908.00220">[PDF]</a></strong></p></div><p>为了在分类信息的形象化中解释颜色的意义，人们必须确定不同的颜色如何对应不同的概念。在视觉化中，当颜色和概念之间的分配符合人们的期望时，这个过程会更容易，使调色板在语义上具有可解释性。为了语义上的可解释性，人们已经在努力优化调色板设计，但是这需要对人类颜色概念的关联有很好的估计。从人那里获取这些数据是昂贵的，这促使了对自动化方法的需求。本文开发并评估了一种新的方法，以一种与人类评分强烈相关的方式自动估计颜色概念关联。基于之前使用谷歌的研究图像，本文的方法直接操作在谷歌图像搜索结果，不需要人工循环。具体地说，评估了几种提取图像原始像素内容的方法，以最佳地估计从人类评级中获得的颜色概念关联。最有效的颜色提取方法是在颜色空间中结合圆柱扇区和颜色类别。本文的方法仅使用一小组图像可以准确地估计出不同水果的平均人类颜色概念关联。这种方法还可以很好地概括为更复杂的、与回收相关的、可以以任何颜色出现的对象概念。</p><div class="note default modern"><p><strong>[S] Measuring and Modeling the Feature Detection Threshold Functions of Colormaps <a href="https://ecxproject.org/wp-content/uploads/sites/18/2018/07/Ware2018-MeasureModelingFeatureDiscrimination.pdf">[PDF]</a></strong></p></div><p>伪着色是科学可视化中最常用的技术之一。要对标量字段应用伪着色，每个点上的字段值将使用一系列颜色中的一种(称为色图)表示。生成色彩图的原则之一是均匀性，以前确定均匀性的主要方法是应用均匀色彩空间。</p><p>本文提出了一种新的评价彩色地图特征检测阈值函数的方法。该方法被用于众包研究中，用于直接评价三种特征尺寸的九种彩色地图。结果被用来测试一个假设，即统一颜色空间(CIELAB)将准确建模的彩色映射特征检测阈值相比，一个模型的色度成分权值减少。本文还验证了特征检测可以仅根据亮度进行预测的假设。结果否定了这两种假设，并且本文演示了当任务是在彩色映射数据中检测较小的特征，CIELAB颜色空间中绿红蓝黄项的权重减少，如何创建一个更准确的模型。该方法本身和改进后的CIELAB均可用于色彩图的设计和评价</p><div class="note default modern"><p><strong>[S] Measuring the Effects of Scalar and Spherical Colormaps on Ensembles of DMRI Tubes <a href="https://pdfs.semanticscholar.org/19c4/7f59ace38e67a448f90613d7377dc09da01c.pdf">[PDF]</a></strong></p></div><p>本文报告了在视觉化扩散磁共振成像(DMRI)管的集合标量和方向的颜色编码的经验研究结果。实验测试了用于平均分数各向异性(FA)任务(灰度、黑体、发散、等亮度-彩虹、扩展黑体和冷温)的6种标量颜色图，以及用于道路追踪任务(均匀灰度、绝对、特征图和Boy表面嵌入)的4种三维方向编码。结果表明，扩展黑体、冷暖黑体和黑体仍然是识别三维集合平均的最佳方法。等亮度-彩虹着色导致与其他颜色图相同的总体平均精度。尽管如此，超过50%的答案始终有更高的总体平均估计值，独立于平均值。色调影响均值的总体估计，而不是亮度。对于集合定向跟踪任务，作者发现，Boy表面嵌入(最大的空间分辨率和对比度)和绝对颜色(最低的空间分辨率和对比度)方案比特征图方案(中等分辨率和对比度)得到更准确的答案，在精度方面表现为可视化设计中的奇异谷现象</p><hr><h2 id="Searching-amp-Querying"><a href="#Searching-amp-Querying" class="headerlink" title="Searching &amp; Querying"></a>Searching &amp; Querying</h2><div class="note default modern"><p><strong>[I] Searching the Visual Style and Structure of D3 Visualizations <a href="https://arxiv.org/pdf/1907.11265">[PDF]</a></strong></p></div><p>本文为D3可视化提供了一个搜索引擎，允许基于其视觉风格和底层结构的查询。为了构建引擎，团队从网上抓取7860 D3可视化集合，并解构每个集合，以恢复其数据，其数据编码标记和描述数据如何映射到标记的可视属性的编码。团队还提取了标记的轴和其他非数据编码属性(如字体、背景颜色)。本文的搜索引擎将这种样式和结构信息以及有关包含图表的网页的元数据进行索引。本文展示了可视化开发人员如何搜索集合，以找到显示特定设计特征的可视化效果，从而探索可能的设计空间。还演示了研究人员如何使用搜索引擎来识别常用的视觉设计模式，并在收集的D3图表中执行这样的人口统计学设计分析。一项用户研究表明，可视化开发人员发现，与只允许在包含图表的网页上进行关键字搜索的基准搜索引擎相比，基于本文的风格和结构的搜索引擎在查找不同D3图表设计时更有用，更令人满意。</p><div class="note default modern"><p><strong>[V] A Natural-language-based Visual Query Approach of Uncertain Human Trajectories <a href="https://zhaosongh.github.io/publication/Vis2019NLB.pdf">[PDF]</a></strong></p></div><p>可视化查询是交互式探索海量轨迹数据的关键。然而，数据的不确定性给满足高级分析需求带来了深刻的挑战。一方面，很多基础数据并不包含精确的地理坐标，例如，手机的位置只是指手机所在的区域(即手机基站)，而不是精确的GPS坐标。另一方面，领域专家和普通用户更喜欢用一种自然的方式来访问和分析大量的运动数据，例如使用自然语言句子。</p><p>本文提出了一种视觉分析方法，可以从文本句子中提取时空约束，并支持一种有效的查询方法，针对不确定的移动轨迹数据。该方法首先利用点向量及其覆盖区域的语义信息对大量空间不确定轨迹进行编码，然后利用有效的索引机制将轨迹文档存储在文本数据库中。可视化界面促进了大型轨迹数据的查询条件规范、位置感知可视化和语义探索。在真实人类移动数据集上的使用场景证明了本文方法的有效性。</p><div class="note default modern"><p><strong>[V] You can’t always sketch what you want: Understanding Sensemaking in Visual Query Systems <a href="https://arxiv.org/pdf/1710.00763.pdf">[PDF]</a></strong></p></div><p>可视化查询系统(VQSs)使用户能够以交互方式搜索具有所需可视化模式的折线图，通常使用直观的基于草图的界面指定。尽管过去的VQSs工作已经进行了几十年，但这些努力并没有转化为实践的采用，可能是因为VQSs在很大程度上是在不现实的实验室环境中进行评估的。为了弥补这种采用上的差距，作者团队与来自三个不同领域的专家合作——天文学、遗传学和材料科学——通过长达一年的以用户为中心的设计过程，开发了一个支持他们的工作流程和分析需求的VQS，并评估VQSs在实践中如何使用。研究结果表明，临时粗略查询并不像以前的工作建议的那样常用，因为分析师通常不能准确地表达他们感兴趣的模式。此外，本文还描述了增强的VQS支持的三种基本感知过程。团队发现参与者使用了所有三种过程，但比例不同，取决于每个领域的分析需求。研究结果表明，为了使未来的VQSs在更大范围的分析研究中有用，所有这三种感知过程都必须被整合起来。</p><div class="note default modern"><p><strong>[V] Do What I Mean, Not What I Say! Design Considerations for Supporting Intent and Context in Analytical Conversation <a href="https://research.tableau.com/sites/default/files/intentpaper_VAST2019.pdf">[PDF]</a></strong></p></div><p>自然语言是创建可视化和与可视化交互的一种有用的方式，但用户对自然语言系统的智能往往抱有不切实际的期望。用户期望和系统能力之间的鸿沟可能会导致令人失望的用户体验。因此，如果我们想要设计一个自然语言系统，围绕系统智能的需求是什么?</p><p>本文回顾了作者团队在Ask Data的设计中是如何回答这个问题的，Ask Data是一种自然语言交互功能画面。团队考察了影响感知系统智能的两个因素:系统理解输入话语背后的分析意图的能力和上下文解释话语的能力(即考虑当前的可视化状态和最近的动作)。本文的目标是理解系统需要以何种方式来支持智能的这两个方面，以实现积极的用户体验。首先描述一个预设计《绿野仙踪》的研究让团队对这个问题有了更深刻的认识，并缩小了所考虑的设计空间。然后，反思该研究对系统开发的影响，考察该研究的设计含义如何在实践中发挥作用。本文工作为视觉分析中的自然语言交互设计提供了见解，同时也反映了设计前实证研究在视觉分析系统开发中的价值</p><div class="note default modern"><p><strong>[V] TopicSifter: Interactive Search Space Reduction Through Targeted Topic Modeling <a href="https://arxiv.org/pdf/1907.12079">[PDF]</a></strong></p></div><p>主题建模通常用于分析和理解大型文档集合。然而，在实践中，用户希望关注特定的方面或“目标”，而不是整个语料库。例如，给定一个大的文档集合，用户可能只想要一个更小的子集，这个子集更符合他们的兴趣、任务和域。特别地，本文关注的是具有高查全率的大规模文档检索，其中任何丢失的相关文档都是至关重要的。</p><p>简单的关键字匹配搜索通常1)在研究数据集之前，很难找到能够覆盖感兴趣的文档的关键字查询列表,2)有些文件可能不包含感兴趣的确切关键字，但可能仍然高度相关,3)词具有多义性，这会导致检索到的子集中包含不相关的文档</p><p>本文提出了TopicSifter，一个用于交互式搜索空间缩减的可视化分析系统。该系统采用了基于非负矩阵分解的目标主题建模，并允许用户给出相关反馈，以细化目标，引导主题建模获得最相关的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：IMOS</title>
      <link href="2020/11/09/Re0-5/"/>
      <url>2020/11/09/Re0-5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>差分是竞赛中非常常用的技巧，正巧这次的USACO题目中可以用上差分，顺便做一个普及</p><p>这一个小节大概就只准备讲这一题，因为剩下的题目只涉及到进制转换和回文判断，属于对语法的巩固，没有太多想讲的知识点</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Milking Cows]</p><p>给定若干条线段(数量不大于5000)，左右端点范围[0,1000000]，求没有被线段覆盖的最长区间和被至少一条线段覆盖的最长区间</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先可以得到这个题的一个非常朴素的做法，将每个线段在数组中对覆盖到的位置+1，然后扫描整个区间得到答案，USACO的原数据较弱，所以我看到有些同学是这么过的，但是这么做的复杂度是O(nL)的，并不是一个合理的复杂度</p><h2 id="IMOS"><a href="#IMOS" class="headerlink" title="IMOS"></a>IMOS</h2><p>IMOS又被称为累积和法，其实就是通过前缀和以及差分思想来维护数据，在数据结构题中这个技巧非常实用</p><p>举一个简单的例子：</p><p>有一辆公交车，现在告诉你每个人上车和离开的时间点，要求查询任意时刻车上的人数</p><p>IMOS的做法就是，对于每个人，我们只需要在其上车的时间点+1，下车的时间点-1，计算这个时间表的前缀和，就可以得到关于时间点的答案数组</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/R5-1.png"></p><p>计算前缀和</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/R5-2.png"></p><p>二维的处理方法看下图应该就能看懂</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/R5-3.png"></p><p>图是从我自己比较古老的讲课slide里面截的，将就着看吧</p><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><p>那么有了IMOS这个手段，对于刚才那种朴素的做法，我们可以用IMOS来优化，对于每个区间，在左端点的位置+1，在右端点的后一个位置-1，然后对数组求前缀和就得到了覆盖数组，扫描求解答案即可</p><p>然而此题其实还有一个更具有普适性的做法，将区间排序，然后比较左右端点来更新两个答案，具体细节留给大家自己来思考实现</p><h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><ul><li>实现朴素的区间覆盖数组求解，并用IMOS优化</li><li>对区间排序，顺序扫描区间计算答案</li></ul>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：雷达图</title>
      <link href="2020/11/05/fullStack8/"/>
      <url>2020/11/05/fullStack8/</url>
      
        <content type="html"><![CDATA[<p>这回我们用祖传的数据来画一个雷达图</p><h2 id="绘制边框"><a href="#绘制边框" class="headerlink" title="绘制边框"></a>绘制边框</h2><p>参数和数据载入的过程和之前别无二致，准备工作完成之后，我们先来绘制几个同心圆，来作为雷达图的基础边框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gridCircles = d3.range(<span class="number">4</span>).map(<span class="function">(<span class="params">d, i</span>) =&gt;</span> (</span><br><span class="line">    axis.append(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;cx&quot;</span>, dimensions.boundedRadius)</span><br><span class="line">        .attr(<span class="string">&quot;cy&quot;</span>, dimensions.boundedRadius)</span><br><span class="line">        .attr(<span class="string">&quot;r&quot;</span>, dimensions.boundedRadius * (i / <span class="number">3</span>))</span><br><span class="line">        .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;grid-line&quot;</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack8-1.png"></p><p>我们准备在雷达图上显示六种属性，因此接下来我们要画对应的六个坐标轴，和同心圆一样，我们也可以用map来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gridLines = metrics.map(<span class="function">(<span class="params">metric, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> angle = i * ((<span class="built_in">Math</span>.PI * <span class="number">2</span>) / metrics.length) - <span class="built_in">Math</span>.PI * <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">return</span> axis.append(<span class="string">&quot;line&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;x1&quot;</span>, dimensions.boundedWidth / <span class="number">2</span>)</span><br><span class="line">        .attr(<span class="string">&quot;x2&quot;</span>, <span class="built_in">Math</span>.cos(angle) * dimensions.boundedRadius + dimensions.boundedWidth / <span class="number">2</span>)</span><br><span class="line">        .attr(<span class="string">&quot;y1&quot;</span>, dimensions.boundedHeight / <span class="number">2</span>)</span><br><span class="line">        .attr(<span class="string">&quot;y2&quot;</span>, <span class="built_in">Math</span>.sin(angle) * dimensions.boundedRadius + dimensions.boundedWidth / <span class="number">2</span>)</span><br><span class="line">        .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;grid-line&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack8-2.png"></p><h2 id="数据绘制"><a href="#数据绘制" class="headerlink" title="数据绘制"></a>数据绘制</h2><p>首先我们将要展示的属性标注在画出来的同心圆的边界上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> labels = metrics.map(<span class="function">(<span class="params">metric, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> angle = i * ((<span class="built_in">Math</span>.PI * <span class="number">2</span>) / metrics.length) - <span class="built_in">Math</span>.PI * <span class="number">0.5</span></span><br><span class="line">    <span class="keyword">const</span> x = </span><br><span class="line">        <span class="built_in">Math</span>.cos(angle) * (dimensions.boundedRadius * <span class="number">1.1</span>) + dimensions.boundedWidth / <span class="number">2</span></span><br><span class="line">    <span class="keyword">const</span> y = </span><br><span class="line">        <span class="built_in">Math</span>.sin(angle) * (dimensions.boundedRadius * <span class="number">1.1</span>) + dimensions.boundedHeight / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> axis.append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;x&quot;</span>, x)</span><br><span class="line">        .attr(<span class="string">&quot;y&quot;</span>, y)</span><br><span class="line">        .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;metric-label&quot;</span>)</span><br><span class="line">        .style(<span class="string">&quot;text-anchor&quot;</span>,</span><br><span class="line">            i == <span class="number">0</span> || i == metrics.length / <span class="number">2</span> ? <span class="string">&quot;middle&quot;</span> :</span><br><span class="line">            i &lt; metrics.length / <span class="number">2</span> ? <span class="string">&quot;start&quot;</span> : <span class="string">&quot;end&quot;</span></span><br><span class="line">        )</span><br><span class="line">        .text(metric)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>text-anchor是对给定点的对齐方式，因为我们是标注在圆周外边的，所以肯定有文本的开头在给定点，文本的结束位置在给定点和文本的中点在给定点三种，因此我们需要根据其下标决定对齐方式</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack8-3.png"></p><p>然后将数值在图表上表示出来，这里我们希望画一个闭合的图形，所以采用d3.lineRadial()，需要设置角度和半径，.curve(d3.curveLinearClosed)则将最后一笔连上，形成闭合图形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;line&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> drawLine = <span class="function">(<span class="params">day</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lineGenerator = d3.lineRadial()</span><br><span class="line">        .angle(<span class="function">(<span class="params">metric, i</span>) =&gt;</span> i * ((<span class="built_in">Math</span>.PI * <span class="number">2</span>) / metrics.length))</span><br><span class="line">        .radius(<span class="function">(<span class="params">metric, i</span>) =&gt;</span> metricScales[i](+day[metric] || <span class="number">0</span>))</span><br><span class="line">        .curve(d3.curveLinearClosed)</span><br><span class="line">    <span class="keyword">const</span> line = bounds.select(<span class="string">&quot;.line&quot;</span>)</span><br><span class="line">        .datum(metrics)</span><br><span class="line">        .attr(<span class="string">&quot;d&quot;</span>, lineGenerator)</span><br><span class="line">        .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(<span class="subst">$&#123;dimensions.boundedRadius&#125;</span>px, <span class="subst">$&#123;dimensions.boundedRadius&#125;</span>px)`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们加入按钮用于切换对应的日期，显示对应的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeDayIndex = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> title = d3.select(<span class="string">&quot;#title&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> dateFormatter = d3.timeFormat(<span class="string">&quot;%B %-d, %Y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateChart = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    title.text(dateFormatter(dateAccessor(dataset[activeDayIndex])))</span><br><span class="line">    drawLine(dataset[activeDayIndex])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateChart()</span><br><span class="line"></span><br><span class="line">d3.select(<span class="string">&quot;#show-next-day&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    activeDayIndex = (activeDayIndex + <span class="number">1</span>) % (dataset.length - <span class="number">1</span>)</span><br><span class="line">    updateChart()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack8-4.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/radar/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：热图</title>
      <link href="2020/11/05/fullStack7/"/>
      <url>2020/11/05/fullStack7/</url>
      
        <content type="html"><![CDATA[<p>常用git的同学可能对热图(heatmap)已经很熟悉了，就是这个东西</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack7-2.png"></p><p>我的contribution真是丢人，希望之后可以填的更满一点</p><p>现在我们来做一个自己的heatmap，当然还是熟悉的那个数据</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>先把数据读入，然后做一些预处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathToJSON = <span class="string">&quot;./data/nyc_weather_data.json&quot;</span></span><br><span class="line"><span class="keyword">let</span> dataset = <span class="keyword">await</span> d3.json(pathToJSON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parseDate = d3.timeParse(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> dateAccessor = <span class="function"><span class="params">d</span> =&gt;</span> parseDate(d.date)</span><br><span class="line">dataset = dataset.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> dateAccessor(a) - dateAccessor(b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstDate = dateAccessor(dataset[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weekFormat = d3.timeFormat(<span class="string">&quot;%-e&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> xAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d3.timeWeeks(firstDate, dateAccessor(d)).length</span><br><span class="line"><span class="keyword">const</span> dayOfWeekFormat = d3.timeFormat(<span class="string">&quot;%-w&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> yAccessor = <span class="function"><span class="params">d</span> =&gt;</span> +dayOfWeekFormat(dateAccessor(d))</span><br></pre></td></tr></table></figure><p>之后计算一些参数，我们期望的是一列显示一周七天，所以要先算出星期的数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberOfWeeks = <span class="built_in">Math</span>.ceil(dataset.length / <span class="number">7</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> dimensions = &#123;</span><br><span class="line">    margin: &#123;</span><br><span class="line">        top: <span class="number">30</span>,</span><br><span class="line">        right: <span class="number">0</span>,</span><br><span class="line">        bottom: <span class="number">0</span>,</span><br><span class="line">        left: <span class="number">80</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">dimensions.width = (<span class="built_in">window</span>.innerWidth </span><br><span class="line">    - dimensions.margin.left </span><br><span class="line">    - dimensions.margin.right) * <span class="number">0.95</span></span><br><span class="line">dimensions.boundedWidth = dimensions.width </span><br><span class="line">    - dimensions.margin.left </span><br><span class="line">    - dimensions.margin.right</span><br><span class="line">dimensions.height = </span><br><span class="line">    dimensions.boundedWidth * <span class="number">7</span> / numberOfWeeks </span><br><span class="line">    + dimensions.margin.top </span><br><span class="line">    + dimensions.margin.bottom</span><br><span class="line">dimensions.boundedHeight = dimensions.height </span><br><span class="line">    - dimensions.margin.top </span><br><span class="line">    - dimensions.margin.bottom</span><br></pre></td></tr></table></figure><p>和往常一样建立画布</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = d3.select(<span class="string">&quot;#wrapper&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, dimensions.width)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, dimensions.height)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bounds = wrapper.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;dimensions.margin.left&#125;</span>px, <span class="subst">$&#123;dimensions.margin.top&#125;</span>px</span></span><br><span class="line"><span class="string">    )`</span>)</span><br></pre></td></tr></table></figure><p>还需要计算的参数是表示每天的每个小格子的长宽以及格子的间隙</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> barPadding = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> totalBarDimension = d3.min([</span><br><span class="line">    dimensions.boundedWidth / numberOfWeeks,</span><br><span class="line">    dimensions.boundedHeight / <span class="number">7</span>,</span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> barDimension = totalBarDimension - barPadding</span><br></pre></td></tr></table></figure><h2 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h2><p>先把月份的信息绘制出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monthFormat = d3.timeFormat(<span class="string">&quot;%b&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> months = bounds.selectAll(<span class="string">&quot;.month&quot;</span>)</span><br><span class="line">    .data(d3.timeMonths(dateAccessor(dataset[<span class="number">0</span>]), </span><br><span class="line">        dateAccessor(dataset[dataset.length - <span class="number">1</span>])))</span><br><span class="line">    .enter().append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;month&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        totalBarDimension * d3.timeWeeks(firstDate, d).length&#125;</span>, -10</span></span><br><span class="line"><span class="string">    )`</span>)</span><br><span class="line">    .text(<span class="function"><span class="params">d</span> =&gt;</span> monthFormat(d))</span><br></pre></td></tr></table></figure><p>d3.timeMonths可以将起止时间按照月份间隔划分生成数据，生成的数据输出如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack7-3.png"></p><p>绘制的效果如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack7-4.png"></p><p>星期的绘制如法炮制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dayOfWeekParse = d3.timeParse(<span class="string">&quot;%-e&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> dayOfWeekTickFormat = d3.timeFormat(<span class="string">&quot;%-A&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> labels = bounds.selectAll(<span class="string">&quot;.label&quot;</span>)</span><br><span class="line">    .data(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">d, i</span>) =&gt;</span> i))</span><br><span class="line">    .enter().append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;label&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;transform&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> <span class="string">`translate(-10, <span class="subst">$&#123;totalBarDimension * (d + <span class="number">0.5</span>)&#125;</span>)`</span>)</span><br><span class="line">    .text(<span class="function"><span class="params">d</span> =&gt;</span> dayOfWeekTickFormat(dayOfWeekParse(d))) </span><br></pre></td></tr></table></figure><p>然后我们来画里边的格子，其实就是在指定的位置画上对应的小方块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建颜色比例尺</span></span><br><span class="line"><span class="keyword">const</span> colorAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d[metric]</span><br><span class="line"><span class="keyword">const</span> colorRangeDomain = d3.extent(dataset, colorAccessor)</span><br><span class="line"><span class="keyword">const</span> colorRange = d3.scaleLinear()</span><br><span class="line">    .domain(colorRangeDomain)</span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    .clamp(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> colorGradient = d3.interpolateHcl(<span class="string">&quot;#ecf0f1&quot;</span>, <span class="string">&quot;pink&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> colorScale = <span class="function"><span class="params">d</span> =&gt;</span> colorGradient(colorRange(d))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> days = bounds.selectAll(<span class="string">&quot;.day&quot;</span>)</span><br><span class="line">    .data(dataset, <span class="function"><span class="params">d</span> =&gt;</span> d.date)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newDays = days.enter().append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> allDays = newDays.merge(days)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;day&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> totalBarDimension * xAccessor(d))</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, barDimension)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> totalBarDimension * yAccessor(d))</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, barDimension)</span><br><span class="line">    .style(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> colorScale(colorAccessor(d)))</span><br></pre></td></tr></table></figure><p>最后再加上一个标题和比例尺标注</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d3.select(<span class="string">&quot;#metric&quot;</span>)</span><br><span class="line">    .text(metric)</span><br><span class="line">d3.select(<span class="string">&quot;#legend-min&quot;</span>)</span><br><span class="line">    .text(colorRangeDomain[<span class="number">0</span>])</span><br><span class="line">d3.select(<span class="string">&quot;#legend-max&quot;</span>)</span><br><span class="line">    .text(colorRangeDomain[<span class="number">1</span>])</span><br><span class="line">d3.select(<span class="string">&quot;#legend-gradient&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;background&quot;</span>, <span class="string">`linear-gradient(to right, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="literal">null</span>).map((d, i) =&gt; (</span></span></span><br><span class="line"><span class="string"><span class="subst">            <span class="string">`<span class="subst">$&#123;colorGradient(i <span class="regexp">/ 9)&#125; $&#123;i * 100 /</span> <span class="number">9</span>&#125;</span>%`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )).join(<span class="string">&quot;, &quot;</span>)</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>)`</span>)</span><br></pre></td></tr></table></figure><p>交互部分则沿用之前柱状图中的按钮来切换数据，热图就画完了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack7-1.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/heatmap/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：环的处理</title>
      <link href="2020/11/03/Re0-4/"/>
      <url>2020/11/03/Re0-4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环是竞赛题当中一个比较常见的条件，在不同情况下需要不同的处理方法，最常见的是下标取余和破环成链，别的技巧因为涉及更多算法暂且不提，大家之后遇到可以自行整理归纳</p><p>第一节结束，大家应该基本掌握了语法，从本篇开始，基本不再放出具体的题目代码，只讨论思路和算法，或者给出部分核心代码，有些单纯练习，并没有新鲜技巧或者新内容引入的题也会跳过</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Broken Necklace]</p><p>有一条由N个红色的，白色的，或蓝色的珠子组成的项链，要求在某点打破项链，展开成一条直线，从两端往里收集珠子，收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色，每端收集珠子时当遇到不同颜色的珠子就停止收集，问能够收集到的最多的珠子数量</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先有一个非常简单的思路，枚举每一个断点，然后往两边获取珠子直到不能获取为止，但是本题给出的是一个环，如果获取珠子的过程中跨越了n-1分界线，就要用取余来计算下一个位置，并且比较容易写错</p><p>这里有个比较好的方法就是，破环成链，这是一个非常常用的技巧，具体做法就是，将表示环的数组复制一遍，接在原来的数组后面，那么不需要跨越分界线，原来所有环的遍历情况在链上就能处理</p><p>但是在这里就会出现一个问题，如果往两边取珠子的过程在原来的环上会相遇，那么在链上，就会得到大于环长度的答案，这个其实是很好处理的，和链的长度取个min就可以了</p><p>以上的思路实现的时间复杂度是$O(n^2)$，相信大家在实现中应该不会遇到太大的困难</p><p>接下来我们考虑优化：答案应该是相邻的连续红色珠子和连续蓝色珠子(考虑白珠)之和的最大值</p><p>那么就不断地交替处理连续的红色珠子和蓝色珠子即可，我们以红色珠子为例，那么很容易想到的策略就是，将所有的白色和红色珠子统计进来，遇到蓝色珠子结束计数</p><p>但是我们在执行中，会发现一个问题</p><p>举个例子，如下的珠串</p><p>bbwrrrrwwwbbbbwwwrrrwwwrrrww</p><p>答案应该是由第二个红色串和蓝色串组成的，但是第2,3,4个w会在计算第一个红珠串的时候被划入红色珠串，所以，在统计红色珠串的时候，将遇到的所有白色珠串都算作红色的做法是不可行的，最后的白色珠串是需要复用的，因此还要统计最后一串连续的白色珠串</p><p>KEY CODE (以红色珠子为例)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRed) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">        b = w + <span class="number">1</span>;</span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">        isRed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        w++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r += w + <span class="number">1</span>;</span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans, r + b + w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连续蓝色珠子部分和预处理部分请自行实现</p><h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><ul><li>实现朴素的$O(n^2)$做法</li><li>优化算法的复杂度到$O(n)$</li><li>学有余力的同学请用搜索算法完成此题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：地图</title>
      <link href="2020/11/03/fullStack6/"/>
      <url>2020/11/03/fullStack6/</url>
      
        <content type="html"><![CDATA[<p>在d3中地图的创建通常用d3-geo来实现的，GeoJSON是一种用于表示地理结构(几何图形、特性或特性集合)的格式，我们选择Natural Earth来作为练手数据</p><h2 id="数据读入与参数设置"><a href="#数据读入与参数设置" class="headerlink" title="数据读入与参数设置"></a>数据读入与参数设置</h2><p>首先读入数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countryShapes = <span class="keyword">await</span> d3.json(<span class="string">&#x27;./data/world-geojson.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dataset = <span class="keyword">await</span> d3.csv(<span class="string">&#x27;./data/world_bank_data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><p>console.log一下我们可以看到json数据的内容，其中包含了四个关键字：crs, features, name, type</p><p>我们在feature里面挑选关键词并创建访问器函数，通过访问国家ID来找到人口增长数据集中的度量值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countryNameAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.properties[<span class="string">&quot;NAME&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> countryIdAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.properties[<span class="string">&quot;ADM0_A3_IS&quot;</span>]</span><br></pre></td></tr></table></figure><p>然后来看一下这个csv文件</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack6-1.png"></p><p>这个数据集是一个数组，它将每个国家多次列出，每次都使用不同的度量，以Series Name键命名，这里我们只用到每年人口的增长，所以把它抠出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> metric = <span class="string">&quot;Population growth (annual %)&quot;</span></span><br></pre></td></tr></table></figure><p>然后我们将检查数据集数组中的每一项。如果条目的“系列名称”与我们的度量不匹配，我们将不做任何事情。如果匹配，我们将向metricDataByCountry对象添加一个新值:键是项目的“国家代码”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> metricDataByCountry = &#123;&#125;</span><br><span class="line">dataset.forEach(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[<span class="string">&#x27;Series Name&#x27;</span>] != metric) <span class="keyword">return</span></span><br><span class="line">    metricDataByCountry[d[<span class="string">&#x27;Country Code&#x27;</span>]] = d[<span class="string">&#x27;2017 [YR2017]&#x27;</span>] || <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们来选择一个投影方式，我们先创建一个球体，随后选择一种投影方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sphere = &#123; <span class="attr">type</span>: <span class="string">&#x27;Sphere&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> projection = d3</span><br><span class="line">    .geoEqualEarth() </span><br><span class="line">    .fitWidth(dimensions.boundedWidth, sphere) </span><br><span class="line"><span class="keyword">const</span> pathGenerator = d3.geoPath(projection)</span><br></pre></td></tr></table></figure><p>fitWidth中的两个参数分别表示图示的宽度和要投影的对象</p><p>pathGenerator()有一个.bounds()方法，它将返回一个[x, y]坐标数组，描述指定GeoJSON对象的边界框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [[x0, y0], [x1, y1]] = pathGenerator.bounds(sphere)</span><br></pre></td></tr></table></figure><p>最后我们来定义一下参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dimensions = &#123;</span><br><span class="line">    width: <span class="built_in">window</span>.innerWidth * <span class="number">0.9</span>,</span><br><span class="line">    margin: &#123;</span><br><span class="line">        top: <span class="number">10</span>,</span><br><span class="line">        right: <span class="number">10</span>,</span><br><span class="line">        bottom: <span class="number">10</span>,</span><br><span class="line">        left: <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dimensions.boundedWidth =</span><br><span class="line">    dimensions.width - dimensions.margin.left - dimensions.margin.right</span><br><span class="line">dimensions.boundedHeight = y1</span><br><span class="line">dimensions.height =</span><br><span class="line">    dimensions.boundedHeight + dimensions.margin.top + dimensions.margin.bottom</span><br></pre></td></tr></table></figure><h2 id="创建比例尺"><a href="#创建比例尺" class="headerlink" title="创建比例尺"></a>创建比例尺</h2><p>接下来要创建一个比例尺，将度量值(人口增长数量)转换为颜色值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象值</span></span><br><span class="line"><span class="keyword">const</span> metricValues = <span class="built_in">Object</span>.values(metricDataByCountry) </span><br><span class="line"><span class="comment">// 获取数据范围 (最小值，最大致)</span></span><br><span class="line"><span class="keyword">const</span> metricValueExtent = d3.extent(metricValues) </span><br><span class="line"><span class="keyword">const</span> maxChange = d3.max([-metricValueExtent[<span class="number">0</span>], metricValueExtent[<span class="number">1</span>]])</span><br><span class="line"><span class="keyword">const</span> colorScale = d3</span><br><span class="line">    .scaleLinear()</span><br><span class="line">    .domain([-maxChange, <span class="number">0</span>, maxChange])</span><br><span class="line">    .range([<span class="string">&#x27;indigo&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;darkgreen&#x27;</span>])</span><br></pre></td></tr></table></figure><p>因为增长率存在负增长，所以我们需要获得绝对值的最大值，然后创建一个两段的比例尺，用两种不同颜色表示正负</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>准备工作完成，我们开始画这个地图</p><p>先把轮廓画出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> earth = bounds.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;earth&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;d&quot;</span>, pathGenerator(sphere))</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack6-2.png"></p><p>然后通过d3.geoGraticule10()函数每隔10度画一个分割线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> graticuleJson = d3.geoGraticule10()</span><br><span class="line"><span class="keyword">const</span> graticule = bounds.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;graticule&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;d&quot;</span>, pathGenerator(graticuleJson))</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack6-3.png"></p><p>最后将国家数据画上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countries = bounds</span><br><span class="line">    .selectAll(<span class="string">&#x27;.country&#x27;</span>)</span><br><span class="line">    .data(countryShapes.features) </span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">&#x27;path&#x27;</span>) </span><br><span class="line">    .attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;country&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;d&#x27;</span>, pathGenerator)</span><br><span class="line">    .attr(<span class="string">&#x27;fill&#x27;</span>, <span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> metricValue = metricDataByCountry[countryIdAccessor(d)] </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> metricValue === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">&#x27;#e2e6e9&#x27;</span> </span><br><span class="line">        <span class="keyword">return</span> colorScale(metricValue) </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>再额外加个标题和比例尺说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> legendGroup = wrapper</span><br><span class="line">    .append(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    .attr(</span><br><span class="line">        <span class="string">&#x27;transform&#x27;</span>,</span><br><span class="line">        <span class="string">`translate(<span class="subst">$&#123;<span class="number">120</span>&#125;</span>,<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.width &lt; <span class="number">800</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            ? dimensions.boundedHeight - <span class="number">30</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            : dimensions.boundedHeight * <span class="number">0.5</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>)`</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题</span></span><br><span class="line"><span class="keyword">const</span> legendTitle = legendGroup</span><br><span class="line">    .append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;y&#x27;</span>, -<span class="number">23</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;legend-title&#x27;</span>)</span><br><span class="line">    .text(<span class="string">&#x27;Population growth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年份标注</span></span><br><span class="line"><span class="keyword">const</span> legendByline = legendGroup</span><br><span class="line">    .append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;y&#x27;</span>, -<span class="number">9</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;legend-byline&#x27;</span>)</span><br><span class="line">    .text(<span class="string">&#x27;Percent change in 2017&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// defs中创建的元素是不可见的，但可以在后面使用</span></span><br><span class="line"><span class="keyword">const</span> defs = wrapper.append(<span class="string">&#x27;defs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> legendGradientId = <span class="string">&#x27;legend-gradient&#x27;</span></span><br><span class="line"><span class="keyword">const</span> gradient = defs</span><br><span class="line">    .append(<span class="string">&#x27;linearGradient&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;id&#x27;</span>, legendGradientId)</span><br><span class="line">    .selectAll(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">    .data(colorScale.range())</span><br><span class="line">    .enter()</span><br><span class="line">    .append(<span class="string">&#x27;stop&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;stop-color&#x27;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d)</span><br><span class="line">    .attr(</span><br><span class="line">        <span class="string">&#x27;offset&#x27;</span>,</span><br><span class="line">        (d, i) =&gt;</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            (i * <span class="number">100</span>) / <span class="number">2</span> </span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>%`</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画出比例尺</span></span><br><span class="line"><span class="keyword">const</span> legendWidth = <span class="number">120</span></span><br><span class="line"><span class="keyword">const</span> legendHeight = <span class="number">16</span></span><br><span class="line"><span class="keyword">const</span> legendGradient = legendGroup</span><br><span class="line">    .append(<span class="string">&#x27;rect&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;x&#x27;</span>, -legendWidth / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;height&#x27;</span>, legendHeight)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, legendWidth)</span><br><span class="line">    .style(<span class="string">&#x27;fill&#x27;</span>, <span class="string">`url(#<span class="subst">$&#123;legendGradientId&#125;</span>)`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右侧数值</span></span><br><span class="line"><span class="keyword">const</span> legendValueRight = legendGroup</span><br><span class="line">    .append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;legend-value&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;x&#x27;</span>, legendWidth / <span class="number">2</span> + <span class="number">10</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;y&#x27;</span>, legendHeight / <span class="number">2</span>)</span><br><span class="line">    .text(<span class="string">`<span class="subst">$&#123;d3.format(<span class="string">&#x27;.1f&#x27;</span>)(maxChange)&#125;</span>%`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左侧数值</span></span><br><span class="line"><span class="keyword">const</span> legendValueLeft = legendGroup</span><br><span class="line">    .append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;legend-value&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;x&#x27;</span>, -legendWidth / <span class="number">2</span> - <span class="number">10</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;y&#x27;</span>, legendHeight / <span class="number">2</span>)</span><br><span class="line">    .text(<span class="string">`<span class="subst">$&#123;d3.format(<span class="string">&#x27;.1f&#x27;</span>)(-maxChange)&#125;</span>%`</span>)</span><br><span class="line">    .style(<span class="string">&#x27;text-anchor&#x27;</span>, <span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里书上介绍了一个神奇的东西，navigator，可以获取浏览器用户的位置，这里我们用一个小圆圈显示出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="params">myPosition</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myPosition)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [x, y] = projection([</span><br><span class="line">        myPosition.coords.longitude,</span><br><span class="line">        myPosition.coords.latitude</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> myLocation = bounds.append(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;my-location&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;cx&quot;</span>, x)</span><br><span class="line">        .attr(<span class="string">&quot;cy&quot;</span>, y)</span><br><span class="line">        .attr(<span class="string">&quot;r&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        .transition().duration(<span class="number">500</span>)</span><br><span class="line">        .attr(<span class="string">&quot;r&quot;</span>, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack6-4.png"></p><p>互动部分和先前类似，加入了一个小牌子显示信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">countries</span><br><span class="line">    .on(<span class="string">&quot;mouseenter&quot;</span>, onMouseEnter)</span><br><span class="line">    .on(<span class="string">&quot;mouseleave&quot;</span>, onMouseLeave)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tooltip = d3.select(<span class="string">&quot;#tooltip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMouseEnter</span>(<span class="params">datum</span>) </span>&#123; </span><br><span class="line">    tooltip.style(<span class="string">&quot;opacity&quot;</span>, <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">const</span> metricValue = metricDataByCountry[countryIdAccessor(datum)]</span><br><span class="line">    tooltip.select(<span class="string">&quot;#country&quot;</span>).text(countryNameAccessor(datum))</span><br><span class="line">    tooltip.select(<span class="string">&quot;#value&quot;</span>).text(<span class="string">`<span class="subst">$&#123;d3.format(<span class="string">&quot;,.2f&quot;</span>)(metricValue || <span class="number">0</span>)&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [centerX, centerY] = pathGenerator.centroid(datum)</span><br><span class="line">    <span class="keyword">const</span> x = centerX + dimensions.margin.left</span><br><span class="line">    <span class="keyword">const</span> y = centerY + dimensions.margin.top</span><br><span class="line"></span><br><span class="line">    tooltip.style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(`</span></span><br><span class="line">        + <span class="string">`calc( -50% + <span class="subst">$&#123;x&#125;</span>px),`</span></span><br><span class="line">        + <span class="string">`calc(-100% + <span class="subst">$&#123;y&#125;</span>px)`</span></span><br><span class="line">        + <span class="string">`)`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMouseLeave</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    tooltip.style(<span class="string">&quot;opacity&quot;</span>, <span class="number">0</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack6-5.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/map/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：交互</title>
      <link href="2020/11/03/fullStack5/"/>
      <url>2020/11/03/fullStack5/</url>
      
        <content type="html"><![CDATA[<p>交互即对于键盘和鼠标对元素的操作做出反应</p><p>我们先对柱状图加入一些交互操作</p><p>交互的实现非常简单，.on(事件，操作函数)，比如我们想在矩形上做出一个鼠标移入的操作，只要实现如下代码即可，这样就可以使得矩阵在鼠标移入的时候变成紫色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binGroups.select(<span class="string">&#x27;rect&#x27;</span>)</span><br><span class="line">    .on(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">        d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;purple&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack5-1.png"></p><p>然后就发现当鼠标移开之后还是紫色的，这说明我们还需要加入一个鼠标移开的事件，这样就可以保证只有鼠标覆盖到的矩阵是变了颜色的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.on(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;cornflowerblue&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们就可以在function里面加入更多的操作，比如实现一个矩阵对应数据的小牌牌</p><p>现在html的wrapper里面画个牌，用于显示属性对应的范围和矩形表示的数值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tooltip&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tooltip-range&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;metric&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>: <span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;range&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tooltip-value&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> days</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>样式用css设置，因为我们希望移动到矩形时显示对应的数据，所以在css中先将其透明度设置为透明</p><p>修改鼠标移入的函数，改变数据牌的位置和信息，然后将设置为可见</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.on(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">    d3.select(<span class="built_in">this</span>).style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;purple&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> formatmetrics = d3.format(<span class="string">&quot;.2f&quot;</span>) </span><br><span class="line">    tooltip.select(<span class="string">&quot;#metric&quot;</span>)</span><br><span class="line">        .text(metric)</span><br><span class="line">    tooltip.select(<span class="string">&quot;#range&quot;</span>)</span><br><span class="line">        .text([formatmetrics (d.x0), formatmetrics(d.x1)].join(<span class="string">&quot; - &quot;</span>))</span><br><span class="line">    tooltip.select(<span class="string">&quot;#count&quot;</span>).text(yAccessor(d))</span><br><span class="line">    <span class="keyword">const</span> x = xScale(d.x0) + (xScale(d.x1) - xScale(d.x0)) / <span class="number">2</span> + dimensions.margin.left</span><br><span class="line">    <span class="keyword">const</span> y = yScale(yAccessor(d)) + dimensions.margin.top</span><br><span class="line">    tooltip.style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(<span class="subst">$&#123;x + <span class="number">120</span>&#125;</span>px, <span class="subst">$&#123;y - <span class="number">50</span>&#125;</span>px)`</span>)</span><br><span class="line">    tooltip.style(<span class="string">&quot;opacity&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而在移除函数里设置opacity为0，就可以成功加入这个牌子</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack5-2.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/barInteraction/">[演示地址]</a></p><p>散点图和柱状图几乎是一个做法，就是在之前实现的内容里加入显示牌即可</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack5-3.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/scatterplotInteraction/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIS2019论文整理(2)</title>
      <link href="2020/11/02/VIS2019-2/"/>
      <url>2020/11/02/VIS2019-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[V] VAST，[I] InfoVis，[S] SciVis </p></blockquote><p>继续整理VIS2019的论文内容，之前的内容见<a href="https://forever97.github.io/2020/10/21/VIS2019-1/">[VIS2019论文整理(1)]</a></p><hr><h2 id="Evaluation-amp-Reproducibility"><a href="#Evaluation-amp-Reproducibility" class="headerlink" title="Evaluation &amp; Reproducibility"></a>Evaluation &amp; Reproducibility</h2><div class="note default modern"><p><strong>[I] Toward Objective Evaluation of Working Memory in Visualizations: A Case Study Using Pupillometry and a Dual-Task Paradigm <a href="https://osf.io/zj6tp/download?format=pdf">[PDF]</a></strong></p></div><p>认知科学已经在许多应用领域建立了广泛使用和验证的评估工作记忆的方法，但很少有研究使用这些方法来评估可视化对工作记忆的影响。使用经过验证的方法来测量工作记忆的信息可视化研究之所以缺乏，部分原因可能是由于缺乏为可视化研究的独特需求量身定制的跨领域方法论指导。本文提出了一套清晰、实用、有经验验证的视觉任务工作记忆评估方法，并为读者选择合适的工作记忆评估范式提供了指导。以地理空间数据为例，阐述了在视觉-空间聚合任务中评估工作记忆的多种方法。结果表明，使用双任务实验设计(同时完成多个任务而不是单任务)和瞳孔扩张可以揭示与任务难度和双任务相关的工作记忆需求。在双任务实验设计中，对任务完成时间和瞳孔测量法的测量揭示了工作记忆需求与任务难度和双任务相关。瞳孔测量显示，当参与者完成更困难的任务或同时处理多项任务时，他们的瞳孔明显更大，本文建议对视觉化工作记忆的相对差异感兴趣的研究人员应考虑一种趋同方法，即使用工作记忆的生理测量和行为测量来产生视觉化努力的丰富评估</p><div class="note default modern"><p><strong>[I] VisTA: Integrating Machine Intelligence with Visualization to Support the Investigation of Think-Aloud Sessions <a href="https://www.jeffjianzhao.com/papers/vista.pdf">[PDF]</a></strong></p></div><p>有声思维协议在可用性测试中被用户体验(UX)从业者广泛使用，以发现用户界面设计中的问题。分析大量记录的有声思维会话通常是很困难的，由于时间和资源的限制，很少有UX实践者在分析过程中有机会获得第二个视角。最近的研究显示微妙的冗长和说话方式往往发生在用户遇到的可用性问题中，受到这些研究的启发，本文的第一步是设计和评估一个智能的可视化分析工具，它利用这些模式来识别遇到的可用性问题，并将它们呈现给用户体验从业者来帮助他们分析。首先进行并记录有声思维会话，然后从录音中提取文本和声学特征，并训练机器学习(ML)模型来检测问题，接下来，迭代地设计和开发了一个可视化分析工具，VisTA，它能够通过ML预测和输入特性的时间轴可视化来动态地调查出声思考会话。文中将VisTA和baseline做了比较，研究结果表明，用户体验专业人员在使用VisTA时识别出了比baseline更多的问题，他们利用问题可视化作为概述、预测和锚点，以及将特性可视化作为了解ML考虑和忽略什么的手段</p><div class="note default modern"><p><strong>[S] On Evaluating Runtime Performance of Interactive Visualizations <a href="https://freysn.github.io/papers/performance_tvcg19.pdf">[PDF]</a></strong></p></div><p>随着可视化领域的成熟，可视化技术的评估已经从报告运行时性能扩展到研究用户行为。因此，用户研究的许多方法和最佳实践已经得到发展。虽然保持交互性对于探索大型数据集仍然是至关重要的，但是还没有开发出类似的评估运行时性能的方法基础。本文对最近的50篇关于渲染体块或粒子表明上有新技术提出或者技术上提升可视化分析的论文进行分析。为了获得对定性运行时行为和定量参数依赖的更深层次的理解，作者团队开发了一个框架，用于对所知的体积和粒子可视化技术的最详尽的性能评估，包括对10种不同gpu的数百万次测量，本文报告了团队的见解，从统计分析的数据，讨论独立和线性参数行为和非明显的影响。在评估科学可视化应用程序的运行时性能时，本文提供了最佳实践的建议，可以作为更精细的性能量化模型的起点</p><div class="note default modern"><p><strong>[V] The Validity and Generalizability of Summative Evaluation Methods in Visual Analytics  <a href="https://arxiv.org/pdf/1907.13314">[PDF]</a></strong></p></div><p>许多评估方法已经被用来评估视觉分析(VA)解决方案的有效性。这些方法源于各种不同的起源和不同的假设和目标，这导致了对其评价能力的混淆。此外，缺乏对评价过程的讨论可能会限制为VA开发新的专门的评价方法的潜力。这篇文章对评估方法做了一个分析，对过去两年文献的评价方法进行了调查和分类，分析了这些方法的有效性和归纳性，以及使用这些方法的可行性，同时提出了一种新的度量标准——总结性质量，用于根据评价方法证明有效性的能力对评价方法进行比较，并根据评价方法的总结性质量对评价方法的选择提出建议</p><div class="note default modern"><p><strong>[V] An Analysis of Automated Visual Analysis Classification: Interactive Visualization Task Inference of Cancer Genomics Domain Experts  <a href="http://vis.cs.brown.edu/docs/pdf/g/Gramazio-2018-AAV.pdf.html">[PDF]</a></strong></p></div><p>本文展示了鼠标交互日志分类如何帮助可视化工具匠理解他们的工具是如何使用的，本文的主要贡献是对12个可视化分析任务分类器的评估，它将基因组学和可视化专家的预测与任务推断进行比较，本文的评估使用的大多数可视化评估器都可以访问的常见分类器:k近邻、线性支持向量机和随机森林。通过比较分类器的预测和专家做出的视觉分析任务推断，团队发现简单的自动任务分类可以有高达73%的准确率，并且可以从“垃圾”日志中分离出有意义的日志，准确率高达91%。本文的第二项贡献是利用分类预测探索常见的MAGI相互作用趋势，这扩展了当前关于生态癌症基因组可视化任务的知识，第三个贡献是讨论自动化任务分类如何为迭代工具设计提供信息，这些贡献表明，鼠标交互日志分析是一种可行的方法，可用于(1)评估以客户端为中心的工具的任务需求，(2)允许研究人员对专家进行比通常可能的实验室观察更大规模的研究，以及(3)突出潜在的工具评估偏差</p><hr><h2 id="Animation-and-Sports"><a href="#Animation-and-Sports" class="headerlink" title="Animation and Sports"></a>Animation and Sports</h2><div class="note default modern"><p><strong>[I] A Comparative Evaluation of Animation and Small Multiples for Trend Visualization on Mobile Phones <a href="https://arxiv.org/pdf/1907.03919">[PDF]</a></strong></p></div><p>本文比较了移动电话上分散图的动画和小倍数变量的有效性，以比较多变量数据集的趋势。可视化在移动应用程序和移动优先的网站中越来越流行，但是对于小型显示器的可视化研究还很少，在这篇论文中，团队建立在先前的实验研究上进行了更大的显示，评估了动态和非动态散点图的变化。结合类似的实验刺激和任务，本文进行了一项实验，让96名众包工作者使用他们的手机进行9项趋势比较任务。团队发现，那些使用小的多重设计的人持续地在更短的时间内完成任务，尽管与使用动画设计的人相比，他们的自信心略低。准确性结果更多地依赖于任务，作者根据单个任务的特点进一步解释结果，并特别关注每个任务中目标和干扰数据项的轨迹。文中确定的案例倾向于动画或小的倍数，为进一步的实验研究和在移动设备上的可视化设计提供了新的问题</p><div class="note default modern"><p><strong>[I] A Comparison of Visualizations for Identifying Correlation Over Time and Space <a href="https://arxiv.org/pdf/1907.03919">[PDF]</a></strong></p></div><p>在许多领域中，观察空间和时间上两个或多个变量之间的关系是必不可少的。例如，观察不同国家出生时的预期寿命和生育率的演变，就可以对这些国家的人口结构进行概述。为这类多变量数据选择可视化表示是使分析师能够提取模式和趋势的关键。以前的工作比较了地理时间的可视化技术，例如在空间和时间上演化的单一主题变量，或者在特定时间点上演化的两个变量。但是可视化技术在交流随着时间和空间的变化而变化的两个变量之间的相关性方面的有效性还有待研究。本文报告了一项比较三种技术的研究，这些技术代表了可视化地理-时间多元数据的不同策略:对给定的时间步长并置所有的位置，或者对给定的位置并置所有的时间步长;以及使用覆盖在地图特征之上的符号或使用地图特征本身的可视通道来编码主题属性。参与者执行了一系列的任务，要求他们识别两个变量是否随着时间的推移而相互关联，以及在他们的进化过程中是否存在某种模式。任务在时间这两个维度上的粒度不同(所有时间步长，一个子步长，只有一步)和空间步长(所有位置，子区域中的位置，只有一个位置)。结果表明，可视化的有效性在很大程度上取决于要执行的任务，在此基础上，提出了一套用于通信关联的时空可视化技术的设计准则</p><div class="note default modern"><p><strong>[I] Common Fate for Animated Transitions in Visualization <a href="http://users.umiacs.umd.edu/~elm/projects/common-fate/common-fate.pdf">[PDF]</a></strong></p></div><p>格式塔心理学的共同命运定律指出，视觉物体以相同的速度沿平行轨迹运动时，将被观察者视为一组，然而，共同命运的概念远比仅仅速度更为广泛：在这篇文章中，作者探讨了共同的命运如何导致协调变化的亮度和大小。本文展示了一项众包图形感知研究的结果，在该研究中，要求员工对一系列涉及四个图形对象的实验进行感知判断，这些对象在静态和动态视觉因素(位置、大小和亮度)相互冲突的影响下进行判断。结果得到如下的视觉分组排名:移动 &gt; (动态亮度，大小，亮度); 动态尺寸&gt;(动态亮度、位置); 和动态亮度&gt;大小。团队还进行了后续实验，利用类似gapminder的动画散点图和选举数据的主题地图，在一个更生态有效的环境中评估三个动态视觉因素。结果表明，在实际应用中，这些因素的相对分组强度可能取决于各种参数，包括可视化特征和基础数据</p><hr><h2 id="Multivariate-amp-Multidimensional-Data"><a href="#Multivariate-amp-Multidimensional-Data" class="headerlink" title="Multivariate &amp; Multidimensional Data"></a>Multivariate &amp; Multidimensional Data</h2><div class="note default modern"><p><strong>[V] Taxonomizer: A Visual Analytics Framework for Constructing Fully Labeled Hierarchies from Multivariate Data <a href="https://pdfs.semanticscholar.org/6a16/c48f5e0ec94fa20c9b5dffbe4cd0d0703738.pdf">[PDF]</a></strong></p></div><p>按照多维数据空间的维度或属性组织它们是一项相当困难的任务。这一领域的大部分工作都集中在统计方面，如相关性聚类、降维等等。这些方法通常生成层次结构，其中叶节点由属性名标记，而内部节点通常仅由统计度量和标准表示，如阈值。这使得主流用户很难理解它们。另一方面，科学、生物学、工程等领域的分类很容易理解，因为它们在内部节点上也提供了有意义的标签。自动标记分类的内部节点需要识别上位概念(hypernyms)。本文提出的框架叫做Taxonomizer，采用一种可视化分析方法来应对这一挑战。它呼吁人类的智慧来联系最新的数据分析、神经词嵌入和词汇数据库。它由一组可视化工具组成，这些工具从一个自动计算的层次结构开始，其中叶节点是原始数据属性，然后它允许用户为任何多元数据集造型高质量的分类</p><div class="note default modern"><p><strong>[I] An Incremental Dimensionality Reduction Method for Visualizing Streaming Multidimensional Data <a href="https://arxiv.org/pdf/1905.04000">[PDF]</a></strong></p></div><p>维数降维(DR)方法是多维数据分析和可视化的常用方法。然而，当数据是一个实时流媒体，传统的DR方法不能直接使用，因为他们的计算复杂性和不能保持预测的数据位置在以前的时间点。此外，当动态数据记录具有不同的维数时，这个问题就变得更加具有挑战性，就像在实际应用程序中经常发现的那样</p><p>本文提出了一种增量DR解。作者团队通过几种方式增强了现有的增量主成分分析方法，以确保其可用于可视化流化多维数据，首先，采用几何变换和动画的方法，在可视化递增时保持观众的心理地图，其次，为了处理数据维数的变化，使用了一种优化的方法来估计投影数据的位置，并且将结果的不确定性传达到可视化中的。最后用两个真实数据集的案例研究来证明设计的有效性</p><div class="note default modern"><p><strong>[S] TTHRESH: Tensor Compression for Multidimensional Visual Data <a href="https://pdfs.semanticscholar.org/d09c/0fadd4845116fc4bc24fa38f612d4e4f24e3.pdf">[PDF]</a></strong></p></div><p>在可视化应用程序中，内存和网络带宽是处理高分辨率多维数据集的决定性瓶颈，它们越来越需要合适的数据压缩策略。本文针对常规网格上的多维数据，提出了一种新的有损压缩算法。它利用高阶奇异值分解(HOSVD)，将奇异值分解推广到三维及更高的奇异值分解，并结合位平面、行程长度和算术编码来压缩HOSVD变换系数。本文的方案在低到中比特率的情况下，特别平滑地降低数据，并实现比其他最先进的算法更低的平均平方误差，因为它在数据归档和可视化管理中是必需的。该算法的进一步优势包括非常细的比特率选择粒度和在压缩域中以非常小的代价操作数据的能力，例如重构所有(或选定部分)数据集的过滤和/或下采样版本</p><div class="note default modern"><p><strong>[V] Selection Bias Tracking and Detailed Subset Comparison for High-Dimensional Data <a href="https://arxiv.org/pdf/1906.07625">[PDF]</a></strong></p></div><p>大型、复杂数据集的收集已经成为广泛领域的普遍现象。可视化分析工具在探索和回答有关这些大型数据集的复杂问题方面发挥着越来越重要的作用。然而，许多可视化设计并不是为了同时可视化复杂数据集中出现的大量维数。这一事实，再加上许多可视化分析系统的能力，使得基于一小部分可视化维度的快速、特别的组或组的指定成为可能。这导致引入选择偏差的可能性——当用户基于一组指定的维度创建队列时，许多其他未见的维度之间的差异也可能被引入。这些非预期的副作用可能导致队列不再代表拟研究的更大人群，从而对后续分析的有效性产生负面影响。</p><p>本文介绍了选择性偏差跟踪和可视化技术，这些技术可以整合到高维探索性视觉分析系统中，重点关注具有现有数据层次结构的医疗数据。这些技术包括：(1)基于树的队列来源和可视化，包括一个用户指定的基线队列，所有其他队列进行比较，队列“漂移”的可视化编码，这表明在哪里可能发生选择偏差; (2)一组可视化，包括一种新的基于冰柱图的可视化，用于详细比较基线和用户指定的焦点队列之间的每维度差异。这些技术被集成到一个医学时间事件序列可视化分析工具中。本文提供了示例用例，并报告来自领域专家用户访谈的结果</p><div class="note default modern"><p><strong>[V] Visual Analysis of High-Dimensional Event Sequence Data via Dynamic Hierarchical Aggregation <a href="https://arxiv.org/pdf/1906.07617">[PDF]</a></strong></p></div><p>时间事件数据在广泛的领域中收集，并且开发了各种可视化分析技术来增强分析人员处理这种形式的数据的能力。这些技术通常显示对共享公共模式的事件序列集计算的聚合统计信息。然而，现实世界中许多事件序列数据集的高维性阻碍了这些技术的有效聚合。应对这一挑战的一种常见策略是在可视化之前将事件类型组合在一起，作为一个预处理过程，以便在分析中将每个事件类型表示为单个事件类型。但是，将这些事件分组计算为预处理过程也给分析带来了很大的限制。</p><p>这篇文章提出了一种新的动态层次维数聚集可视化分析方法，该方法利用预定义的维度层次结构来计算量化运行时层次结构中分组的可选级别的信息(相对于感兴趣的度量)。主要贡献包括为特定分析上下文交互式地确定信息最丰富的事件分组集的算法，以及带有基于优化布局算法的香味(scented)分散焦点可视化设计，该算法支持对可选事件类型分组的交互式分层探索</p><hr><h2 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h2><div class="note default modern"><p><strong>[I] Construct-A-Vis: Free-Form Visualization Creation for Children <a href="http://kops.uni-konstanz.de/bitstream/handle/123456789/46713/Bishop_2-1lohcsy3k3ob6.pdf?sequence=3&isAllowed=y">[PDF]</a></strong></p></div><p>建立数据分析技能是现代小学课程的一部分。最近的研究探索了如何通过突出具体映射和抽象映射之间的联系的完成练习来促进儿童对视觉数据表示的理解。这种方法通过向儿童展示一个目标可视化来搭建可视化活动的支架。但是，怎样才能让孩子们参与到更自由形式的视觉数据制图练习中来呢? 如何构建一个创造性的探索可视化技术和地图的可能性? </p><p>本文展示了一个基于平板电脑的工具Construct-A-Vis，旨在探索与小学儿童进行自由形式和建设性可视化活动的可行性。vis提供了可调级别的脚手架可视化映射过程，它可以供孩子单独使用，也可以作为合作活动的一部分。一项针对小学儿童单独或成对使用Construct-A-Vis单独和成对强调这种自由形式的建设性方法的潜力，在孩子们的各种可视化结果和他们对数据和绘图过程的关键参与中可见。基于研究结果，作者团队对儿童自由形式可视化工具的设计贡献了见解，包括基于工具的脚手架机制的作用，以及指导儿童可视化活动的共享交互</p><div class="note default modern"><p><strong>[I] Decoding Complex Visualizations in Science Museums – An Empirical Study <a href="https://arxiv.org/pdf/1907.13193">[PDF]</a></strong></p></div><p>本文描述了博物馆参观者解码过程的详细分析，因为他们使用可视化设计来支持对一个大型、复杂的数据集的探索。定量和定性分析显示，访客平均要花43秒的时间来解读足够多的可视化数据，以了解隐含数据中的模式和关系，而要花54秒的时间来得到他们第一次正确的数据解读。此外，游客在整个过程中都在解码，而不仅仅是在最初使用可视化的时候。该研究分析了有声思维的数据，以确定游客在将视觉表征映射到他们的预期参照对象时所遇到的问题，研究了这些问题发生的原因，并考虑了这些解码问题是否以及如何得到解决。本文还描述了多种视觉编码是如何帮助和阻碍解码的，并总结了非正式科学学习场所视觉化设计和适应的启示</p><div class="note default modern"><p><strong>[I] Investigating Direct Manipulation of Graphical Encodings as a Method for User Interaction <a href="https://hal.archives-ouvertes.fr/hal-02260450/document">[PDF]</a></strong></p></div><p>本文研究直接操作图形编码作为一种与可视化交互的方法。人们对开发可视化工具越来越感兴趣，这些工具使用户能够通过直接操作图形编码来执行操作，而不是像复选框和滑块这样的外部小部件。此类工具的设计者必须决定应该支持哪些直接操作，并确定如何调用每个操作。然而，对于人们如何使用图形编码的直接操作来传达他们预期的操作，我们缺乏经验指导方针。本文通过进行定性研究来解决这个问题，研究参与者如何使用直接操作标准图形编码执行15个操作。</p><p>从这项研究中，1)确定了人们用于执行每项操作的策略列表，2)观察跨操作策略的共性，3)得出启示，以帮助设计者利用图形编码的直接操作作为用户交互的一种方法</p><div class="note default modern"><p><strong>[S] Artifact-Based Rendering: Harnessing Natural and Traditional Visual Media for More Expressive and Engaging 3D Visualizations <a href="https://128.84.21.199/pdf/1907.13178">[PDF]</a></strong></p></div><p>本文介绍了基于人工渲染(ABR)，一种工具、算法和流程的框架，它使使用完全源自传统物理媒体或在自然中创建的颜色、线条、纹理和形式的视觉语言产生真实的、数据驱动的3D科学可视化成为可能。ABR的理论和过程被提出来解决三个当前的需求:(i)设计更好的可视化，使非程序员能够快速地设计和评论许多可供选择的数据到可视化的映射;扩大科学可视化中使用的视觉词汇，以描述日益复杂的多变量数据;(iii)为数据可视化带来更迷人、更自然、更人性化的手工美学。支持ABR的新工具和算法包括用于构建基于人工的色彩地图、优化用于数据可视化的3D扫描网格以及从人工制品合成纹理的前端小应用程序。这些都是由一个交互式渲染引擎与定制算法和界面，展示了多种新的视觉风格描绘点，线，表面和体积数据补充。一项研究团队内部的设计研究提供了可视化设计过程的早期证据，ABR被认为可以使传统的科学可视化系统相比较。用户对气候科学和脑成像应用的定性反馈支持ABR在科学发现和公众传播方面的应用</p><div class="note default modern"><p><strong>[V] Origraph: Interactive Network Wrangling <a href="http://sci.utah.edu/~vdl/papers/2019_vast_origraph.pdf">[PDF]</a></strong></p></div><p>网络是思考许多数据集的一种自然方式。然而，网络所基于的数据很少以适合分析过程的形式收集，因此有必要创建和重塑网络。数据角力是数据分析管道中公认的重要组成部分，但交互式网络角力在可视化研究领域中却很少受到关注。</p><p>本文讨论了网络数据集纠集(wrangling)的一组重要操作，并介绍了一种可视化的数据纠集(wrangling)工具Origraph，这使得分析人员能够将这些操作应用到他们的数据集，关键操作包括从源数据(如表)创建网络、通过引入新节点或边类来重塑网络、过滤节点或边以及派生新节点或边属性。Origraph使分析人员可以执行这些操作，几乎不需要编程，并立即可视化结果。Origraph提供视图来调查网络模型，一个网络样本，节点和边缘属性，此外还引入了一些接口，旨在帮助分析人员为合理的网络争吵操作指定争论点，本文在两种情况下演示了定向仪的有用性：首先，调查了电影行业中的性别偏见，然后是金钱对也门战争的政治支持的影响</p><hr><h2 id="Immersion-and-Virtual-Environments"><a href="#Immersion-and-Virtual-Environments" class="headerlink" title="Immersion and Virtual Environments"></a>Immersion and Virtual Environments</h2><div class="note default modern"><p><strong>[I] MARVisT: Authoring Glyph-based Visualization in Mobile Augmented Reality <a href="http://www.cse.ust.hk/~huamin/tvcg_zhutian_2019.pdf">[PDF]</a></strong></p></div><p>移动增强现实(AR)技术的最新进展为个人可视化提供了新的思路，其优势在于将可视化融入个人日常生活，将可视化置于现实环境中，并引起用户的兴趣。然而，让非专业人士在移动AR环境中创建数据可视化是一项挑战，因为缺乏支持数据与AR内容绑定的现场设计工具。大多数现有的增强现实创作工具需要在个人电脑上工作，或者手工创建每个虚拟对象并修改其可视化属性。</p><p>本文根据AR符号的可视化创作工具的特殊性总结出四个设计注意事项，对这一问题进行了系统的研究。根据这些设计考虑，团队设计并实现了MARVisT，一个移动创作工具，它利用来自现实的信息来帮助非专家处理数据和虚拟符号，真实对象和虚拟符号，以及真实对象和数据之间的关系。有了MARVisT，没有可视化专业知识的用户可以将数据绑定到真实世界的对象，从而快速、毫不费力地创建富有表现力的基于AR图形的可视化，用数据重塑真实世界的表现形式。我们用几个例子来展示奇迹的表现力。用户研究与非专家也进行评估的创作经验的MARVisT</p><div class="note default modern"><p><strong>[I] Designing for Mobile and Immersive Visual Analytics in the Field <a href="https://cmci.colorado.edu/visualab/fieldview/fieldview.pdf">[PDF]</a></strong></p></div><p>数据收集和分析对于环境科学和公共安全等领域的运作至关重要。然而，现场工作者在高效收集和分析现场数据时，目前面临着面向数据和平台的问题，如连接有限、屏幕空间有限、注意力资源有限等</p><p>在本文中，探索了可视化分析工具如何通过更深入地将数据集成到现场实践中来改变现场实践。团队使用结合移动、云和浸入式分析组件的设计探针，与来自5个领域的10位专家进行访谈，以探索可视化分析如何支持该领域的数据收集和分析需求。结果确定了当前方法的缺点，目标场景和未来现场分析系统的设计考虑。团队将这些发现体现在FieldView中，这是一个可扩展的、开放源码的原型，设计用于支持对位置字段分析的关键用例。研究结果表明，将移动和沉浸式技术集成在一起的潜力，可以增强数据在各种野外作业中的实用性，也可以为可视化分析工具提供新的方向，从而改变野外工作的面貌</p><div class="note default modern"><p><strong>[I] Evaluating an Immersive Space-Time Cube Geovisualization for Intuitive Trajectory Data Exploration <a href="http://ws.iat.sfu.ca/papers/stcvirtualdesk.pdf">[PDF]</a></strong></p></div><p>时空立方体使分析人员能够清晰地观察到地理可视化中运动轨迹数据集的时空特征。然而，缺乏深度线索、陡峭的学习曲线以及对高效的3D导航的需求，都影响了它的一般可用性</p><p>在这项工作中，团队研究浸入式分析领域中的一个时空立方体。基于对之前工作的回顾和选择适当的探索隐喻，构建了一个原型环境，其中立方体与分析师真实办公桌的虚拟表示相结合，使用空中手势直观地控制空间和时间的缩放和平移。在一项用户研究中，团队将沉浸式环境与基于桌面的实现进行了比较，20名参与者参与了针对不同用户界面特性的7项不同难度的任务。为了研究杂波的存在如何影响性能，本文探索了两种具有不同数量轨迹的情况。虽然大多数任务的定量表现是相似的，但当分析交互模式和考虑主观指标时，就会出现巨大的差异。身临其境的时空立方体获得了更高的可用性分数，更高的用户偏好，并且被认为有更低的精神负荷，在25分钟的虚拟现实会话中不会让参与者感到不适</p><div class="note default modern"><p><strong>[I] The Impact of Immersion on Cluster Identification Tasks <a href="https://kops.uni-konstanz.de/bitstream/handle/123456789/47308/Kraus_2-1nayktaycvl2e3.pdf?sequence=1">[PDF]</a></strong></p></div><p>最近的技术发展鼓励使用头戴式显示器(HMDs)作为一种媒介来探索虚拟现实(VRs)中的可视化。与传统的计算机屏幕相比，VR环境(VREs)提供了新的、更具身临其境感的可视化设计空间。以往在医学、心理学、地质学等不同领域的研究都报告了浸入式学习对学习表现或恐惧症治疗效果的积极影响</p><p>在这篇论文中提出的工作评估了这些发现对来自信息可视化(InfoVis)领域的共同任务的适用性，团队进行了一项定量的用户研究，以调查沉浸感对散点图可视化中聚类识别任务的影响。主要的实验由18名参与者进行，他们在被试中使用了四种不同的视觉效果，(1)屏幕上的二维散点图矩阵，(2)屏幕上的三维散点图，(3)VRE作品中的三维散点图缩影，(4)VRE作品中的完全沉浸式三维散点图。四个可视化设计空间的沉浸程度不同，如补充研究所示。本研究的主要研究结果显示，被调查的视觉化设计空间在准确性、效率、记忆性、方向感和用户偏好等方面的任务表现有所不同。特别是，就测量变量而言，屏幕上2D可视化的表现要比3D可视化差。研究表明，在3D数据和聚类检测的背景下，浸入性水平的提高可以带来实质性的好处</p><div class="note default modern"><p><strong>[I] There Is No Spoon: Evaluating Performance, Space Use, and Presence with Expert Domain Users in Immersive Analytics <a href="http://users.umiacs.umd.edu/~elm/projects/nospoon/nospoon.pdf">[PDF]</a></strong></p></div><p>沉浸式抽象分析将用户周围的空间变成了数据分析的画布，以多种方式支持人类的认知能力。本文展示了一项设计研究、背景调查和纵向评估的结果，涉及专业经济学家使用虚拟现实(VR)系统多维可视化来探索实际经济数据。评估结果强调了空间的不同使用取决于环境(探索与展示)，空间的组织来支持工作，以及沉浸感对三维分析空间中的导航和方向的影响</p><div class="note default modern"><p><strong>[S] Deadeye Visualization Revisited: Investigation of Preattentiveness and Applicability in Virtual Environments <a href="https://arxiv.org/pdf/1907.04702">[PDF]</a></strong></p></div><p>视觉化依靠高亮来吸引和引导我们的注意力。为了使一个感兴趣的物体独立于许多干扰物中脱颖而出，潜在的视觉线索，例如颜色，必须具有先注意性，在之前的工作中，团队介绍了Deadeye作为一种即时可识别的高亮技术，它通过仅为一只眼睛渲染目标物体而工作。与之前的方法不同，死眼的优点是不改变目标的任何视觉属性。但是，在2D可视化的情况下，该方法需要额外的设置来允许dichoptic表示，这是一个相当大的缺点。作为社区请求的后续，本文探索了Deadeye作为3D可视化的突出显示技术，因为这样的立体场景支持开箱即用的dichoptic表示。死眼抑制目标物体的双目差异，因此不能假定技术的适用性作为一个既定的事实。基于这一动机，本文提出了虚拟现实中死眼的定量评估，包括具有多个异质干扰的配置，作为一个重要的鲁棒性挑战。在确定了这种真实环境下的保留先验(平均精度均在90%以上)后，团队探索了VR体绘制作为Deadeye应用场景的实例。本文为集成技术描述了一个可能的工作流程，进行了一个探索性的调查来证明好处和限制，最后提供了相关的设计含义</p><hr><h2 id="Planning-and-Situational-Awareness"><a href="#Planning-and-Situational-Awareness" class="headerlink" title="Planning and Situational Awareness"></a>Planning and Situational Awareness</h2><div class="note default modern"><p><strong>[I] A Systematic Review of Visualization in Building Information Modeling  <a href="http://eprints.whiterose.ac.uk/146384/1/author_TVCG2907583.pdf">[PDF]</a></strong></p></div><p>建筑信息建模(BIM)采用数据丰富的3D CAD模型进行大型设施的设计、施工和运营。这些复杂的数据集包含大量和各种各样的信息，从设计规范到实时传感器数据。他们被建筑师和工程师用于各种分析和模拟整个设施的生命周期。可以使用来自不同可视化领域的许多技术来分析这些数据，然而，BIM领域在很大程度上仍未被可视化界所探索。这篇文章的目的是鼓励可视化研究人员增加对BIM的参与</p><p>为此，本文介绍了当前BIM实践中可视化的系统回顾结果，使用一种新的分类法来识别主要的应用领域并分析常用的技术。从这个领域的描述中，本文强调了BIM的独特特征带来的未来研究机会。例如，探索科学和信息可视化之间的协同作用，以集成空间和非空间数据。作者希望这篇文章能让人们意识到BIM领域给可视化社区带来的有趣的新挑战</p><div class="note default modern"><p><strong>[V] PlanningVis: A Visual Analytics Approach to Production Planning in Smart Factories <a href="https://arxiv.org/pdf/1907.12201">[PDF]</a></strong></p></div><p>制造业的生产计划对于充分利用工厂资源(如机器、原材料和工人)和降低成本至关重要。随着工业4.0的到来，大量记录工厂资源状况的数据被收集起来，并进一步参与到生产计划中，这为通过数据驱动的方法理解、评估和调整复杂的生产计划带来了前所未有的机会。然而，由于生产数据量大，产品之间的复杂依赖关系，以及市场和工厂的意外变化，开发一个系统的生产计划分析方法是具有挑战性的。以往的研究只提供了总结的结果，没有提供生产计划对比分析的细节。此外，在意外事件发生时快速调整计划也不被支持</p><p>本文提出PlanningVis视觉分析系统，以支持生产计划的探索和比较三个级别的细节:一个计划概述呈现整体计划的区别，产品视图可视化各个产品的各项性能，和生产细节视图显示产品的依赖和日常生产细节相关的工厂，PlanningVis通过将自动规划算法与交互式可视化探索相结合，可以促进日常生产计划的高效优化，并支持对生产过程中意外事件的快速响应。两个案例研究与现实数据和精心设计的访谈领域专家证明了计划vis的有效性和可用性</p><div class="note default modern"><p><strong>[V] sPortfolio: Stratified Visual Analysis of Stock Portfolios <a href="http://vis.cse.ust.hk/groups/finvis/paper/sportfolio.pdf">[PDF]</a></strong></p></div><p>建立在稳健的金融理论基础上的定量投资，是当今投资行业的中心舞台。定量投资的本质是多因素模型，它解释了股票的风险和收益之间的关系。然而，多因素模型产生了大量的因素数据，即使是经验丰富的投资组合经理也很难驾驭这些数据。这导致投资组合分析和因素研究受到缺乏直观的视觉分析工具的限制。以往的投资组合可视化系统主要关注投资组合收益和股票持有量之间的关系，这对于做出可操作的洞察或了解市场趋势是不够的</p><p>本文提出了sPortfolio，据作者所知，这是第一个试图探索因素投资领域的可视化。特别是，sPortfolio提供了因素数据的整体概述，旨在促进三个不同水平的分析:风险因素水平，用于一般市场情况分析;多投资组合层次，用于理解投资组合策略;和单一投资组合水平，用于调查详细的操作。通过三个案例研究，验证了系统的有效性和可用性。该系统已通过试点研究，很快将投入工业生产</p><hr><h2 id="XAI-and-Fairness"><a href="#XAI-and-Fairness" class="headerlink" title="XAI and Fairness"></a>XAI and Fairness</h2><div class="note default modern"><p><strong>[V] explAIner: A Visual Analytics Framework for Interactive and Explainable Machine Learning <a href="https://bib.dbvis.de/uploadedFiles/2019-08-02paper.pdf">[PDF]</a></strong></p></div><p>本文提出了一个交互式和可解释的机器学习框架，使用户能够(1)理解机器学习模型;(2)使用不同可解释AI方法诊断模型局限性;以及(3)对模型进行细化和优化</p><p>本文框架结合了一个迭代的XAI管道和8个全局监测和指导机制，包括质量监控、源头跟踪、模型比较和信任建立。为了实现框架的操作，提出了explAIner，这是一个用于交互式和可解释的机器学习的可视化分析系统，它实例化了常用的TensorBoard环境中建议管道的所有阶段，本文进行了一个用户研究，有9个不同专业水平的参与者，以检查他们对工作流的看法，并收集建议来填补系统和框架之间的差距</p><div class="note default modern"><p><strong>[V] FairSight: Visual Analytics for Fairness in Decision Making <a href="https://arxiv.org/pdf/1908.00176">[PDF]</a></strong></p></div><p>数据驱动的个人决策越来越普遍，但最近的研究提出了有关潜在歧视的问题。作为回应，研究人员已经努力提出和实施公平措施和算法，但这些努力还没有转化为实际的数据驱动决策。因此，仍然迫切需要创造一种可行的工具来促进公平决策。</p><p>本文提出了一个可视化分析系统FairSight来满足这一需求;它旨在通过确定所需的行动——理解、测量、诊断和减轻偏见——来实现决策排序的不同公平概念，这些行动共同导致更公平的决策。通过实例研究和用户研究，证明了系统中所提出的可视化分析和诊断模块能够有效地理解公平感知决策流程，获得更公平的决策结果</p><div class="note default modern"><p><strong>[V] Summit: Scaling Deep Learning Interpretability by Visualizing Activation and Attribution Summarizations <a href="https://fredhohman.com/papers/19-summit-vast.pdf">[PDF]</a></strong></p></div><p>深度学习越来越多地用于决策任务。然而，理解神经网络如何产生最终的预测仍然是一个基本的挑战。现有的解释神经网络对图像的预测的工作通常集中在解释单个图像或神经元的预测。由于预测通常是通过对数百万幅图像进行优化的数百万权重进行计算，这样的解释很容易忽略更大的图像</p><p>本文展示的SUMMIT是一个交互式系统，它可以大规模、系统地总结和可视化深度学习模型已经学习的特征，以及这些特征如何相互作用，从而做出预测，SUMMIT介绍了两种新的可伸缩总结技术:(1)激活聚合发现重要的神经元，(2)神经元影响聚合识别这些神经元之间的关系。SUMMIT结合了这些技术来创建一个新颖的属性图，它揭示和总结了对模型结果有贡献的关键神经元联系和子结构。SUMMIT扩展到大型数据，例如具有1.2M图像的ImageNet数据集，并利用神经网络特性可视化和数据集示例帮助用户将大型、复杂的神经网络模型提取为紧凑的交互式可视化。本文提出了神经网络探索场景，其中SUMMIT帮助发现了一个普遍的、大规模图像分类器学习表示的多种惊人见解，并为未来的神经网络架构设计提供了信息。SUMMIT visualization在现代web浏览器中运行，并且是开源的</p><div class="note default modern"><p><strong>[V] FairVis: Visual Analytics for Discovering Intersectional Bias in Machine Learning <a href="https://arxiv.org/pdf/1904.05419">[PDF]</a></strong></p></div><p>随着机器学习能力和可访问性的不断增强，它已经被应用到许多真实世界的领域和关于人的数据中。尽管算法系统可能带来好处，但模型可以反映、注入或加剧其输出中隐含或明确的社会偏见，使某些人口统计亚群体处于不利地位。发现一个机器学习模型引入了哪些偏差是一个巨大的挑战，因为有许多关于公平的定义和大量可能受到影响的子群体。</p><p>本文提出FAIRVIS，一个混合首创的视觉分析系统，集成了一种新颖的子组发现技术，使用户可以审计机器学习模型的公平性，通过FAIRVIS，用户可以利用领域知识来生成和研究已知的子组，以及探索建议的和相似的子组，FAIRVIS的协调视图使用户能够探索子组性能的高级概述，并随后深入到特定子组的详细研究中，本文展示了FAIRVIS如何帮助发现用于预测收入和再犯的两个真实数据集的偏差。作为一个致力于发现机器学习偏差的视觉分析系统，FAIRVIS展示了交互式可视化如何帮助数据科学家和普通公众理解和创建更公平的算法系统</p><div class="note default modern"><p><strong>[V] Visual Genealogy of Deep Neural Networks <a href="https://pdfs.semanticscholar.org/096e/71222c3cbce410211c4fa0dccc9ffbc508ac.pdf">[PDF]</a></strong></p></div><p>对现有的深度神经网络(DNNs)进行全面和可理解的总结，有助于从业者理解DNNs的行为和进化，为结构优化提供见解，并阐明DNNs的工作机制。然而，由于DNN体系结构的复杂性和多样性，这种总结很难得到</p><p>为了解决这个问题，本文提出DNN系谱，一个交互式可视化工具，提供一个具有代表性的DNN及其进化关系的可视化摘要。DNN Genealogy使用户能够从多个方面学习DNNs，包括建筑、性能和进化关系。该工具的核心是基于我们对140篇论文的分析，对66个具有代表性的DNNs进行系统分析和可视化，一个有向无环图用于说明这些DNNs之间的进化关系，并突出有代表性的DNNs。在用户探索过程中，开发了一个焦点+上下文可视化来定位用户，图中使用了一组网络符号，便于理解和比较进化上下文中的DNNs。案例研究表明，DNN系谱学为理解、应用和优化DNN提供了有益的指导。DNN系谱是可扩展的，并将继续更新，以反映未来的进展在DNNs</p><hr><h2 id="Vis-for-Software-and-Systems"><a href="#Vis-for-Software-and-Systems" class="headerlink" title="Vis for Software and Systems"></a>Vis for Software and Systems</h2><div class="note default modern"><p><strong>[V] CloudDet: Interactive Visual Analysis of Anomalous Performances in Cloud Computing Systems <a href="https://arxiv.org/pdf/1907.13187">[PDF]</a></strong></p></div><p>检测和分析云计算系统中可能出现的异常性能，对于避免给客户造成损失，确保系统高效运行至关重要。为此，开发了各种自动化技术来识别云计算性能中的异常情况。这些技术通常用于跟踪系统的性能指标(例如CPU、内存和磁盘I/O)，这些指标由多元时间序列表示。然而，由于云计算数据的复杂特性，这些自动化方法的有效性受到了影响。因此，异常解释需要人工对自动分析结果进行大量判断</p><p>本文提出了一个统一的可视化分析系统CloudDet，用于交互地检测、检查和诊断云计算系统中的异常。基于给定度量数据的特定时间模式(如周期模式)，开发了一种新的无监督异常检测算法来识别异常，其结果将在系统中可视化，以表明异常的发生。丰富的可视化和交互设计被用来帮助理解空间和时间环境中的异常。团队通过定量评估、两个使用真实数据的案例研究和与领域专家的访谈来证明CloudDet的有效性</p><div class="note default modern"><p><strong>[I] Visualizing a Moving Target: A Design Study on Task Parallel Programs in the Presence of Evolving Data and Concerns <a href="https://arxiv.org/pdf/1905.13135">[PDF]</a></strong></p></div><p>可视化项目中常见的陷阱包括缺乏数据可用性、领域用户的需求和关注点变化太快，以致于无法完成设计过程。虽然避免这样的项目通常是谨慎的，但作者认为在某些情况下使用它们是有益的，因为可视化过程可以帮助细化数据收集，解决拥有数据和工具来分析它的“鸡和蛋”问题。本文发现，这是在任务并行计算领域的情况下，这样的数据和工具是一个开放的研究领域。尽管存在这些障碍，团队还是进行了设计研究。通过紧密耦合的迭代设计过程，构建了Atria，一个支持性能分析的多视图执行图形可视化。Atria通过聚集与代码行相关的节点来简化执行图的初始表示。作者团队在多个平台上部署了Atria，有些需要修改设计。本文将描述如何调整设计研究方法以适应数据和领域专家关注的“移动目标”，以及这种移动如何保持可视化和编程项目的健康。团队对过程进行反思，并讨论在数据和用户需求不断变化的情况下，哪些因素使项目能够成功</p><div class="note default modern"><p><strong>[I] How People Visually Represent Discrete Constraint Problem <a href="https://research-repository.st-andrews.ac.uk/bitstream/handle/10023/16952/Zhu_2019_How_people_visually_IEEETVCG_AAM.pdf?sequence=1">[PDF]</a></strong></p></div><p>尽管现有的约束解决软件在许多情况下可以快速地解决比如时间表或人员分配的问题，但这些系统涉及到需要大量时间和精力来学习和应用专门语言，这些语言通常是基于文本的，很难快速解释和理解，特别是对于没有工程或数学背景的人。可视化为建模和理解这类问题提供了另一种方法。虽然面向过程化语言的可视化编程语言有很多，但问题规范的可视化编码一直没有得到足够的重视</p><p>作为这类语言的第一步，团队进行了一项研究，将人们如何用图形表示约束问题进行了分类。本文研究了具有不同专业知识的三组人:非计算机科学家、计算机科学家和约束程序员，并分析了他们在纸上的标记(如箭头)、手势(如指向)和到问题概念的映射(如容器、集合)。本文提供基础来指导未来的工具设计，使人们能够通过可视化表示有效地掌握、建模和解决问题</p><div class="note default modern"><p><strong>[I] Preserving Command Line Workflow for a Package Management using ASCII DAG Visualization <a href="https://hdc.cs.arizona.edu/papers/tvcg_2018_graphterm_preprint.pdf">[PDF]</a></strong></p></div><p>包管理器通过消除成功地构建、安装和维护系统软件的耗时的、有时甚至是完全禁止的障碍，从而提供了对应用程序的轻松访问。包依赖关系包含构建和运行目标软件所需的所有包之间的依赖关系。包管理系统开发人员、包维护人员和用户可能会在简单的列表不足以进行分析时查阅依赖关系图。然而，在远程命令行环境中工作的用户必须中断他们的工作流，以便在图形程序中可视化依赖图，可能需要在设备之间移动文件或引起转发延迟。Spack用户的情况就是如此，Spack是一种开源包管理系统，最初开发它是为了简化超级计算环境所需的复杂构建。为了保持Spack的命令行工作流，团队开发了一个交互式的ASCII可视化依赖图，通过与Spack维护者的访谈，确定了依赖关系图的用户目标和相应的可视化任务。团队通过以命令行为中心的研究来评估可视化的使用情况，并将其与系统现有的两种方法进行比较。团队观察到，尽管ASCII表示有限制，但参与者在从命令行界面工作流接近本文的可视化时更喜欢</p><div class="note default modern"><p><strong>[S] Inviwo - A Visualization System with Usage Abstraction Levels <a href="https://arxiv.org/pdf/1811.12517">[PDF]</a></strong></p></div><p>当今可视化应用程序的复杂性要求为这些应用程序的开发量身定制特定的可视化系统。通常，这类系统利用抽象级别来改进应用程序开发过程，例如通过提供数据流网络编辑器。不幸的是，这些抽象会导致一些问题，需要通过以抽象为中心的系统设计来绕过这些问题。通常，高级抽象隐藏了低级细节，这使得直接访问底层计算平台变得困难，而底层计算平台对于实现最佳性能非常重要。因此，本文提出了一种为现代和可持续的可视化系统开发的层结构，允许开发人员与所有包含的抽象层进行交互。作者将这种交互功能称为使用抽象级别，因为目标是具有不同经验级别的应用程序开发人员。本文制定了这样一个系统的需求，推导出所需的架构，并展示了这些概念是如何在Inviwo可视化系统中示范性地实现的</p><div class="note default modern"><p><strong>[V] Exploranative Code Quality Documents <a href="https://www.vis.wiwi.uni-due.de/uploads/tx_itochairt3/publications/code-quality-documents-preprint.pdf">[PDF]</a></strong></p></div><p>良好的代码质量是有效开发可维护软件的先决条件。本文提出了一种新的方法来生成探索性(解释性和探索性)数据驱动文档，在交互式的、探索性的环境中报告代码质量。本文使用基于模板的自然语言生成方法来创建关于代码质量的文本解释，依赖于来自软件度量的数据。交互式文档通过不同的可视化方式得到丰富，包括用于数据探索的平行坐标图和散点图以及嵌入到文本中的图形。团队设计了一种交互模型，允许用户通过文本和可视化之间的一致链接来探索代码质量;通过集成的解释性文本，用户被教导有关代码质量方面的背景知识。本文的交互式文档的方法是在一个设计研究过程中开发的，包括软件工程和视觉分析专家。尽管该解决方案是特定于软件工程场景的，但团队讨论了如何将该概念推广到多元数据，并在更广泛的范围内报告经验教训</p><hr><h2 id="Large-Data-and-Dimensionality-Reduction"><a href="#Large-Data-and-Dimensionality-Reduction" class="headerlink" title="Large Data and Dimensionality Reduction"></a>Large Data and Dimensionality Reduction</h2><div class="note default modern"><p><strong>[I] OntoPlot: A Novel Visualisation for Non-hierarchical Associations in Large Ontologies <a href="https://arxiv.org/pdf/1908.00688">[PDF]</a></strong></p></div><p>本体是概念和概念之间复杂关系的正式表示。它们被广泛用于捕获诸如生物学和医学等领域的全面领域知识，在这些领域中大型而复杂的本体可以包含成百上千个概念。特别是由于本体的规模很大，可视化对于创作、探索和理解它们的底层数据非常有用。现有的本体可视化工具通常侧重于层次结构，对非层次关联的重视程度低得多</p><p>本文提出了OntoPlot，一种新颖的可视化设计，旨在促进所有概念关联的探索，同时仍然显示本体的大型层次结构。这种混合的视觉效果结合了冰柱情节、视觉压缩技术和交互性，提高了空间效率，降低了视觉结构的复杂性，团队与领域专家进行了一项用户研究，以评估OntoPlot的可用性，并将其与事实上的本体编辑器Prot’eg’e进行比较。结果表明，OntoPlot达到了对关联相关任务的设计目标，受到了领域专家的强烈青睐。</p><div class="note default modern"><p><strong>[I] P5: Portable Progressive Parallel Processing Pipeline for Interactive Data Analysis and Visualization <a href="https://pdfs.semanticscholar.org/8c69/6c592a8b3d236ec0dea34bbfcb2208ad90d7.pdf">[PDF]</a></strong></p></div><p>本文提供了一个基于web的可视化工具包P5，它结合了声明性可视化语法和GPU计算，用于渐进式数据分析和可视化。为了交互式地分析和探索大数据，渐进式分析和可视化方法最近出现了。逐步细化结果的渐进式可视化具有允许用户控制分析过程和做出早期决策的优势。P5利用声明式语法来指定可视化设计，并利用GPU计算来加速数据的渐进处理和呈现。可以在渐进处理期间修改声明性规范，以创建用于分析中间结果的不同可视化。为了实现用户交互来进行渐进式数据分析，P5利用GPU基于声明式交互规范自动聚合和索引数据，以促进有效的交互可视化。本文通过各种示例应用程序和几个性能基准测试来演示P5的有效性和有用性</p><div class="note default modern"><p><strong>[I] RSATree: Distribution-Aware Data Representation of Large-Scale Tabular Datasets for Flexible Visual Query <a href="https://arxiv.org/pdf/1908.02005">[PDF]</a></strong></p></div><p>为了可视化和分析大型数据集，分析人员通常会研究由图表(例如直方图和bin - ned散点图)表示的数据统计聚合而来的数据分布。聚合查询通过这样一个流程隐式地执行。数据集总是非常大; 因此，应该通过计算预定义的数据集来加快响应时间。但是，查询仅限于预处理数据集的预定义绑定模式。这种局限性阻碍了分析人员灵活地调整可视化规范，以有效地研究数据中的隐式模式。</p><p>RSATree允许任意查询和灵活的装箱策略利用三个方案，即一个R-tree-based空间分区方案捕捉数据分布,locality-sensitive散列技术实现保随机访问数据项，和总结区域表方案支持交互式查询聚合值和一个线性计算复杂度，本研究提出并实现了一个基于web的可视化查询系统，该系统支持可视化规范、查询和探索具有用户可调粒度的大型表格数据。作者团队通过在真实数据集上进行各种实验并分析时间和空间复杂度来证明我们的方法的效率和效用。</p><hr><h2 id="Scatterplots"><a href="#Scatterplots" class="headerlink" title="Scatterplots"></a>Scatterplots</h2><div class="note default modern"><p><strong>[V] ScatterNet: A Deep Subjective Similarity Model for Visual Analysis of Scatterplots <a href="https://pdfs.semanticscholar.org/4ae9/e84dc7d7fbd731fc88bfbf350f148d1864f9.pdf">[PDF]</a></strong></p></div><p>相似度测量方法广泛应用于各种可视化应用中。在这项工作中，作者团队通过引入一种新的基于深度学习的方法来解决在散点图的视觉分析中表现人类感知的挑战，ScatterNet，抓住了这些情节中感知驱动的相似性。该方法利用深度神经网络提取散点图图像的语义特征，进行相似度计算。团队创建一个包含相似和不同散点图图像的大型标记数据集来训练深度神经网络，并进行了一系列评估，包括性能实验和用户研究，以证明方法的有效性和效率。评估结果表明，学习的特征有效地捕捉了人类对散点图相似度的感知，本文描述两个场景来展示如何将ScatterNet应用于视觉分析应用程序</p><div class="note default modern"><p><strong>[I] A Recursive Subdivision Technique for Sampling Multi-class Scatterplots <a href="http://www.yunhaiwang.net/infoVis2019/scatterplot/sampling.pdf">[PDF]</a></strong></p></div><p>本文提出了一种非均匀递归采样技术用于多类散点图，其具体目标是在保留主要异常值的情况下，忠实地呈现相关数据和类密度。该技术基于一个定制的二进制kd-树，其中的叶节点是通过递归地细分底层的多类密度图来创建的。通过回溯合并叶节点，直到它们包含所有类的点，为随后应用的离群感知多类抽样策略。定量评价表明，与以往的方法相比，该方法能更好地保留多类散点图中的异常值和相对密度，多个实例研究表明了本文方法在探索复杂和真实世界数据方面的有效性</p><div class="note default modern"><p><strong>[I] Data Sampling in Multi-view and Multi-class Scatterplots via Set Cover Optimization <a href="http://people.scs.carleton.ca/~olivervankaick/pubs/scatter_plots.pdf">[PDF]</a></strong></p></div><p>本文提出了一种在散点图中对不同视图或类进行联合优化点选择的数据采样方法，本文方法使用空间填充曲线(z级曲线)，将一个点集划分为子集，当每个子集被一个样本覆盖时，提供一个与原始点集具有良好近似保证的采样或共重置，对于多个视图的散点图矩阵，不同的视图提供不同的空间曲线，导致不同分区的给定的点集。多散点图、关注每个类分布或全球分销提供了两种不同分区的给定的点集，需要考虑在coreset的选择。对于这两种情况，团队将协同重置选择问题转化为精确选择问题覆盖问题(ECP)，并通过定量和定性评估证明有效解决ECP的近似解决方案能够提供高质量的采样</p><div class="note default modern"><p><strong>[I] Discriminability Tests for Visualization Effectiveness and Scalability <a href="https://arxiv.org/pdf/1907.11358">[PDF]</a></strong></p></div><p>特定可视化方法的可伸缩性受到人们辨别不同数据集绘制的图之间差异的能力的限制。理想情况下，当数据发生变化时，可视化会以可察觉的方式发生变化。当编码与所查看的数据集的字符不匹配时，此关系将失效。不幸的是，可视化的设计和评估往往没有充分探索它们将如何对各种各样的数据集作出响应。本文探讨了一种图像相似度度量的使用，多尺度结构相似度指数(MS-SSIM)，用于测试不同数据集的数据可视化的可判别性。MS-SSIM能够捕获跨多个尺度的两个可视化的相似性，包括低级别的粒度变化和高级模式。MS-SSIM没有捕捉到的重要数据更改表明可视化的可识别性和有效性较低。两项实证研究证明了该措施的效用。首先，团队比较人类相似度判断和MS-SSIM分数的散点图集合，在第二阶段，作者计算一组基本可视化的可区分性值，并将它们与有效性的经验测量值进行比较。在这两种情况下，分析表明计算测度能够近似经验结果。本文方法可用于对竞争性编码的可辨别性进行排序，并帮助为特定类型的数据分布选择可视化</p><div class="note default modern"><p><strong>[I] Winglets: Visualizing Association with Uncertainty in Multi-class Scatterplots <a href="https://deardeer.github.io/pub/InfoVis19_Winglet.pdf">[PDF]</a></strong></p></div><p>这项工作提出了Winglets，一种对经典散点图的增强，通过提高对相关聚类的关联和不确定性感知来更好地感知多个类的发音。Winglets被设计成一对属于数据点的双侧笔触，利用完形闭合原理来塑造簇的形状，而不是使用明确的分裂编码。通过对长度和方向这两个主要属性的巧妙设计，Winglets使观众能够完成集群的心理完成。在受控用户研究中，研究了Winglets感知簇关联和某些点的不确定性的效率。结果表明，Winglets形成了更显著的聚类关联点，提高了关联不确定性的感知</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：动画与过渡</title>
      <link href="2020/10/29/fullStack4/"/>
      <url>2020/10/29/fullStack4/</url>
      
        <content type="html"><![CDATA[<p>动画和过渡是D3中非常重要的一块内容</p><h2 id="为柱状图添加动画"><a href="#为柱状图添加动画" class="headerlink" title="为柱状图添加动画"></a>为柱状图添加动画</h2><p>首先我们学习一下如何对<a href="/2020/10/29/fullStack3/">之前的柱状图</a>增添动画</p><p>之前我们完成柱状图之后，可以通过调用函数生成多个不同的柱状图，现在我们希望用一个按钮来完成柱状图之间的切换，因为每个柱状图中柱子的数量是不同的，因此这就涉及到了d3中各种状态的处理，当exit态中一个柱子退出图像或者enter态中一个柱子加入图像的过程，我们肯定不希望是直接消失或者直接出现的，这样会非常丑，于是，就需要过渡和动画</p><p>首先设置动画过渡的时长</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exitTransition = d3.transition().duration(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">const</span> updateTransition = d3.transition().duration(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>插入动画呢，只要在希望过渡的属性之前加入.transition(updateTransition)即可</p><p>我们得设置进入状态，更新状态，以及退出状态的不同属性值，然后在remove之前和append之后插入过渡动画，使得图表转化平滑</p><p>先来设置进入状态的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newBinGroups = binGroups.enter().append(<span class="string">&#x27;g&#x27;</span>).attr(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;bin&#x27;</span>)</span><br><span class="line"><span class="comment">// 矩形块</span></span><br><span class="line">newBinGroups.append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(d.x0) + barPadding)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.boundedHeight)</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d3.max([<span class="number">0</span>, xScale(d.x1) - xScale(d.x0) - barPadding]))</span><br><span class="line">    .style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;yellowgreen&quot;</span>)</span><br><span class="line"><span class="comment">// 字符</span></span><br><span class="line">newBinGroups.append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(d.x0) + (xScale(d.x1) - xScale(d.x0)) / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.boundedHeight)</span><br></pre></td></tr></table></figure><p>我们将颜色设置成黄绿色并将高度设置成0，这样数据新增的时候就有柱子往上长，颜色会变化的过程，同时还需要设置text一开始也处于底部</p><p>然后是状态更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">binGroups = newBinGroups.merge(binGroups)        </span><br><span class="line"><span class="keyword">const</span> barRects = binGroups.select(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">    .transition(updateTransition) <span class="comment">// 高度过渡</span></span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(d.x0) + barPadding)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> dimensions.boundedHeight - yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d3.max([<span class="number">0</span>, xScale(d.x1) - xScale(d.x0) - barPadding]))</span><br><span class="line">    .transition(updateTransition) <span class="comment">// 颜色过渡</span></span><br><span class="line">    .style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;cornflowerblue&quot;</span>) </span><br></pre></td></tr></table></figure><p>先将新和数据绑定的元素和原来的集合合并，然后过渡到更新状态</p><p>注意这里用了两次.transition(updateTransition)，也就是说会有两次过渡动画，一次是新加入的元素高度从0开始到更新状态的高度，第二次则是高度完成后颜色发生变化，如果去掉第二次过渡，则颜色和高度会同时过渡</p><p>退出状态的设置则同理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldBinGroups = binGroups.exit()</span><br><span class="line"></span><br><span class="line">oldBinGroups.selectAll(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">    .transition(exitTransition) </span><br><span class="line">    .style(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;red&quot;</span>) </span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.boundedHeight)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">oldBinGroups.selectAll(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .transition(exitTransition)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.boundedHeight)</span><br><span class="line"></span><br><span class="line">oldBinGroups</span><br><span class="line">    .transition(exitTransition)</span><br><span class="line">    .remove()</span><br></pre></td></tr></table></figure><p>先将未绑定数据的元素选中，设置最终状态(柱子和文本都要处理)，在过渡完之后，将这些元素remove</p><p>而中位线和坐标轴只有一个，没有进入的退出的问题，直接加入动画过渡即可</p><p>那么现在让我们最后来画一个按钮，来实现图表内容的切换</p><p>这里介绍一下css中按钮的三个方法：hover，focus以及active</p><p>hover是鼠标覆盖到按钮上触发，active是鼠标在按钮上处于点击状态时触发，而focus则是鼠标选中文本框时触发，这里我们用hover和active让按钮看起来更棒</p><p>先来画一个按钮</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">appearance</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: darkseagreen;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span> seagreen;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.1s</span> ease-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transition是过渡，ease-out是一个非线性过渡方式(减速型)，设置了6px的圆角以及下边5px的阴影</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack4-1.png"></p><p>然后我们设置一下hover和active</p><p>鼠标覆盖的时候颜色变深并且主体下移，同时阴影少1px使得看起来更合理，鼠标点击的时候下移4px同时阴影减少4px，过程中阴影减少始终等于下移距离</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#73b173</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">0</span> <span class="number">0</span> seagreen;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">1px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span> seagreen;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">4px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在js文件中加上相应的点击事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = d3.select(<span class="string">&#x27;body&#x27;</span>).append(<span class="string">&#x27;button&#x27;</span>).text(<span class="string">&#x27;Change metric&#x27;</span>)</span><br><span class="line">button.node().addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    selectedMetricIndex = (selectedMetricIndex + <span class="number">1</span>) % (metrics.length - <span class="number">1</span>)</span><br><span class="line">    drawHistogram(metrics[selectedMetricIndex])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://forever97.github.io/dataViz/fullStackD3/updatingBars/">[演示地址]</a></p><h2 id="为折线图添加动画"><a href="#为折线图添加动画" class="headerlink" title="为折线图添加动画"></a>为折线图添加动画</h2><p>然后我们尝试在之前的折线图中加入过渡动画</p><p>希望实现的效果是不断生成新的数据加到当前数据的末尾，产生随着时间后移的效果</p><p>我们先从数据集中取一百天来画图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset = dataset.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> xAccessor(a) - xAccessor(b)).slice(<span class="number">0</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>这里dataset重新赋值了，所以我们不能再用之前的const了，而是要用let来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataset = <span class="keyword">await</span> d3.json(pathToJSON)</span><br></pre></td></tr></table></figure><p>我们先在画线的程序外边写一个新数据的生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateNewDataPoint</span>(<span class="params">dataset</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> lastDataPoint = dataset[dataset.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> nextDay = d3.timeDay.offset(xAccessor(lastDataPoint), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        date: d3.timeFormat(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)(nextDay),</span><br><span class="line">        <span class="comment">// random() : 0.0 ~ 1.0 之间的一个伪随机数</span></span><br><span class="line">        temperatureMax: yAccessor(lastDataPoint) + (<span class="built_in">Math</span>.random() * <span class="number">6</span> - <span class="number">3</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNewDay</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    dataset = [</span><br><span class="line">        ...dataset.slice(<span class="number">1</span>), </span><br><span class="line">        generateNewDataPoint(dataset),</span><br><span class="line">    ]</span><br><span class="line">    drawLine(dataset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下代码，.slice(st,en)方法可以从数据集中抽取区段[st,en]，可以省略第二个参数，表示从给定开头抽取到结尾，…是ES6的特性，表示将数据集展开，通俗的说就是把dataset的括号拿走</p><p>设置一下每次数据更新的时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(addNewDay, <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>然后我们来实现动画过渡</p><p>坐标轴和之前的柱状图实现一致</p><p>线的部分我们先尝试一下和柱状图一样的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds</span><br><span class="line">    .select(<span class="string">&#x27;.line&#x27;</span>)</span><br><span class="line">    .transition()</span><br><span class="line">    .duration(<span class="number">1000</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;d&#x27;</span>, lineGenerator(dataset))</span><br></pre></td></tr></table></figure><p>结果非常的蛋疼，原先的线扭啊扭地扭成了下一条线，这是因为attr函数并不知道我们把点平移到了下一个索引，而是将每个点过渡到了第二天的y值(毕竟这个看起来才是合理的动画)</p><p>于是我们得告诉动画，我们这是发生了平移</p><p>我们计算平移量，然后对线的位置平移样式添加动画</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds</span><br><span class="line">    .select(<span class="string">&#x27;.line&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;d&#x27;</span>, lineGenerator(dataset))</span><br><span class="line">    .style(<span class="string">&#x27;transform&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    .transition()</span><br><span class="line">    .duration(<span class="number">1000</span>)</span><br><span class="line">    .style(<span class="string">&#x27;transform&#x27;</span>, <span class="string">`translateX(<span class="subst">$&#123;-pixelsBetweenLastPoints&#125;</span>px)`</span>)</span><br></pre></td></tr></table></figure><p>这样就变成了向左平移两位</p><p>然后发现值跟线对不上了…… (偏了两位)</p><p>这个故事告诉我们，过渡的最终状态，一定要是位置正确的状态，咱换换状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds</span><br><span class="line">    .select(<span class="string">&#x27;.line&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;d&#x27;</span>, lineGenerator(dataset))</span><br><span class="line">    .style(<span class="string">&#x27;transform&#x27;</span>, <span class="string">`translateX(<span class="subst">$&#123;pixelsBetweenLastPoints&#125;</span>px)`</span>)</span><br><span class="line">    .transition()</span><br><span class="line">    .duration(<span class="number">1000</span>)</span><br><span class="line">    .style(<span class="string">&#x27;transform&#x27;</span>, <span class="string">&#x27;none&#x27;</span>)</span><br></pre></td></tr></table></figure><p>现在就对了，但是还有点小问题，左边的点是直接消失的，右边的点超出了图表</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack4-2.png"></p><p>defs元素用于存储后面在SVG中使用的任何可重用定义。我们可以在defs元素中放置任何clipPath，在clipPath的作用是隐藏越界数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bounds</span><br><span class="line">    .append(<span class="string">&#x27;defs&#x27;</span>)</span><br><span class="line">    .append(<span class="string">&#x27;clipPath&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;bounds-clip-path&#x27;</span>)</span><br><span class="line">    .append(<span class="string">&#x27;rect&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, dimensions.boundedWidth)</span><br><span class="line">    .attr(<span class="string">&#x27;height&#x27;</span>, dimensions.boundedHeight)</span><br></pre></td></tr></table></figure><p>修改完我们的bounds之后，越界的线条就消失了</p><p>接下来处理前面少掉的一个点，这是书中作者布置的任务，我的实现方法是，直接把映射切掉第一个点，让它显示在clipPath之外，这就不会有突兀的消失了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xScale = d3</span><br><span class="line">    .scaleTime()</span><br><span class="line">    .domain(d3.extent(dataset.slice(<span class="number">1</span>), xAccessor))</span><br><span class="line">    .range([<span class="number">0</span>, dimensions.boundedWidth])</span><br></pre></td></tr></table></figure><p><a href="https://forever97.github.io/dataViz/fullStackD3/updatingLine/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：柱状图</title>
      <link href="2020/10/29/fullStack3/"/>
      <url>2020/10/29/fullStack3/</url>
      
        <content type="html"><![CDATA[<p>还是熟悉的数据，这回来做一个柱状图</p><p><a href="https://github.com/forever97/dataViz/blob/main/fullStackD3/lineChart/data/nyc_weather_data.json">[数据下载地址]</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>还是熟悉的数据载入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathToJSON = <span class="string">&quot;./data/nyc_weather_data.json&quot;</span></span><br><span class="line"><span class="keyword">const</span> dataset = <span class="keyword">await</span> d3.json(pathToJSON)</span><br></pre></td></tr></table></figure><p>接着设置参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="number">600</span></span><br><span class="line"><span class="keyword">let</span> dimensions = &#123;</span><br><span class="line">    width: width,</span><br><span class="line">    height: width * <span class="number">0.9</span>,</span><br><span class="line">    margin: &#123;</span><br><span class="line">        top: <span class="number">30</span>,</span><br><span class="line">        right: <span class="number">10</span>,</span><br><span class="line">        bottom: <span class="number">50</span>,</span><br><span class="line">        left: <span class="number">50</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">dimensions.boundedWidth = dimensions.width </span><br><span class="line">    - dimensions.margin.left </span><br><span class="line">    - dimensions.margin.right</span><br><span class="line">dimensions.boundedHeight = dimensions.height </span><br><span class="line">    - dimensions.margin.top </span><br><span class="line">    - dimensions.margin.bottom</span><br></pre></td></tr></table></figure><p>处理画布和bound</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = d3</span><br><span class="line">    .select(<span class="string">&#x27;#wrapper&#x27;</span>)</span><br><span class="line">    .append(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;width&#x27;</span>, dimensions.width)</span><br><span class="line">    .attr(<span class="string">&#x27;height&#x27;</span>, dimensions.height)</span><br><span class="line"><span class="keyword">const</span> bounds = wrapper</span><br><span class="line">    .append(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    .style(</span><br><span class="line">        <span class="string">&#x27;transform&#x27;</span>,</span><br><span class="line">        <span class="string">`translate(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            dimensions.margin.left</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>px, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            dimensions.margin.top</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>)`</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>准备先用柱状图对湿度humidity进行一个统计</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> metricAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.humidity</span><br></pre></td></tr></table></figure><p>然后根据湿度的范围创建一个比例尺</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xScale = d3</span><br><span class="line">    .scaleLinear()</span><br><span class="line">    .domain(d3.extent(dataset, metricAccessor))</span><br><span class="line">    .range([<span class="number">0</span>, dimensions.boundedWidth])</span><br><span class="line">    .nice()</span><br></pre></td></tr></table></figure><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>然后我们需要对数据进行分组，决定他们都是属于哪个bin的</p><p>这里采用histogram方法，首先需要通过domain传入域，然后通过value告诉生成器获取值的方法，因为dataset是对象集，我们要获得对应的湿度值，thresholds可以告诉生成器我们希望它生成几个bin，当然不一定完全听你的，但是生成器会尽可能接近设定的组数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binsGenerator = d3.histogram()</span><br><span class="line">    .domain(xScale.domain())</span><br><span class="line">    .value(metricAccessor)</span><br><span class="line">    .thresholds(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>分组并查看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bins = binsGenerator(dataset)</span><br><span class="line"><span class="built_in">console</span>.log(bins)</span><br></pre></td></tr></table></figure><p>可以看到一共分出了15组</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-1.png"></p><p>然后我们就可以根据我们的bin来创建y比例尺了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.length</span><br><span class="line"><span class="keyword">const</span> yScale = d3.scaleLinear()</span><br><span class="line">    .domain([<span class="number">0</span>, d3.max(bins, yAccessor)])</span><br><span class="line">    .range([dimensions.boundedHeight, <span class="number">0</span>])</span><br><span class="line">    .nice()</span><br></pre></td></tr></table></figure><p>分组之后的x0和x1表示组内湿度的下限和上限，length表示组内的元素数量</p><h2 id="绘制数据"><a href="#绘制数据" class="headerlink" title="绘制数据"></a>绘制数据</h2><p>首先生成一个组来画柱子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binsGroup = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> binGroups = binsGroup.selectAll(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .data(bins)</span><br><span class="line">    .enter().append(<span class="string">&quot;g&quot;</span>)</span><br></pre></td></tr></table></figure><p>绘制柱子，注意提到过的svg的y轴是从上到下的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> barPadding = <span class="number">1</span> <span class="comment">// 柱子间距</span></span><br><span class="line"><span class="keyword">const</span> barRects = binGroups.append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(d.x0) + barPadding / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> d3.max([<span class="number">0</span>, xScale(d.x1) - xScale(d.x0) - barPadding]))</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> dimensions.boundedHeight - yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;cornflowerblue&quot;</span>)</span><br></pre></td></tr></table></figure><p>成功绘制了柱子</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-2.png"></p><p>然后我们在柱子上方写上对应的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> barText = binGroups.filter(yAccessor)</span><br><span class="line">    .append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(d.x0) + (xScale(d.x1) - xScale(d.x0)) / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)) - <span class="number">5</span>)</span><br><span class="line">    .text(yAccessor)</span><br><span class="line">    .style(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;middle&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;darkgrey&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;font-size&quot;</span>, <span class="string">&quot;12px&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;font-family&quot;</span>, <span class="string">&quot;sans-serif&quot;</span>)</span><br></pre></td></tr></table></figure><p>.filter()的参数为一个接受一个数据点并返回一个值的函数，数据集中任何返回错误值的项都将被删除</p><p>效果如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-3.png"></p><p>接着我们可以在图像上标注一根代表平均值的线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mean = d3.mean(dataset, metricAccessor)</span><br><span class="line"><span class="keyword">const</span> meanLine = bounds.append(<span class="string">&quot;line&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x1&quot;</span>, xScale(mean))</span><br><span class="line">    .attr(<span class="string">&quot;x2&quot;</span>, xScale(mean))</span><br><span class="line">    .attr(<span class="string">&quot;y1&quot;</span>, -<span class="number">15</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y2&quot;</span>, dimensions.boundedHeight)</span><br><span class="line">    .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;maroon&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;stroke-dasharray&quot;</span>, <span class="string">&quot;2px 4px&quot;</span>) <span class="comment">// 虚线，参数为实虚比例</span></span><br></pre></td></tr></table></figure><p>再加个字儿</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> meanLabel = bounds</span><br><span class="line">    .append(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;x&#x27;</span>, xScale(mean))</span><br><span class="line">    .attr(<span class="string">&#x27;y&#x27;</span>, <span class="number">15</span>)</span><br><span class="line">    .text(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">    .attr(<span class="string">&#x27;fill&#x27;</span>, <span class="string">&#x27;maroon&#x27;</span>)</span><br><span class="line">    .style(<span class="string">&#x27;font-size&#x27;</span>, <span class="string">&#x27;12px&#x27;</span>)</span><br><span class="line">    .style(<span class="string">&#x27;text-anchor&#x27;</span>, <span class="string">&#x27;middle&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-4.png"></p><p>补一手x轴和标注</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxisGenerator = d3.axisBottom()</span><br><span class="line">    .scale(xScale)</span><br><span class="line"><span class="keyword">const</span> xAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .call(xAxisGenerator)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translateY(<span class="subst">$&#123;dimensions.boundedHeight&#125;</span>px)`</span>)</span><br><span class="line"><span class="keyword">const</span> xAxisLabel = xAxis.append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, dimensions.boundedWidth / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.margin.bottom - <span class="number">10</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;black&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;font-size&quot;</span>, <span class="string">&quot;1.4em&quot;</span>)</span><br><span class="line">    .text(metricAccessor)</span><br><span class="line">    <span class="comment">// 大小写转换</span></span><br><span class="line">    .style(<span class="string">&quot;text-transform&quot;</span>, <span class="string">&quot;capitalize&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-5.png"></p><h2 id="代码模板化"><a href="#代码模板化" class="headerlink" title="代码模板化"></a>代码模板化</h2><p>说到代码模板化，其实我们前边一直在做这件事情，用metricAccessor来表示我们要计算的湿度，我们只要将其它的属性作为metricAccessor传递进去就能创建对应的图表了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> drawHistogram = <span class="function"><span class="params">metric</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> metricAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d[metric]</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用一个循环对于每种属性去调用这个函数，就能够画出对应属性的图表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> metrics = [</span><br><span class="line">    <span class="string">&quot;windSpeed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;moonPhase&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dewPoint&quot;</span>,</span><br><span class="line">    <span class="string">&quot;humidity&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uvIndex&quot;</span>,</span><br><span class="line">    <span class="string">&quot;windBearing&quot;</span>,</span><br><span class="line">    <span class="string">&quot;temperatureMin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;temperatureMax&quot;</span>,</span><br><span class="line">]</span><br><span class="line">metrics.forEach(drawHistogram)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack3-6.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/barChart/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：散点图</title>
      <link href="2020/10/28/fullStack2/"/>
      <url>2020/10/28/fullStack2/</url>
      
        <content type="html"><![CDATA[<p>这次来画一个散点图，用的还是上次画折线图的数据</p><p><a href="https://github.com/forever97/dataViz/blob/main/fullStackD3/lineChart/data/nyc_weather_data.json">[数据下载地址]</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>读入数据的方式和之前是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataset = <span class="keyword">await</span> d3.json(<span class="string">&quot;./data/nyc_weather_data.json&quot;</span>)</span><br></pre></td></tr></table></figure><p>这次采用湿度和露点作为两个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.dewPoint</span><br><span class="line"><span class="keyword">const</span> yAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.humidity</span><br></pre></td></tr></table></figure><p>我们准备画一个正方形的散点图，所以我们现在计算它的边长</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = d3.min([</span><br><span class="line">    <span class="built_in">window</span>.innerWidth * <span class="number">0.9</span>, </span><br><span class="line">    <span class="built_in">window</span>.innerHeight * <span class="number">0.9</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>同样的，设置一个参数表，并计算bound的高和宽</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dimensions = &#123;</span><br><span class="line">    width: width,</span><br><span class="line">    height: width,</span><br><span class="line">    margin: &#123;</span><br><span class="line">        top: <span class="number">10</span>,</span><br><span class="line">        right: <span class="number">10</span>,</span><br><span class="line">        bottom: <span class="number">50</span>,</span><br><span class="line">        left: <span class="number">50</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">dimensions.boundedWidth = dimensions.width</span><br><span class="line">    - dimensions.margin.left</span><br><span class="line">    - dimensions.margin.right</span><br><span class="line">dimensions.boundedHeight = dimensions.height</span><br><span class="line">    - dimensions.margin.top</span><br><span class="line">    - dimensions.margin.bottom</span><br></pre></td></tr></table></figure><p>之后我们用这些参数来创建画布，然后创建bound并平移</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = d3.select(<span class="string">&quot;#wrapper&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, dimensions.width)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, dimensions.height)</span><br><span class="line"><span class="keyword">const</span> bounds = wrapper.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.margin.left</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>px, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.margin.top</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>px)`</span>)</span><br></pre></td></tr></table></figure><p>随后创建一个比例尺</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xScale = d3.scaleLinear()</span><br><span class="line">    .domain(d3.extent(dataset, xAccessor))  </span><br><span class="line">    .range([<span class="number">0</span>, dimensions.boundedWidth])</span><br><span class="line">    .nice()</span><br><span class="line"><span class="keyword">const</span> yScale = d3.scaleLinear()</span><br><span class="line">    .domain(d3.extent(dataset, yAccessor))  </span><br><span class="line">    .range([dimensions.boundedHeight, <span class="number">0</span>])</span><br><span class="line">    .nice()</span><br></pre></td></tr></table></figure><p>.nice()做的是一个舍入操作，能够让比例尺范围为最小刻度的整数倍</p><h2 id="绘制数据"><a href="#绘制数据" class="headerlink" title="绘制数据"></a>绘制数据</h2><p>既然是散点图，我们肯定希望对每个数据绘制一个点，这里我们用小半径的圆来表示点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataset.forEach(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">    bounds</span><br><span class="line">        .append(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">        .attr(<span class="string">&quot;cx&quot;</span>, xScale(xAccessor(d)))</span><br><span class="line">        .attr(<span class="string">&quot;cy&quot;</span>, yScale(yAccessor(d)))   </span><br><span class="line">        .attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果我们用js的方式来处理，直接用循环把每个点画上去就ok了，但是我们是准备用d3来做数据可视化的，那么就需要考虑到数据更新，需要将图像和数据绑定</p><p>d3中的数据状态如下图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack2-1.png"></p><ol><li>enter状态：表示没有绑定元素的数据</li><li>group状态：元素和数据一一对应</li><li>exit状态：没有绑定数据的元素</li></ol><p>我们用.dataset()来使得元素和数据关联，之后就可以对于不同状态的数据或元素做对应的处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dots = bounds.selectAll(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">    .data(dataset)</span><br><span class="line">    .enter().append(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;cx&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(xAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;cy&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;cornflowerblue&quot;</span>)</span><br></pre></td></tr></table></figure><p>对于enter状态的所有数据，绑定一个图像元素</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack2-2.png"></p><p>那如果我既要加入数据，又想要已有的数据一起更新呢，这里就可以用一个merge，将数据合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dots = bounds.selectAll(<span class="string">&quot;circle&quot;</span>).data(dataset)</span><br><span class="line">dots.enter().append(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">    .merge(dots)</span><br><span class="line">    .attr(<span class="string">&quot;cx&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(xAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;cy&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;grey&quot;</span>)</span><br></pre></td></tr></table></figure><p>数据合并还有一种更方便的方式，不需要去先找到enter态，然后append，最后merge，而是可以直接使用join</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dots.join(<span class="string">&quot;circle&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;cx&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> xScale(xAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;cy&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br><span class="line">    .attr(<span class="string">&quot;r&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;grey&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建坐标轴的方式和之前的类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxisGenerator = d3.axisBottom().scale(xScale)</span><br><span class="line"><span class="keyword">const</span> xAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .call(xAxisGenerator)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translateY(<span class="subst">$&#123;dimensions.boundedHeight&#125;</span>px)`</span>)</span><br><span class="line"><span class="keyword">const</span> yAxisGenerator = d3.axisLeft()</span><br><span class="line">    .scale(yScale)</span><br><span class="line">    .ticks(<span class="number">4</span>) <span class="comment">// 指定刻度数量</span></span><br><span class="line"><span class="keyword">const</span> yAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .call(yAxisGenerator)</span><br></pre></td></tr></table></figure><p>这回我们还希望把坐标轴对应的维度变量名也表示在图表上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxisLabel = xAxis.append(<span class="string">&quot;text&quot;</span>) </span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, dimensions.boundedWidth / <span class="number">2</span>) </span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, dimensions.margin.bottom - <span class="number">10</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="comment">// html中有些使用属性没效果，要用样式，svg都可</span></span><br><span class="line">    .style(<span class="string">&quot;font-size&quot;</span>, <span class="string">&quot;1.4em&quot;</span>) </span><br><span class="line">    .html(<span class="string">&quot;Dew point (&amp;deg;F)&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> yAxisLabel = yAxis.append(<span class="string">&quot;text&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, -dimensions.boundedHeight / <span class="number">2</span>)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, -dimensions.margin.left + <span class="number">10</span>)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;black&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;font-size&quot;</span>, <span class="string">&quot;1.4em&quot;</span>)</span><br><span class="line">    .text(<span class="string">&quot;Relative humidity&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">&quot;rotate(-90deg)&quot;</span>)</span><br><span class="line">    .style(<span class="string">&quot;text-anchor&quot;</span>, <span class="string">&quot;middle&quot;</span>)</span><br></pre></td></tr></table></figure><p>字体大小设置为标准的1.4倍，y轴旋转90度并居中</p><p>已经像模像样了起来</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack2-3.png"></p><h2 id="引入颜色维度"><a href="#引入颜色维度" class="headerlink" title="引入颜色维度"></a>引入颜色维度</h2><p>散点图除了横纵坐标之外，点的颜色也可以表示一个维度的数据，这里我们用颜色来表示cloudCover这个属性</p><p>创建一个颜色比例尺</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.cloudCover</span><br><span class="line"><span class="keyword">const</span> colorScale = d3.scaleLinear()</span><br><span class="line">    .domain(d3.extent(dataset, colorAccessor))</span><br><span class="line">    .range([<span class="string">&quot;skyblue&quot;</span>, <span class="string">&quot;darkslategrey&quot;</span>])</span><br></pre></td></tr></table></figure><p>然后修改一下绘制散点的fill属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.attr(<span class="string">&quot;fill&quot;</span>, <span class="function"><span class="params">d</span> =&gt;</span> colorScale(colorAccessor(d))) </span><br></pre></td></tr></table></figure><p>一张三维的图表就创建完毕了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack2-4.png"></p><p>最后玩点花的，把坐标轴的.domain移除，把.tickSize设置成跟长宽相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxisGenerator = d3.axisBottom()</span><br><span class="line">    .scale(xScale)</span><br><span class="line">    .ticks(<span class="number">25</span>)</span><br><span class="line">    .tickSize(-dimensions.height)</span><br><span class="line">xAxis.selectAll(<span class="string">&#x27;.domain&#x27;</span>) </span><br><span class="line">        .remove()</span><br></pre></td></tr></table></figure><p>y轴同理</p><p>在css里把tick的颜色设淡一点，改一下圆的半径和透明度，完工</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack2-5.png"></p><p><a href="https://forever97.github.io/dataViz/fullStackD3/scatterplot/">[演示地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：年月日与星期的计算</title>
      <link href="2020/10/28/Re0-3/"/>
      <url>2020/10/28/Re0-3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次要讲解的题从本质上说就是一个简单的模拟题，模拟题在竞赛中是一类简单而复杂的问题，简单是因为不需要太过高深的算法就能够解决，而复杂指的是，你需要准确地掌握题目中的每一个条件，用最简单明快的方式去实现</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Friday the Thirteenth]</p><p>已知1900年1月1日是星期一，4,6,11和9月有30天，其他月份除了2月都有31天。年份可以被400整除的世纪年或者被4整除的非世纪年是闰年，世纪年指的是年份为100整数的年</p><p>写一个程序来计算从1900年起，在n年里13日落在星期六，星期日，星期一,……星期五的次数</p><h2 id="分析与代码"><a href="#分析与代码" class="headerlink" title="分析与代码"></a>分析与代码</h2><p>首先用一个常量来记录1900这个年份数字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1900</span>;</span><br></pre></td></tr></table></figure><p>每年各个月份的天数其实也是一个常量，我们用一个数组来将其记录下来，方便查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>这里我只记录了非闰年的情况，为了清晰起见，闰年也可以通过这种方式记录</p><p>之后的基本思路就是每个月的天数不断累加，判断那个月的13号是星期几即可</p><p>因为题目中要求的是依次输出周六到周五，所以我们用数组下标为0的位置存周六的次数，下标为1的位置存周日的次数，以此类推</p><p>1900年的1月1日是周一，也就是<strong>前一天是周日</strong>，所以我们建立我们的天数累加变量day值为1，来表示要计算的第一天的前一天</p><p>闰年的判断直接按照题目描述的进行计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isLeap = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((base + i) % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((base + i) % <span class="number">400</span> == <span class="number">0</span>) isLeap = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((base + i) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    isLeap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后逐年逐月计算日期对应星期几即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++) &#123;</span><br><span class="line">    count[(day + <span class="number">13</span>) % <span class="number">7</span>]++;</span><br><span class="line">    day += months[j];</span><br><span class="line">    <span class="keyword">if</span> (j==<span class="number">1</span> &amp;&amp; isLeap) day++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，直接模拟，这题就可以处理完毕了</p><p>除此之外，希望大家通过这题顺便学习一下蔡勒公式，其作用是根据给定的年月日直接通过式子算出是星期几，当然这个公式有一定的限制(自行搜索了解)，对于这题来说是没有问题的</p><p>那么如果有了蔡勒公式，这个题的结构就可以变得更简单，直接枚举年月日，计算对应星期几记录即可</p><h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 1900年</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1900</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">7</span>, <span class="number">0</span>)</span></span>; <span class="comment">// [星期六 - 星期五]</span></span><br><span class="line">    <span class="keyword">int</span> months[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;; <span class="comment">// 非闰年</span></span><br><span class="line">    <span class="keyword">int</span> day = <span class="number">1</span>; <span class="comment">// 公元元年1月1日前一天是星期日</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 对每年是否为闰年进行计算</span></span><br><span class="line">        <span class="keyword">bool</span> isLeap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((base + i) % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((base + i) % <span class="number">400</span> == <span class="number">0</span>) isLeap = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((base + i) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            isLeap = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算每个月的13号对应星期几</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; j++) &#123;</span><br><span class="line">            count[(day + <span class="number">13</span>) % <span class="number">7</span>]++;</span><br><span class="line">            day += months[j];</span><br><span class="line">            <span class="keyword">if</span> (j==<span class="number">1</span> &amp;&amp; isLeap) day++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, count[i], <span class="string">&quot; \n&quot;</span>[i == <span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note success modern"><p>Accept</p></div><p>蔡勒公式的代码非常简单，请大家自行学习实现</p><h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><ul><li>用简单清楚的方式实现这道题</li><li>学习蔡勒公式，完成此题，将蔡勒公式整理进自己的模板</li></ul>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>D3学习记录：折线图</title>
      <link href="2020/10/28/fullStack1/"/>
      <url>2020/10/28/fullStack1/</url>
      
        <content type="html"><![CDATA[<p>最近准备刷一遍 Fullstack D3 and Data Visualization，系统地学一下d3，顺便记录一下学习过程</p><p>首先是实现一个小目标：画一个纽约天气折线图</p><h2 id="数据载入与查看"><a href="#数据载入与查看" class="headerlink" title="数据载入与查看"></a>数据载入与查看</h2><p>第一步，载入数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">drawLineChart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dataset = <span class="keyword">await</span> d3.json(<span class="string">&quot;./data/nyc_weather_data.json&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(dataset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下所有的代码都是默认在drawLineChart异步函数中书写</p><p>然后可以控制台输出来看看</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-1.png"></p><p>365天的天气，每天还有一堆属性，这种情况下有个更方便的查看数据的方式，console.table，我们来查看第一天的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.table(dataset[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-2.png"></p><p>nice</p><h2 id="初始参数设置"><a href="#初始参数设置" class="headerlink" title="初始参数设置"></a>初始参数设置</h2><p>用xAccessor和yAccessor来绘制x轴和y轴上的点</p><p>y轴用每天的最高气温作为标度，而x轴则采用时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yAccessor = <span class="function"><span class="params">d</span> =&gt;</span> d.temperatureMax</span><br></pre></td></tr></table></figure><p>我们看到x轴的数据类型是这样的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-3.png"></p><p>显然是一个字符串，我们希望把它转成一个js中的date类型，用d3.timeParse()可以完成这个要求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateParser = d3.timeParse(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> xAccessor = <span class="function"><span class="params">d</span> =&gt;</span> dateParser(d.date)</span><br></pre></td></tr></table></figure><p>然后来设置一些参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dimensions = &#123;</span><br><span class="line">    width: <span class="built_in">window</span>.innerWidth * <span class="number">0.9</span>,</span><br><span class="line">    height: <span class="number">400</span>,</span><br><span class="line">    margin: &#123;</span><br><span class="line">        top: <span class="number">15</span>,</span><br><span class="line">        right: <span class="number">15</span>,</span><br><span class="line">        bottom: <span class="number">40</span>,</span><br><span class="line">        left: <span class="number">60</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数中包括了包装器的大小和页边距</p><p>之后这些参数就可以用来计算边界</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> dimensions.boundedWidth = dimensions.width </span><br><span class="line">    - dimensions.margin.left </span><br><span class="line">    - dimensions.margin.right;</span><br><span class="line">dimensions.boundedHeight = dimensions.height </span><br><span class="line">    - dimensions.margin.top </span><br><span class="line">    - dimensions.margin.bottom;  </span><br></pre></td></tr></table></figure><p>创建一个svg元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = d3.select(<span class="string">&quot;#wrapper&quot;</span>)</span><br><span class="line">    .append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, dimensions.width)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, dimensions.height)</span><br></pre></td></tr></table></figure><p>然后在svg中创建一个组，这么做的好处是，我们可以在组里面画东西，然后在svg里面去统一移动画的东西</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bounds = wrapper.append(<span class="string">&quot;g&quot;</span>)  </span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translate(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.margin.left</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>px, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.margin.top</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>px)`</span>)</span><br></pre></td></tr></table></figure><h2 id="创建比例尺"><a href="#创建比例尺" class="headerlink" title="创建比例尺"></a>创建比例尺</h2><p>画坐标轴之前，我们需要创建一个比例尺，把数值映射到图像中的像素</p><p>我们用d3.extent来获取数据中的最小值和最大值作为domain</p><p>映射到组内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yScale = d3.scaleLinear()</span><br><span class="line">    .domain(d3.extent(dataset, yAccessor)) </span><br><span class="line">    .range([dimensions.boundedHeight, <span class="number">0</span>])</span><br><span class="line"><span class="keyword">const</span> xScale = d3.scaleTime()</span><br><span class="line">    .domain(d3.extent(dataset, xAccessor))  </span><br><span class="line">    .range([<span class="number">0</span>, dimensions.boundedWidth])</span><br></pre></td></tr></table></figure><p>svg里面的y是从上到下计数的，所以我们想建一个原点在下面的坐标轴需要倒一下比例尺的range，我们可以输出yScale(32)来检查比例尺创建是否正确</p><p>我们来创建一个矩形框住低温区域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> freezingTemperaturePlacement = yScale(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">const</span> freezingTemperatures = bounds.append(<span class="string">&quot;rect&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;x&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    .attr(<span class="string">&quot;width&quot;</span>, dimensions.boundedWidth)</span><br><span class="line">    .attr(<span class="string">&quot;y&quot;</span>, freezingTemperaturePlacement)</span><br><span class="line">    .attr(<span class="string">&quot;height&quot;</span>, dimensions.boundedHeight - freezingTemperaturePlacement)</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;#e0f3f3&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="绘制折线"><a href="#绘制折线" class="headerlink" title="绘制折线"></a>绘制折线</h2><p>首先需要一个线生成器，能够将数据转化成线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lineGenerator = d3.line() </span><br><span class="line">    .x(<span class="function"><span class="params">d</span> =&gt;</span> xScale(xAccessor(d)))</span><br><span class="line">    .y(<span class="function"><span class="params">d</span> =&gt;</span> yScale(yAccessor(d)))</span><br></pre></td></tr></table></figure><p>然后就可以把线画出来了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;d&quot;</span>, lineGenerator(dataset))</span><br></pre></td></tr></table></figure><p>但是画出来是这样的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-4.png"></p><p>这是因为svg元素默认黑色填充以及无笔触(stroke)</p><p>我们对填充和笔触进行设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> line = bounds.append(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;d&quot;</span>, lineGenerator(dataset))</span><br><span class="line">    .attr(<span class="string">&quot;fill&quot;</span>, <span class="string">&quot;none&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;stroke&quot;</span>, <span class="string">&quot;#af9358&quot;</span>)</span><br><span class="line">    .attr(<span class="string">&quot;stroke-width&quot;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>折线图就画出来了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-5.png"></p><h2 id="绘制坐标轴"><a href="#绘制坐标轴" class="headerlink" title="绘制坐标轴"></a>绘制坐标轴</h2><p>最后来画一个坐标轴，同理，先定义一个坐标轴生成器，然后告诉它在哪里生成坐标轴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yAxisGenerator = d3.axisLeft()  </span><br><span class="line">    .scale(yScale)</span><br><span class="line"><span class="keyword">const</span> yAxis = bounds.call(yAxisGenerator)</span><br></pre></td></tr></table></figure><p>call将以selection作为第一个参数执行所提供的函数</p><p>也就是上述代码等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yAxisGenerator = d3.axisLeft()  </span><br><span class="line">    .scale(yScale)</span><br><span class="line"><span class="keyword">const</span> yAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">yAxisGenerator(yAxis)</span><br></pre></td></tr></table></figure><p>同理画一下x轴</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxisGenerator = d3.axisBottom()  </span><br><span class="line">    .scale(xScale)</span><br><span class="line"><span class="keyword">const</span> xAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .call(xAxisGenerator)</span><br></pre></td></tr></table></figure><p>然后发现这个y轴倒是没什么问题，但是x轴莫名其妙跑到上面去了</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/fullStack1-6.png"></p><p>因为d3的坐标轴生成器只知道相对于轴，刻度线在哪个方向，轴的位置是没有设置的，所以要平移一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xAxis = bounds.append(<span class="string">&quot;g&quot;</span>)</span><br><span class="line">    .call(xAxisGenerator)</span><br><span class="line">    .style(<span class="string">&quot;transform&quot;</span>, <span class="string">`translateY(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        dimensions.boundedHeight</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>px)`</span>)</span><br></pre></td></tr></table></figure><p>ok，完工</p><p>最后顺便加了条最低温度的线，调整了一下坐标轴的范围和线的颜色</p><p><a href="https://forever97.github.io/dataViz/fullStackD3/lineChart/">[演示地址]</a></p><p><a href="https://github.com/forever97/dataViz/blob/main/fullStackD3/lineChart/data/nyc_weather_data.json">[数据下载地址]</a></p>]]></content>
      
      
      <categories>
          
          <category> 🍵D3茶楼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：标准模板库</title>
      <link href="2020/10/21/Re0-2/"/>
      <url>2020/10/21/Re0-2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>标准模板库，简称STL，包含有大量的模板类和模板函数，是C升级到C++的++里面包括的部分，非常方便实用，是竞赛中的必备技能之一，当然STL和C++语法一样，想介绍详细，也会变成厚厚的一本书(《 STL源码剖析 》)，所以这和语法的学习方法是一样的，不断学习需要用到的即可，从doc中学习最标准的书写方式，从别人的代码中学习<del>一些奇技淫巧</del>高效的使用方法</p><p><a href="http://www.cplusplus.com/reference/">C++ Reference</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Greedy Gift Givers]</p><p>给定互送礼物的列表，确定每个人收到的礼物价值比送出的多多少</p><p>每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人</p><figure class="highlight plain"><figcaption><span>INPUT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">dave</span><br><span class="line">laura</span><br><span class="line">owen</span><br><span class="line">vick</span><br><span class="line">amr</span><br><span class="line">dave</span><br><span class="line">200 3</span><br><span class="line">laura</span><br><span class="line">owen</span><br><span class="line">vick</span><br><span class="line">owen</span><br><span class="line">500 1</span><br><span class="line">dave</span><br><span class="line">amr</span><br><span class="line">150 2</span><br><span class="line">vick</span><br><span class="line">owen</span><br><span class="line">laura</span><br><span class="line">0 2</span><br><span class="line">amr</span><br><span class="line">vick</span><br><span class="line">vick</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>OUTPUT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dave 302</span><br><span class="line">laura 66</span><br><span class="line">owen -359</span><br><span class="line">vick 141</span><br><span class="line">amr -150</span><br></pre></td></tr></table></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>当你第一次拿到这种题的时候，可能会觉得人名的处理非常的棘手</p><p>那么我们先来做一个题目简化，将这些人名全部替换成数字，那么这个问题就变成一个较为简单的模拟题了：读入每个代表人的数字(1到n)，然后读入他准备用于买礼物的钱，准备送的朋友，计算每个朋友收到的礼物价值和这个人的花费，将花费计算并保存在每个人对应的值上(可以用一个数组来存储)，送出去的钱(朋友收到的总和)计负，收到的钱计正相加处理，实现起来应该并不困难</p><p>现在每个人的标识从数字变为了字符串，我们需要额外处理的问题是，如何去定位这个人，原来的数字可以作为数组的下标，但是现在字符串不可以，这就是最大的问题，一个朴素的处理方式是，我们先用一个字符串数组保存下人名，即name[0]到name[n-1]保存了所有人的名字，然后用一个money数组来保存值的计算过程，每次处理到人名，我们就在name这个表中去查找，找到之后将其在<strong>name中的下标id</strong>作为人的标识符，将对应的值计算记录在money[id]上</p><p>在name表中查找的过程可以直接用for循环去找，这么处理的时间复杂度是$O(n^2)$的 (时间复杂度是什么，如何计算时间复杂度：搜索相关知识或阅读《算法导论》相关章节)，用哈希表来处理这个过程则可以对复杂度进一步优化时间度到$O(n)$ (学有余力的同学可以自行学习哈希表如何处理此类问题)</p><p>接下来我将介绍如何使用STL中的模板函数来解决这个问题</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>首先，出于后续处理的考虑，字符串用string类来读入，而不是之前学到过的char数组，string是无法采用c式读入的，所以我们要用cin来处理读入</p><p>这里需要说明一下C++输入输出流在竞赛中通常是如何处理的，在C++中，cin和cout默认和stdio同步，即可以和C式读入混用而不会导致指针混乱，但是同步是有代价的，函数需要用到各自的缓冲区，所以速度就会变慢，那么如果想要cin的速度和scanf一样快，则需要取消缓冲区同步，可以简单地通过一行代码做到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>此外在默认情况下，cin会绑定cout，用于保证输入缓冲区在调用输入之前被刷新，为了进一步加速，我们可以将两者的绑定也取消</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>); <span class="comment">// cout.tie(NULL);</span></span><br></pre></td></tr></table></figure><h3 id="STL-vector"><a href="#STL-vector" class="headerlink" title="STL-vector"></a>STL-vector</h3><p>向量vector是STL中的一种容器，可以实现动态增长，也就是说，你在定义的时候不需要限定长度，当你往里放入元素的时候容量会自动变大</p><p>举个例子，我们定义一个int类型的向量，我们不需要定义其大小，直接里放入元素即可，已经被元素占据的位置可以直接通过下标访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么如果我希望直接在下标为5的位置直接放入这个3呢，那不是需要先往里塞入5个0才可以么？这种情况，我们就可以定义一下vector的长度，然后就可以当做数组一样用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">a[<span class="number">5</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="STL-map"><a href="#STL-map" class="headerlink" title="STL-map"></a>STL-map</h3><p>映射map是STL中的一种容器，底层实现是红黑树，我们在之前分析题目的时候提到，这个题如果把名字从字符串改成编号，我们就可以用数组来存储信息以简单地解决这个问题，那么map在这个题中可以做的事情概括成一句话就是，让字符串可以作为下标</p><p>map可以做的事情就是将一种数据类型映射到另一种数据类型，我们知道，对于X集合到Y集合的单射f，有f(x)=y，其中x和y是两个集合中对应的元素。map呢，就是实现了这样一个f，你令f(x)=y，那么x为下标的f值就被指向y，且你可以随时更新f(x)的值，听起来是不是，其实f就像是一个数组</p><p>举个例子，将string映射到int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name &gt;&gt; money;</span><br><span class="line">mp[name] = money; </span><br></pre></td></tr></table></figure><p>代码中name是字符串，而money是数字，也就是说，我们可以将字符串作为下标来建立一个类似数组的东西来处理值了，map的单次查找插入时间为$O(log(n))$，而另有一种STL：unordered_map，底层实现是哈希桶，处理方式和map类似，但是两者在不同的问题规模下各有优劣，同学们可以自行查阅资料学习</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np, ng, money;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消除缓冲区以及解绑</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; np;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将string映射到int</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">name</span><span class="params">(np)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入name列表并初始化对应的mp值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; np; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name[i];</span><br><span class="line">        <span class="comment">// mp可以看做是一个字符串为下标的数组</span></span><br><span class="line">        mp[name[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照题目模拟送礼过程</span></span><br><span class="line">    <span class="built_in">string</span> giver, receiver;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; np; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; giver &gt;&gt; money &gt;&gt; ng;</span><br><span class="line">        mp[giver] -= money;</span><br><span class="line">        <span class="comment">// 特殊判断，防止被零除</span></span><br><span class="line">        <span class="keyword">if</span> (ng == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 计算每个人分到的钱</span></span><br><span class="line">        <span class="keyword">int</span> tmp = money / ng;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ng; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; receiver;</span><br><span class="line">            mp[receiver] += tmp;</span><br><span class="line">            money -= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果钱并不能平均分，则余数没有花出去</span></span><br><span class="line">        mp[giver] += money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照输入顺序输出每个名字和对应的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; np; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp[name[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success modern"><p>Accept</p></div><h2 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h2><ul><li>用最朴素的方式实现这道题(用数组存储名字，根据字符串查找)</li><li>学习并使用map(unordered_map)来完成这道题，了解map的更多用法</li><li>学习哈希表(开址法，拉链法(ASL更低))，用自己写的哈希表完成这道题</li><li>学习set(multiset)，了解和map用法的区别，各自的优劣</li></ul>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VIS2019论文整理(1)</title>
      <link href="2020/10/21/VIS2019-1/"/>
      <url>2020/10/21/VIS2019-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[V] VAST，[I] InfoVis，[S] SciVis </p></blockquote><p>整理一下VIS2019的论文内容(Abstract为主)</p><p>本来打算全部整理在一篇文章里的，发现太乱了，所以一篇就放十个专题左右吧</p><p><a href="https://forever97.github.io/2020/11/02/VIS2019-2/">[VIS2019论文整理(2)]</a></p><hr><h2 id="VIS-Best-Paper"><a href="#VIS-Best-Paper" class="headerlink" title="VIS Best Paper"></a>VIS Best Paper</h2><div class="note default modern"><p><strong>[V] FlowSense: A Natural Language Interface for Visual Data Exploration within a Dataflow System <a href="https://arxiv.org/pdf/1908.00681.pdf">[PDF]</a></strong></p></div><p>数据流可视化系统允许用户构建数据流图，数据流图由查询和可视化模块组成，以指定系统功能，从而实现灵活的可视化数据探索。然而，学习数据流图的使用带来的开销往往会阻碍用户。</p><p>基于此，文章设计了一个用于数据流可视化系统的自然语言界面——FlowSense，利用自然语言处理技术来协助数据流图的构造。FlowSense使用带有特殊话语标记和特殊话语占位符的语义分析器来推广到不同的数据集和数据流图。它明确地将已识别的数据集和图表特殊话语呈现给用户，用于数据流上下文感知。使用FlowSense，用户可以通过简单的英语，更方便地扩展和调整数据流图，文章通过一个案例研究，领域专家用一个真实世界的数据来分析问题以及一个正式的用户研究来评估FlowSense</p><div class="note default modern"><p><strong>[I] Data Changes Everything: Challenges and Opportunities in Data Visualization Design Handoff <a href="https://prism.ucalgary.ca/bitstream/handle/1880/110696/DataChanges_InfoVis2019_Preprint.pdf?sequence=1&isAllowed=y">[PDF]</a></strong></p></div><p>复杂的数据可视化设计项目通常需要具有不同可视化相关技能的人员之间的协作，例如，许多团队包括创建新的可视化设计的设计人员和实现结果可视化软件的开发人员，数据描述工具、可视化设计工具和开发平台之间的差距给致力于创建新的数据可视化的设计人员-开发团队带来了挑战，虽然商业交互设计工具通常支持设计人员和开发人员之间的协作，但创建数据可视化带来了一些当前工具所不支持的独特挑战，特别是，可视化设计人员必须描述和构建对底层数据的理解，然后指定布局、数据编码和其他数据驱动参数，这些参数将在许多不同的数据值之间保持稳定。在较大的团队中，设计人员还必须清楚地将这些映射及其依赖关系传达给开发人员、客户端和其他协作者</p><p>文章报告了对五个大型多学科可视化设计项目的观察和反思，并强调了设计规范和六个data-specific可视化挑战。这些挑战包括适应不断变化的数据、预测数据中的边缘情况、理解技术挑战、明确依赖数据的交互、通信数据映射，以及跨迭代保持数据映射的完整性。基于这些观察，揭示了未来用于原型设计、测试和交流数据驱动设计的工具的机会</p><div class="note default modern"><p><strong>[S] InSituNet: Deep Image Synthesis for Parameter Space Exploration of Ensemble Simulations <a href="https://arxiv.org/pdf/1908.00407">[PDF]</a></strong></p></div><p>文章提出了一个基于深度学习的代理模型——InSituNet，支持参数空间探索的集成仿真，在现场可视化</p><p>由于I/O和存储的限制，现场可视化(在模拟时生成可视化)在处理大规模模拟中越来越流行。然而，由于无法获得原始模拟数据，现场可视化方法限制了事后勘探的灵活性，虽然已经提出了多种基于图像的方法来缓解这一限制，但这些方法缺乏探索仿真参数的能力</p><p>模型被设计为卷积回归模型，学习仿真和可视化参数与可视化结果的映射。使用训练好的模型，用户可以在各种可视化设置下为不同的仿真参数生成新的图像，从而能够深入分析底层集成仿真。通过定量和定性评价，文章证明了InSituNet在燃烧、宇宙学和海洋模拟中的有效性</p><hr><h2 id="A-Tour-of-VAST"><a href="#A-Tour-of-VAST" class="headerlink" title="A Tour of VAST"></a>A Tour of VAST</h2><div class="note default modern"><p><strong>[V] NNVA: Neural Network Assisted Visual Analysis of Yeast Cell Polarization Simulation <a href="https://arxiv.org/pdf/1904.09044">[PDF]</a></strong></p></div><p>在许多科学学科中，复杂的计算模型经常被设计用来模拟真实世界的物理现象。然而，这些仿真模型的计算成本往往非常高，并且涉及大量的仿真输入参数，在模型应用于真正的科学研究之前，需要对这些参数进行分析和适当的校准</p><p>文章提出了一个可视化的分析系统，以促进交互探索性分析高维输入参数空间的复杂酵母细胞极化模拟。该系统可以帮助设计仿真模型的计算生物学家通过修改参数值，直观地校准输入参数，并立即可视化预测的仿真结果，而不需要对每个实例运行原始的昂贵仿真，后端分析框架是一个基于神经网络的代理模型</p><p>文章工作展示了使用神经网络作为视觉分析替代模型的优势，利用训练过的网络对原始模拟进行交互参数敏感性分析，并使用神经网络的激活最大化框架推荐最佳参数配置，在训练过程中，进行了两个案例研究，将结果与原始模拟模型的结果以及之前由专家进行的参数分析结果进行了比较</p><div class="note default modern"><p><strong>[V] Supporting Analysis of Dimensionality Reduction Results with Contrastive Learning <a href="https://arxiv.org/pdf/1905.03911">[PDF]</a></strong></p></div><p>降维(DR)经常用于分析和可视化高维数据，因为它提供了数据的良好的第一眼。然而，为了从数据中获得有用的见解来解释DR结果，还需要额外的分析工作，比如识别集群并理解它们的特征，虽然有许多自动方法(例如基于密度的聚类方法)来识别聚类，但仍然缺乏了解聚类特征的有效方法。一个聚类可以通过其特征值的分布来表征，当特性数量很大时，查看原始特性值并不是一项简单的任务</p><p>为了解决这一难题，作者团队提出了一种可视化分析方法，可以在DR结果中有效地突出集群的基本特征。为了提取基本特征，引入了一种增强的对比主成分分析(cPCA)方法。该方法称为ccPCA (PCA中的对比类簇)，可以计算每个特征对一个类簇和其他类簇之间对比的相对贡献。通过使用ccPCA，团队创建了一个交互式系统，其中包括集群特性贡献的可伸缩可视化。团队用案例研究采用了几个公开的数据集来证明了方法和系统的有效性</p><div class="note default modern"><p><strong>[V] The What-If Tool: Interactive Probing of Machine Learning Models <a href="https://arxiv.org/pdf/1907.04135">[PDF]</a></strong></p></div><p>开发和部署机器学习(ML)系统的一个关键挑战是理解它们在广泛的输入范围内的性能，为了应对这一挑战，作者团队创建了What-IF工具，这是一个开源的应用程序，允许从业者使用最少的编码来探测、可视化和分析ML系统。该工具让从业者可以在假设的情况下测试性能，分析不同数据特性的重要性，并在多个模型和输入数据子集之间可视化模型行为。它还允许从业者根据多个ML公平性指标来度量系统。文章主要描述了该工具的设计，并报告不同组织的实际使用情况</p><div class="note default modern"><p><strong>[V] Understanding the Role of Alternatives in Data Analysis Practices <a href="https://hal.telecom-paristech.fr/hal-02182349v2/document">[PDF]</a></strong></p></div><p>数据工作者是将执行数据分析活动作为日常工作的一部分，但不正式定义为数据科学家的人。他们来自不同的领域，经常需要探索各种假设和理论、各种数据源、算法、方法、工具和可视化设计。综合起来，称之为替代方案</p><p>为了更好地理解和描述替代方案在分析中的作用，作者团队对12名具有不同专业知识的数据工作者进行了半结构化的访谈，进行了四种类型的分析来理解：1.为什么数据工作者要探索替代方案；2.选择的不同概念，以及它们如何融入感知过程；3.围绕备选方案的高级流程；4.继承策略来产生、探索和管理这些替代方案</p><p>团队发现参与者的不同层次的领域和计算专业知识，使用不同工具的经验，以及在他们更广泛的背景下的协作，在他们如何探索这些替代方案中扮演了重要的角色。这些发现表明需要更多地关注对替代方案的更深理解，需要更好的工具来促进替代方案的探索、解释和管理</p><p>基于这些分析和发现，团队提出了一个基于参与者1)关注程度、2)抽象水平和3)分析过程的框架。文章展示了这个框架如何帮助理解数据工作者在分析中如何考虑这类替代方案，以及工具设计者如何创建工具来更好地支持它们</p><div class="note default modern"><p><strong>[V] VASABI: Doing User Behaviour Analytics through Interactive Visual Hierarchical User Profiles <a href="https://openaccess.city.ac.uk/id/eprint/22591/8/">[PDF]</a></strong></p></div><p>用户行为分析(UBA)系统提供了复杂的模型，可以捕捉用户长期的行为，目的是识别不符合用户档案的欺诈行为。由于UBA模型的解释所面临的挑战，文章提出了一种可视化分析方法，以帮助分析人员在多个层次(即个体和群体层次)上获得对用户行为的全面理解</p><p>作者团队采用以用户为中心的方法来设计一个可视化的分析框架，支持对用户集合和他们在数字应用程序中进行的众多活动的分析。该框架的核心是层次化用户配置文件的概念，层次化用户配置文件是基于源自会话的特性而构建的，以及使用主题建模方法来总结和分层用户行为的用户任务</p><p>团队外部化了一系列的分析目标和任务，并通过与专家一起执行的用例来评估提出的方法。团队观察到，在交互式可视化层次用户档案的帮助下，分析人员能够有效地进行探索性和调查性分析，能够理解用户行为的特征，在评估可疑用户和活动的同时做出明智的决定</p><hr><h2 id="Provocations"><a href="#Provocations" class="headerlink" title="Provocations"></a>Provocations</h2><div class="note default modern"><p><strong>[I] Data by proxy – material traces as autographic visualizations <a href="https://arxiv.org/pdf/1907.05454">[PDF]</a></strong> </p></div><p>根据定义，信息可视化将自身限制在符号信息的领域。这篇文章讨论了为什么该领域还应该考虑数据形式的符号编码，包括物理痕迹和物质指标。这篇论文比较了物理痕迹和可视化，并描述了产生、揭示和解释它们的技术和可视化实践，通过对信息可视化与自动图形可视化逆向模型的对比，探讨了材料数据的设计原则。Autographic visualization解决了信息可视化的局限性，比如不能直接反映数据生成的实际情况。这两个模型之间的比较允许探索信息可视化背后的知识假设，并揭示与科学可视化和跟踪阅读的丰富历史的联系</p><p>本文首先讨论了数据可视化和相应现象之间的差距，然后研究了材料可视化如何弥合这一差距。它将自动图形可视化与范式(如数据物理化和索引可视化)结合在一起，并将其置于符号学、科学和技术研究(STS)和科学表征的历史等更广泛的理论文献中。本文的主要部分提出了一个用于自动图形可视化的基本设计词汇，并举例说明公民科学家如何在他们的展示中使用自动图形原则，这似乎违反了信息可视化的规范原则，但成功地实现了证据构建的其他修辞目的。最后，本文讨论了自动图形可视化的局限性，提出了痕迹感知的实证研究路线图，并对信息可视化和自动图形可视化技术的发展进行了思考</p><div class="note default modern"><p><strong>[I] Design by Immersion: A Transdisciplinary Approach to Problem-Driven Visualizations <a href="http://openaccess.city.ac.uk/id/eprint/22491/1/hall_design_2019Postprint.pdf">[PDF]</a></strong></p></div><p>虽然以前的工作存在如何从问题驱动的可视化工作和设计研究中引导和传播见解，但是文献并没有解决如何在跨学科团队中以推进所有相关学科的方式实现这些目标</p><p>在文章中介绍并定义了一种新的方法论范式，即浸入式设计，它为问题驱动的可视化工作提供了另一种视角。通过可视化研究人员参与目标领域的工作(或领域专家参与可视化研究)，浸入式设计将跨学科的经验嵌入到可视化过程的中心</p><p>文章说明了通过沉浸式设计的过程是如何打开了一套多样的设计活动，这些设计活动可以根据合作、项目和目标的类型以不同的方式组合在一起。最后，文章讨论了沉浸式设计的挑战和潜在的陷阱</p><div class="note default modern"><p><strong>[I] Criteria for Rigor in Visualization Design Study <a href="http://openaccess.city.ac.uk/id/eprint/22644/1/Criteria%20for%20Rigor%20in%20Visualization%20Design%20Study.pdf">[PDF]</a></strong></p></div><p>通过可视化设计研究，作者团队提出了一种新的研究视角，强调设计是一种探究的方法，通过它实现的广泛的知识贡献是多元的，主观的和社会构建的。从这个解释主义者的立场，团队探索了可视化设计研究的本质，并提出了六个严格的标准，建议根据可视化设计研究及其报告所提供信息的程度来建立和判断其严密性，反射性，丰富性，是似而非的，共鸣性和透明性</p><p>这一观点和标准是通过四年围绕社会科学、信息系统和设计知识的严谨性和本质的讨论而构建的。作者建议来自同源学科的方法来支持可视化研究人员在设计研究的规划、执行和报告过程中满足这些标准</p><p>通过一系列有意提出的问题，文章探讨了可视化设计研究的新视角的含义，得出的结论是，作为一门学科，可视化还不能很好地接受、培养并充分受益于设计研究的严格的、解释性的方法。文章提出的观点和标准旨在激发围绕可视化设计研究的本质和学科更广泛的基础的对话和辩论</p><div class="note default modern"><p><strong>[I] What is Interaction for Data Visualization? <a href="https://hal.archives-ouvertes.fr/hal-02197062/document">[PDF]</a></strong></p></div><p>交互是数据可视化的基础，但是”交互”在可视化上下文中的含义是模糊和混乱的。作者认为，这种混淆是由于缺乏共识的定义。为了解决这个问题，文章从综合可视化社区的交互的包容性观点开始——包括来自信息可视化、可视化分析和科学可视化的见解，以及高级和初级可视化研究人员的输入</p><p>一旦这个观点形成，将看到交互是如何在人机交互(HCI)领域中定义的。通过提取可视化和人机交互中交互观点的共性和差异，作者合成了可视化交互的定义</p><p>本文的定义旨在成为一种思考工具，并激发新颖而大胆的交互设计实践。作者希望通过更好地理解可视化中的交互是什么，它可以是什么来丰富可视化系统中交互的质量，并增强用户的能力</p><div class="note default modern"><p><strong>[I] Why Authors Don’t Visualize Uncertainty <a href="http://users.eecs.northwestern.edu/~jhullman/Value_of_Uncertainty_Vis_CR.pdf">[PDF]</a></strong></p></div><p>尽管已经有提出在数据中传达不确定性来源的技术，但在媒体文章、数据驱动的报告和消费者应用中，明确地呈现不确定性是例外而不是规则，这项工作考虑了，为什么如此之多的可视化作者选择不可视化不确定性，文章提供了一份可视化作者之间关于与不确定性沟通相关的实践、关联和态度的详细描述，这些研究来自于对90位经常为他人创建可视化的作者的调查结果，并采访了13位有影响力的可视化设计师。文章研究结果突出了作者所面临的挑战，并揭示了关于不确定性在可视化中所扮演角色的假设和不一致性 (这里写的作者指可视化作者而不是这篇文章的作者)</p><p>特别是，作者承认描述不确定性的价值与省略直接描述不确定性的规范之间出现了明显的矛盾。为了解释这一矛盾，文章中提出了一个视觉化交际中的不确定性省略的修辞模型</p><p>文章中还采用了一种正式的统计模型，即观众如何判断可视化信号的强度，以可视化为基础的传播，以论证不确定性传播必然会降低观众统计推断的自由度。最后，提出了关于不确定性沟通的可视化研究如何能够更好地服务从业者当前的需求和价值观，同时加深对强化不确定性遗漏的假设的理解的建议</p><hr><h2 id="Scalar-Topology"><a href="#Scalar-Topology" class="headerlink" title="Scalar Topology"></a>Scalar Topology</h2><div class="note default modern"><p><strong>[S] Progressive Wasserstein Barycenters of Persistence Diagrams <a href="https://julien-tierny.github.io/stuff/papers/vidal_vis19.pdf">[PDF]</a></strong></p></div><p>文章提出了一种有效的 持续图 瓦瑟斯坦重心(Wasserstein barycenters) 渐进逼近算法，并应用于集成数据的可视化分析。给定一组标量字段，文章的方法允许计算一个持久性图，该图代表该集合，并可视化地表达在该集合中发现的主要特性的数量、数据范围和显著性</p><p>团队重述了Wasserstein距离近似的有效算法，以扩展先前在重心估计方面的工作。提出了一种新的快速逼近质心的算法，该算法通过迭代递增计算精度和输出图中持久化特征的数量来逐步逼近质心。这样的累进性极大地提高了实践中的收敛性，并允许设计一个可中断的算法，能够尊重计算时间的限制，这使得交互时间内的Wasserstein重心近似成为可能。</p><p>本文介绍了一个集成聚类的应用程序，重新使用k-means算法来利用重心，并在执行时间限制内计算有意义的集成数据簇及其重心图。对合成数据集和现实生活中的数据集进行的广泛实验表明，该算法收敛于质心，这些质心在应用方面具有定性意义，在定量上与以前的技术相比较，同时提供了一个数量级的加速</p><div class="note default modern"><p><strong>[S] The Effect of Data Transformations on Scalar Field Topological Analysis of High-Order FEM Solutions <a href="https://www.researchgate.net/profile/Ashok_Jallepalli/publication/334494490_The_Effect_of_Data_Transformations_on_Scalar_Field_Topological_Analysis_of_High-Order_FEM_Solutions/links/5d2e1391a6fdcc2462e62c3d/The-Effect-of-Data-Transformations-on-Scalar-Field-Topological-Analysis-of-High-Order-FEM-Solutions.pdf">[PDF]</a></strong></p></div><p>高阶有限元方法(HO-FEM)因其在求解复杂流动动力学方面的成功而在模拟界中越来越受欢迎。越来越需要分析这些模拟所产生的输出数据。<br>同时，拓扑分析工具正在成为研究模拟数据的强大方法，然而，由于两个原因，目前大多数拓扑分析方法在HO-FEM模拟数据中的应用有限：首先，当前的拓扑工具是为线性数据设计的(多项式度为1)，但是这些模拟输出的数据的多项式度通常较高(通常高达多项式度为6)，其次，模拟数据和模拟数据的导出量在单元边界处存在不连续，且这些不连续不符合拓扑工具的输入要求。解决这两个问题的一种方法是转换高阶数据，以实现拓扑分析的低阶连续输入。然而，很少有工作评估可能的转换选择及其对拓扑分析的下游影响</p><p>文章进行了一项实证研究，以评估两种常用的数据转换方法以及最近引入的L-SIAC滤波器用于处理高阶模拟数据。研究结果显示，不同的行为是可能的。文章中提供了一些指导，说明如何使用当前可用的拓扑分析实现最好地考虑HO-FEM模拟的拓扑分析管道</p><hr><h2 id="VIS-Meets-Machine-Learning"><a href="#VIS-Meets-Machine-Learning" class="headerlink" title="VIS Meets Machine Learning"></a>VIS Meets Machine Learning</h2><div class="note default modern"><p><strong>[V] GUIRO: User-Guided Matrix Reordering <a href="https://vcg.seas.harvard.edu/publications/guiro-user-guided-matrix-reordering/paper">[PDF]</a></strong></p></div><p>矩阵表示是一种被实践证明是有效的关系可视化技术(或网络)数据。但是，如果母表(类似于节点链接图)的布局揭示了底层的数据拓扑，那么它们是最有效的，考虑到许多已开发的算法，一个实际的问题出现了:“我应该为我手边的数据集选择哪个矩阵重排序算法?”，更糟糕的是，对同一数据集应用不同的重排序算法可能会产生明显不同的视觉矩阵模式。这就导致了这些全自动的、通常是启发式的黑箱过程的可信赖性和可解释性的问题</p><p>基于此，文章提出了GUIRO，一个可视化的分析系统，它可以帮助新手、网络分析师和算法设计者打开黑箱。用户可以研究70种可达矩阵排序算法的实用性和表达性，对于网络分析师，文章中介绍了一种新的模型空间表示和两种交互技术，用于用户引导的行或列，特别是组的重排序(子矩阵重排序)，这些新技术有助于理解全局和局部数据集拓扑</p><p>作者通过让算法设计者访问16个重排序质量指标和可视化的探索方法来在行/列排列级别上比较重排序实现来支持算法设计者。并对GUIRO进行了12个主题的指导探索性用户研究，一个案例研究展示了它在真实场景中的有用性，并通过专家研究收集了对设计决策的反馈。文中提出的方法甚至可以帮助没有经验的用户理解矩阵模式，并允许用户引导重排序算法。GUIRO帮助增加矩阵重新排序算法的透明度，从而帮助广泛的用户更好地了解复杂的重排序过程，反过来支持数据和重排序算法的洞察力</p><div class="note default modern"><p><strong>[S] LassoNet: Deep Lasso-Selection of 3D Point Clouds <a href="https://www.researchgate.net/profile/Wei_Zeng13/publication/335273831_LassoNet_Deep_Lasso-Selection_of_3D_Point_Clouds/links/5de7505d4585159aa45f7b25/LassoNet-Deep-Lasso-Selection-of-3D-Point-Clouds.pdf">[PDF]</a></strong></p></div><p>在三维点云的探索性分析和可视化中，选择是一个基本的任务。以往对选择方法的研究主要基于局部点密度等启发式方法，这限制了它们在一般数据中的适用性。具体的挑战根源于点云(例如，稠密与稀疏)、视点(例如，闭塞与非闭塞)和套索(例如，小与大)所隐含的巨大变化</p><p>文章引入了一种新的深度神经网络LassoNet来进行三维点云的lasso-selection，试图学习从视点和套索到点云区域的潜在映射。为此，通过三维坐标变换和朴素选择将用户目标点与视点和lasso信息结合起来，并通过意图滤波和最远点采样提高方法的可扩展性</p><p>作者使用在两个不同的点云数据上有超过30K个lasso-selection记录的数据集来训练一个分层网络。最后进行了一项正式的用户研究，以比较LassoNet与两种先进的lasso-selection方法。评估结果证实，文中的方法提高了不同组合的三维点云、视点和lasso-selection的选择效率和有效性</p><p>项目演示地址：<a href="https://lassonet.github.io/">https://lassonet.github.io/</a></p><div class="note default modern"><p><strong>[S] TSR-TVD: Temporal Super-Resolution for Time-Varying Data Analysis and Visualization <a href="http://www.nd.edu/~cwang11/research/vis19-tsr.pdf">[PDF]</a></strong></p></div><p>文章提出了TSR-TVD，一个新的深度学习框架，使用对抗数据生成时间超分辨率(TSR)的时变数据(TVD)。TSR-TVD是第一个应用循环生成网络(RGN)的作品，它是循环神经网络(RNN)和生成对抗网络(GAN)的结合，从低分辨率的体积序列生成时间高分辨率的体积序列</p><p>TSR-TVD的设计包括一个生成器和一个鉴别器。生成器以一对体积作为输入，并通过前向和后向预测输出合成的中间体积序列。鉴别器以合成的中间体积作为输入，并产生一个分数来表示这些体积的真实度。这种方法也处理多元数据，其中一个变量的训练网络被用于为另一个变量生成TSR</p><p>为了证明TSR-TVD的有效性，文中展示了几个时变多元数据集的定量和定性结果，并将方法与仅基于RNN或CNN的标准线性插值和解决方案进行比较</p><div class="note default modern"><p><strong>[V] Facetto: Combining Unsupervised and Supervised Learning for Hierarchical Phenotype Analysis in Multi-Channel Image Data <a href="https://www.namwkim.org/assets/files/publications/journal/facetto-combining-unsupervised-and-supervised-learning-for-hierarchical-phenotype-analysis-in-multi-channel-image-data/paper.pdf">[PDF]</a></strong></p></div><p>文中提出的Facetto是一个可扩展的可视化分析应用程序，用于发现人类肿瘤和组织的高维多通道显微图像中的单细胞表型。这些图像代表了数字组织学的前沿，并有望彻底改变癌症等疾病的研究、诊断和治疗方式。高度多路复用的组织图像是复杂的，包括109个或更多的像素，60多个通道和数百万个单独的细胞。这使得手动分析具有挑战性并容易出错。现有的自动化方法在很大程度上也不够充分，因为它们无法有效地利用解剖学病理学家所掌握的人体组织生物学的深刻知识。为了克服这些挑战，Facetto支持对单元类型和状态进行半自动分析。它将无监督学习和监督学习集成到图像和特征探索过程中，并提供分析来源的工具。专家们可以对数据进行聚类，以发现新的癌症和免疫细胞类型，并利用聚类结果训练卷积神经网络，从而对新细胞进行相应的分类。同样，可以对分类器的输出进行聚类，以发现聚合模式和表型子集。此外还引入了一种新的分层方法来跟踪用户创建的分析步骤和数据子集;这有助于识别细胞类型。用户可以建立表型树，并与由此产生的高维特征和图像空间的层次结构进行交互。文中报告了领域科学家探索各种大规模荧光成像数据集的用例。演示了Facetto如何帮助用户指导聚类和分类过程，检查分析结果，并获得对癌症生物学的新科学见解。</p><div class="note default modern"><p><strong>[V] ProtoSteer: Steering Deep Sequence Model with Prototypes <a href="https://www.researchgate.net/profile/Yao_Ming8/publication/335744227_ProtoSteer_Steering_Deep_Sequence_Model_with_Prototypes/links/5d91a0eb299bf10cff1a1764/ProtoSteer-Steering-Deep-Sequence-Model-with-Prototypes.pdf">[PDF]</a></strong></p></div><p>最近，在许多应用领域(包括预测医疗保健、自然语言处理和日志分析)中越来越多地采用深度序列模型(例如LSTMs)。然而，这些模型复杂的工作机制限制了领域专家对它们的访问，它们的黑箱特性也使得将专家的特定领域知识合并到模型中成为一项具有挑战性的任务。</p><p>在ProtoSteer(原型转向)中，本文解决了直接让领域专家参与来引导深层序列模型的挑战，而不需要依赖模型开发人员作为中介。本文的方法源于基于案例的推理，它模仿了人类一般的问题解决过程，即参考过去的经验来解决新问题。文章中利用ProSeNet(原型序列网络)，它从历史数据中学习一小组范例案例(即原型)。在ProtoSteer中，它们既是原始数据的有效视觉总结，也是模型决策的解释。通过使用ProtoSteer，领域专家可以交互式地检查、评论和修改原型。然后系统合并用户指定的原型，并增量地更新模型。团队在应用领域进行广泛的案例研究和专家访谈，包括基于文本的情绪分析和基于车辆故障日志的预测诊断。结果表明，领域用户的参与有助于获得具有更简洁原型的可解释模型，同时保持相似的精度</p><hr><h2 id="Features-and-Topology"><a href="#Features-and-Topology" class="headerlink" title="Features and Topology"></a>Features and Topology</h2><div class="note default modern"><p><strong>[S] Extraction and Visual Analysis of Potential Vorticity Banners around the Alps <a href="https://pdfs.semanticscholar.org/43f2/afe41f5f386066732c3b1336e3570e0cc69d.pdf">[PDF]</a></strong></p></div><p>势涡量(PV)是一个可以通过结合大气中的旋转和分层来计算的量。由于这些物理过程的结合，势涡量被认为是大气动力学中最重要的标量之一。它能够解释锋面雨带的发生，并在温带气旋的特别强风峰中起关键作用。当风绕过山峰而不是越过山峰时，一个潜在的涡量累积就像拉长的条幅一样在山脉的背风处形成，这些所谓的潜在涡度条幅的作用最近引起了气象界相当大的兴趣，例如由于它们对航空风危害和海上运输的影响</p><p>为了支持气象学家和气候学家分析这些结构，本文开发了一个提取算法和一个由多个链接视图组成的可视化探索框架。对于PV条幅的提取，应用了一个预测-校正算法，该算法遵循流线，并将其与势涡量的极值线对齐，利用层次聚类算法，根据不同来源的横幅广告的邻近程度对其进行分组。为了可视化地分析与时间相关的横幅几何图形，文章中提供了交互式概览，并根据需要对细节进行查询，包括对不同时间步长、潜在相关标量和风矢量场的分析</p><p>特别地，文中研究了相对湿度和条幅之间的关系，以了解它们在指示降水发展方面的潜力。通过本文的方法，合作的气象学家们对三维过程有了更深的理解，这可能会促进未来的后续研究</p><div class="note default modern"><p><strong>[S] Multi-Scale Topological Analysis of Asymmetric Tensor Fields on Surfaces <a href="http://web.engr.oregonstate.edu/~zhange/images/2Dasymmetric_multiscale.pdf">[PDF]</a></strong></p></div><p>不对称张量场在许多科学和工程领域都有应用，例如流体动力学。二维不对称张量场的可视化和分析的最新进展集中在张量场的点态分析和有效的可视化隐喻，如颜色、符号和超流线。文中提供了一个新的多尺度的拓扑分析框架的不对称张量场。这个多尺度框架是基于特征值和特征向量图的概念。框架的核心是识别修改图的原子操作，以及指导简化图的顺序的尺度定义，使得对不同大小的数据进行拓扑分析的可视化更加清晰和集中。同时文中也提供了有效的算法来实现这些运算。此外，系统对这些图提供物理解释。为了演示系统的效用，采用了多尺度分析的数据来计算流体动力学</p><div class="note default modern"><p><strong>[S] Vector Field Topology of Time-Dependent Flows in a Steady Reference Frame <a href="https://cgl.ethz.ch/Downloads/Publications/Papers/2019/Ibr19c/Ibr19c.pdf">[PDF]</a></strong></p></div><p>非定常流场的拓扑分析至今仍是流场可视化中最大的挑战之一。本文在旋涡提取的基础上，为二维和三维流定义了一个依赖时间的矢量场拓扑。在这样工作中，把矢量场分成两个分量:一个矢量场，其中流变得稳定，其余的环境流描述拓扑元素(如汇流、源和鞍)和特征曲线(涡线和分叉线)的运动。为此，团队扩展了最近的局部优化方法，通过位移变换从连续介质力学建模空间变化的变形。然后比较和讨论了与现有的基于局部和基于集成的拓扑抽取方法的关系，举例说明了在最优框架中从鞍座中分离的种子与基于集成的线向量场拓扑对齐，与基于线的方法相比，本文的方法给出了每个时间切片的完整拓扑图，包括在时间域边界附近的步骤。通过本文工作，现在即使只有很少的时间片可用，也可以提取拓扑信息。文中在几个分析和数值模拟流程中演示了该方法，并讨论了未来工作的实际方面、局限性和机会</p><div class="note default modern"><p><strong>[V] Scalable Topological Data Analysis and Visualization for Interpreting Data-Driven Models in Scientific Applications <a href="http://www.sci.utah.edu/~shusenl/publications/VAST_19.pdf">[PDF]</a></strong></p></div><p>随着机器学习技术在科学和工程领域的大规模应用的迅速采用，可视化领域的两大挑战也汇聚在一起。首先，黑盒模型(例如，深度神经网络)的使用需要先进的技术来探索和解释模型的行为。其次，计算技术的快速发展产生了大量的数据集，这些数据集需要能够处理数百万甚至更多样本的技术，尽管针对这些可解释性挑战提出了一些解决方案，但它们通常不会超出数千个样本的范围，也不能提供科学家们正在寻找的高层次直觉</p><p>基于此，本文提出了第一个可扩展的解决方案，用于探索和分析科学数据分析管道中经常遇到的高维函数。通过结合一种新的流式邻域图构造、相应的拓扑计算和一种新的数据聚合方案，即拓扑感知数据库，可以对高维数据的拓扑和几何方面进行交互探索，文中包含了高能量密度(HED)物理学和计算生物学的两个用例，在用例中演示了这些能力如何在这两个应用程序中产生重要的新见解</p><hr><h2 id="Bias-amp-Patterns"><a href="#Bias-amp-Patterns" class="headerlink" title="Bias &amp; Patterns"></a>Bias &amp; Patterns</h2><div class="note default modern"><p><strong>[I] Biased Average Position Estimates in Line and Bar Graphs: Underestimation, Overestimation, and Perceptual Pull <a href="http://cyxiong.com/wp-content/uploads/2019/07/VIS_2019_Anchoring___Perceptual_Pull-3.pdf">[PDF]</a></strong></p></div><p>在数据的视觉描述中，与其他编码(如色调)相比，位置(即直线或条的垂直高度)被认为是编码信息最精确的方式。不仅其他编码不如位置精确，而且它们也容易产生系统偏差(例如，颜色分类边界会扭曲感知到的颜色差异)。相比之下，位置的高精确度似乎可以保护它不受这种偏见的影响，通过三个实证研究表明，虽然位置可能是一种精确的数据编码形式，但它也会在如何编码值方面产生系统偏差，至少在短延迟的平均位置报告中是这样的。在单行或一组单条的显示中，对平均头寸的报告有显著的偏差，例如线的头寸被低估了，线的头寸被高估了，在具有多个数据系列(即多个行和/或一组条)的显示中，这种系统性偏差仍然存在。实验中还观察到“感知拉扯”，即每个系列的平均位置估计被“拉”向另一个。这些发现表明，虽然位置可能仍然是最精确的视觉数据编码形式，但它也可能有系统性的偏差</p><div class="note default modern"><p><strong>[I] A Task-based Taxonomy of Cognitive Biases for Information Visualization <a href="http://www.cs.umd.edu/hcil/trs/2018-09/2018-09.pdf">[PDF]</a></strong></p></div><p>信息可视化设计人员努力设计数据显示，使其能够有效地探索、分析和交流数据中的模式，从而做出明智的决策。不幸的是，人类的判断和决策是不完美的，经常受到认知偏见的困扰。有有限的经验研究证明这些偏见如何影响视觉数据分析活动。现有的分类是由认知理论组织的，很难与可视化任务联系起来，基于对文献的调查，文中提出了基于任务的对154种认知偏差进行分类，并将其分为7个主要类别，作者团队希望分类法将帮助可视化研究人员将他们的设计与相应的可能偏差联系起来，并引导新的研究来检测和解决数据可视化中的偏见判断和决策制定</p><div class="note default modern"><p><strong>[I] The Curse of Knowledge in Visual Data Communication <a href="http://visualthinking.psych.northwestern.edu/VisualizationCurse2017/Xiong,%20van%20Weelden%20&%20Franconeri%20InfoVis%202017%20.pdf">[PDF]</a></strong></p></div><p>图片的观察者可以从任何一组可视化数据值中提取许多潜在的关系和模式。即使两个人看到的是同样的景象，他们经常会衍生出不同的故事，从而导致误解。当人们被告知背景信息，使他们认为数据中的一种模式在视觉上显著时，他们相信其他人也会体验到同样的视觉显著性，即使他们被明确告知其他人对背景信息是无所知的，在观看描绘这些数据的线条或柱状图之前，参与者被告知了三个关于影响公众投票数据的政治事件的背景故事中的一个。根据他们听到的背景故事，数据中的一个模式在视觉上特别突出。然后，他们被要求预测那些不了解背景故事的天真观众会在视觉化的画面中发现的最突出的视觉特征，他们强烈地受到自己知识的影响，尽管有明确的指示要他们忽略它，预测其他人会发现同样的模式在视觉上最突出</p><p>这个结果反映了一种心理现象，在认知推理、语言学和教育中都有体现，被称为“知识的诅咒”——一种认知偏差，内容专家试图重新创造一个新手的心理状态，通常会导致沟通失败，目前的研究结果表明，知识的诅咒也困扰着数据的视觉感知，这就解释了为什么演讲者、论文作者和数据分析师在交流数据模式时无法与观众沟通</p><div class="note default modern"><p><strong>[V] Evaluating Perceptual Bias During Geometric Scaling of Scatterplots <a href="http://www.cad.zju.edu.cn/home/vagblog/VAG_Work/GeometricScaling.pdf">[PDF]</a></strong></p></div><p>散点图经常被缩放以适应多视图和多设备数据分析环境中的显示区域。一种常用的缩放方法是同步和比例地放大或缩小整个散点图和内部点。这个过程称为几何缩放。然而，散点图的几何尺度可能会导致感知偏差，即视觉特征的感知值和物理值可能会因几何尺度而分离。例如，如果一个散点图从一台笔记本电脑投射到一个大投影仪屏幕上，那么观察者可能会觉得投影仪上显示的散点图比在笔记本电脑上观看的散点图有更少的点</p><p>本文对几何尺度对散点图中视觉特征感知偏差的影响进行了评价研究。研究的重点是三个基本的视觉特征(即，数度，相关性，和聚类分离)和三个假设，基于经验制定。团队使用精心准备的综合数据精心设计了三个对照实验，并根据参与者的主观体验招募参与者来完成实验。通过对实验结果的详细分析，得到了一组有指导意义的结果：首先，几何缩放引起的偏差与缩放比呈线性关系。第二，从正态分布和均匀分布的散点图测量的偏差之间不存在显著差异。第三，改变点的半径可以在一定程度上纠正偏置。这些发现可用于启发不同场景下散点图的设计决策</p><div class="note default modern"><p><strong>[V] FDive: Learning Relevance Models using Pattern-based Similarity Measures <a href="https://arxiv.org/pdf/1907.12489.pdf">[PDF]</a></strong></p></div><p>由于大型高维数据集的维数性和模式复杂性，对感兴趣的模式进行检测具有一定的难度，因此，分析师需要自动支持相关模式的提取。本文中提出了FDIVE，一个视觉主动学习系统，帮助创建视觉可探索的关联模型，并辅助学习基于模式的相似度。团队使用一组用户提供的标签来对相似度度量进行排序，由特征描述符和距离函数组合组成，通过它们区分相关数据和不相关数据的能力。基于最佳排序的相似度度量，系统计算一个交互式基于地图的自组织关联模型，根据聚类关系对数据进行分类，它还自动提示进一步的相关性反馈，以提高其准确性。不确定区域，特别是在决策边界附近，可以被用户突出和细化。文中通过一个研究分类的电子显微镜图像的脑细胞案例将文章方法和SOTA特征选择方法进行比较，结果表明，FDIVE提高了相关性模型的质量和理解，从而可以为大脑研究带来新的见解</p><hr><h2 id="Multiscale-Visualization"><a href="#Multiscale-Visualization" class="headerlink" title="Multiscale Visualization"></a>Multiscale Visualization</h2><div class="note default modern"><p><strong>[I] Pattern-Driven Navigation in 2D Multiscale Visualizations with Scalable Insets <a href="https://vcg.seas.harvard.edu/publications/pattern-driven-navigation-in-2d-multiscale-visualizations-with-scalable-insets/paper">[PDF]</a></strong></p></div><p>本文介绍了可伸缩Insets，这是一种用于在多尺度可视化(如十亿像素图像、矩阵或地图)中交互式地探索和导航大量带注释的模式的技术。在多尺度可视化中探索许多稀疏分布的模式是具有挑战性的，因为可视化表示会随着缩放级别的变化而变化，缩放时上下文和导航线索会丢失，而且导航也很耗时</p><p>文章采用使用insets(即放大的带注释的模式的缩略图视图)来可视化太小而在某些缩放级别无法识别的带注释的模式。Insets支持用户搜索、比较和上下文化模式，同时减少所需的导航量，它们被动态地放置在视口内或沿着视口的边界，从而在位置和上下文保存之间提供一种平衡。带注释的模式按位置和类型交互地聚集。它们被可视化地表示为一个聚合的inset，以在单个viewport中提供可伸缩的探索。在一个有18名参与者的受控用户研究中，团队发现可伸缩Insets可以加快视觉搜索，并提高模式比较的准确性，但与基线技术相比，频率估计要慢一些，同时，基因组学领域的专家表示，可伸缩Insets很容易学习，并为可伸缩Insets如何应用于开放式数据探索场景提供了初步见解</p><div class="note default modern"><p><strong>[S] Multi-Scale Procedural Animations of Microtubule Dynamics Based on Measured Data <a href="https://www.cg.tuwien.ac.at/research/publications/2019/klein_2019_PMP/klein_2019_PMP-paper.pdf">[PDF]</a></strong></p></div><p>生物学家经常使用计算机图形来可视化结构，由于物理限制，用显微镜是不可能成像的。这种结构的一个例子是微管，它存在于每个真核细胞中。它们是细胞骨架的一部分，维持细胞的形状，并在细胞分裂中发挥关键作用</p><p>文中提出了一个科学准确的多尺度微管动力学过程模型作为程序动画的一个新的应用场景，它可以生成微管整体形状、分子结构的可视化，以及微管生长和拆卸动态行为的动画，这个模型的分辨率从几十微米到原子分辨率都有。模型的所有方面都是由科学数据驱动的。与传统的手动动画方法相比，这种方法的优势在于，当底层数据发生变化时，例如由于new evidence，可以立即重新创建模型。程序动画的概念以其通用的形式呈现，并有一些新颖的扩展，促进了一个容易的转换到其他领域的涌现的多尺度行为</p><div class="note default modern"><p><strong>[S] Scale-Space Splatting: Reforming Spacetime for the Cross-Scale Exploration of Integral Measures in Molecular Dynamics <a href="https://arxiv.org/pdf/1907.09939">[PDF]</a></strong></p></div><p>从基于粒子的模拟(如分子动力学)中理解大量的时空数据，通常依赖于对聚合测度的计算和分析。然而，聚集，隐藏了被研究现象的时空定位的结构信息。这导致了一些退化的情况，即度量无法明显捕捉的行为。</p><p>为了深入挖掘这些集合值，本文提出了一种多尺度视觉挖掘技术。新表示基于部分领域聚合，使构建连续的规模空间的离散数据集和同时探索的规模在空间和时间。作者团队将这两个尺度空间连接在一个尺度空间-时空立方体中，并将模型链接视图通过这个立方体作为正交切片，从而实现了在多个尺度上快速识别时空模式。为了证明方法的有效性，文中展示了蛋白质配体模拟的先进探索</p><div class="note default modern"><p><strong>[S] ScaleTrotter: Illustrative Visual Travels Across Negative Scales <a href="https://hal.inria.fr/hal-02177779/document">[PDF]</a></strong></p></div><p>文中提出了ScaleTrotter，一个用于生物中尺度数据交互、多尺度可视化的概念框架，特别是基因组数据。ScaleTrotter允许观察者顺利地在从细胞核连接数个数量级过度到DNA的原子，创建基因组数据的交互式可视化所面临的挑战，在许多方面都与天文学等需要多尺度表示的其他领域存在根本不同。首先，基因组数据有相互交织的规模水平——DNA是一个非常长，连接在一起的分子，在所有规模水平上都表现出来，其次，DNA的元素不会随着放大而消失——相反，它们被观察到的尺度水平不同地将这些元素组合在一起。第三，团队有完整数据集和所有规模层次的详细信息和几何图形，这对交互式视觉探索提出了挑战，最后，基因组数据的概念规模级别接近规模空间，这要求找到方法，以可视化的方式将较小的规模嵌入到较粗的规模中</p><p>文中通过创建一个新的多尺度可视化概念来解决这些挑战。团队使用了一个依赖于比例的相机模型，它控制了比例在它们各自父元素中的可视嵌入，比例层次结构子集的呈现，以及视图的位置、大小和范围。在遍历刻度时，ScaleTrotter漫游于在集成的可视化中描述的2D和3D可视化表示之间。具体来说，团队讨论了这种形式的多尺度可视化如何遵循基因组数据的具体特征，并描述了它的实现</p><hr><h2 id="Drawing-Nodes-and-Edges"><a href="#Drawing-Nodes-and-Edges" class="headerlink" title="Drawing Nodes and Edges"></a>Drawing Nodes and Edges</h2><div class="note default modern"><p><strong>[I] A Deep Generative Model for Graph Layout <a href="https://arxiv.org/pdf/1904.12225">[PDF]</a></strong></p></div><p>不同的布局可以表征同一图形的不同方面。因此，找到一个“好的”图形布局是图形可视化的一个重要任务。在实践中，用户经常使用不同的方法和不同的参数设置来可视化多个布局中的图形，直到他们找到最适合可视化目的的布局。然而，这种反复试验的过程往往是偶然的，而且非常耗时。</p><p>为了给用户提供一种直观的方式来浏览布局设计空间，文中提出了一种使用深层生成模型系统地可视化不同布局的图形的技术。团队设计了一种编码器-解码器架构来从一组示例布局中学习模型，其中编码器表示潜在空间中的训练示例，而解码器从潜在空间生成布局。文中训练模型构建一个二维的潜在空间，用户可以轻松地探索和生成各种布局。团队通过对生成的布局进行定量和定性评估来展示方法。评估的结果表明，模型能够学习和概括图形布局的抽象概念，而不仅仅是记忆训练示例。总而言之，本文提出了一种全新的图形可视化方法，其中机器学习模型无需手动定义启发式就能从示例中学习将图形可视化</p><div class="note default modern"><p><strong>[I] DeepDrawing: A Deep Learning Approach to Graph Drawing <a href="https://arxiv.org/pdf/1907.11040">[PDF]</a></strong></p></div><p>节点-链接图被广泛用于方便网络探测。然而，在使用图形绘制技术可视化网络时，用户往往需要通过比较相应的绘制结果，迭代地调优不同算法特定的参数，以达到预期的视觉效果，这种尝试和错误的过程通常是冗长和费时的，特别是对于非专业用户来说</p><p>受深度学习技术强大的数据建模和预测能力的启发，文章探索将深度学习技术应用于图形绘制的可能性。具体来说，文中建议使用基于graph-lstm的方法直接将网络结构映射到图形绘图中。以一组布局示例作为训练数据集，训练基于图的lstm模型来获取布局特征。然后，使用训练过的模型为新的网络生成类似风格的图形。文中对两种特殊类型的布局(即网格布局和星型布局)和两种一般类型的布局(即ForceAtlas2和PivotMDS)进行了定性和定量评估，此外，还对20到50个节点的小图形进行了时间成本评估，之后进一步报告了吸取的教训并讨论了局限性和未来的工作</p><div class="note default modern"><p><strong>[I] Interactive Structure-aware Blending of Diverse Edge Bundling Visualizations <a href="http://www.yunhaiwang.net/infoVis2019/EdgeBundling/figsfile/edgebundle.pdf">[PDF]</a></strong></p></div><p>虽然存在许多边缘绑定技术(例如，数据简化以支持数据可视化和决策)，但它们并不直接适用于任何类型的数据集，而且它们的参数往往过于抽象，难以设置。因此，这会妨碍用户创建高效的聚合可视化</p><p>为了解决这些问题，文中研究了一种处理视觉聚合的新方法，即任务驱动和以用户为中心的方法。首先，用户调查不同的边缘捆绑结果，并指定特定的边缘捆绑技术可以提供用户想要的结果的区域，其次，该系统然后计算这些指定区域之间的平滑和结构保持过渡。最后，用户可以进一步微调全局可视化与直接操作技术，以消除局部模糊和应用不同的视觉变形，在本文中提供了详细的设计原理和实现。此外，还展示了与当前的边缘绑定技术相比，本文算法如何给出更合适的结果，最后，提供了具体的使用实例，在这些实例中，算法结合了各种边缘绑定结果，以支持不同的数据探索和可视化</p><div class="note default modern"><p><strong>[I] Persistent Homology Guided Force-Directed Graph Layouts <a href="http://www.sci.utah.edu/~beiwang/publications/PH-GraphDrawing-BeiWang-2019.pdf">[PDF]</a></strong></p></div><p>图通常用于编码实体之间的关系，但是它们的抽象性使它们难以分析。节点链接图在绘制图方面很流行，而强制定向布局为节点安排提供了一种灵活的方法，使用局部关系试图显示图的全局形状。然而，不相关结构的杂乱和重叠会导致图形可视化的混乱</p><p>本文利用无向图的持续同源特征作为导出信息，用于力定向布局的交互操作。首先讨论了如何有效地从带权和不带权的无向图中提取0维持续同源特征。然后介绍用于操作强制定向图形布局的交互式持久性条形码。特别地，用户添加和删除持久同源特征产生的收缩和排斥力，最终选择对布局提升最多的持久同源特征集，最后演示了方法在各种合成和真实数据集中的效用</p><div class="note default modern"><p><strong>[I] Graph Drawing by Stochastic Gradient Descent <a href="https://arxiv.org/pdf/1710.04626">[PDF]</a></strong></p></div><p>一种常用的力定向图绘制方法是使用图论距离作为输入的多维标度。本文提出了一种算法，以最小化其能量函数，称为应力，通过使用随机梯度下降(SGD)移动单一对顶点一次，结果表明，SGD可以比优化更快、更稳定地达到较低的压力水平，而不需要良好的初始化帮助。然后，文中将展示SGD的独特属性如何使它比以前的方法更容易生成受限的布局，还展示了SGD如何直接应用于Ortmann等人的稀疏应力近似中，使算法可扩展到大型图</p><div class="note default modern"><p><strong>[V] The Effect of Edge Bundling and Seriation on Sensemaking of Biclusters in Bipartite Graphs <a href="http://people.cs.vt.edu/ramakris/papers/tvcg-biset-eval-final.pdf">[PDF]</a></strong></p></div><p>探索协调的关系(例如，两组实体之间的共享关系)是各种现实应用中的一项重要分析任务，例如在生物信息学中发现行为相似的基因，在网络安全中检测恶意软件的合谋，以及在市场分析中识别产品捆绑。协调关系可以形式化为双聚体。为了支持双凸体的可视化探索，提出了基于二部图的可视化方法，并利用边缘捆绑来表示双凸体。但是，由于双聚体之间可能存在重叠，存在边缘交叉，并且缺乏对用户在二部图中探索双聚体的影响的深入了解</p><p>为了解决这些问题，本文提出了一种新的基于双聚体的序列化技术来减少绘制二部图中的边交叉，并进行了用户实验来研究边绑定的效果，以及该技术对二部图中双聚体可视化的影响，作者团队发现这两种方法都对减少访问biclusters的用户产生了影响，而边缘包帮助他们找到更合理的答案，此外，团队确定了未来双光泽可视化设计的四个关键权衡。研究结果表明，边缘捆绑对于探索二部图中的双凸体是至关重要的，它有助于减少低级感知问题和支持高级推理</p><hr><h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><div class="note default modern"><p><strong>[S] Accelerated Monte Carlo Rendering of Finite-Time Lyapunov Exponents <a href="https://cgl.ethz.ch/Downloads/Publications/Papers/2019/Ibr19b/Ibr19b.pdf">[PDF]</a></strong></p></div><p>随时间变化的流体流动通常包含大量双曲拉格朗日相干结构，它们作为输运屏障引导平流。有限时间李雅普诺夫指数是定位这些排斥或吸引结构的常用近似。特别是在大型数值模拟中，FTLE脊可以变得任意尖锐和非常复杂。因此，为随后的直接体绘制在网格上的离散采样很可能会在可视化中遗漏尖锐的脊线。为此，最近提出了一种基于蒙特卡罗的无偏置渲染方法，将FTLE场视为单散射参与介质。这种方法构造了一个不离散的地面真值渲染，但是对于单个图像来说，它的渲染时间慢得令人望而生畏。在本文中大大加快了渲染过程，这使得可以在一个更合理的时间框架内计算出高分辨率动画的视频序列，文中采用了两种正交的方法来改善渲染过程:梯度域的体光路径积分和加速透射率估计。作者团队分析了该方法的收敛性和性能，并通过在多个三维矢量场中绘制复杂的FTLE场来验证该方法</p><div class="note default modern"><p><strong>[S] Analysis of the Near-Wall Flow in a Turbine Cascade by Splat Visualization <a href="https://pdfs.semanticscholar.org/bd19/6bc865f588c2b6dbc22bd1f6eb576ad891e7.pdf">[PDF]</a></strong></p></div><p>涡轮机是喷气式飞机和发电厂的重要部件。因此，它们的效率和使用寿命是工程研究的重点。在喷气式飞机或火力发电厂的情况下，由于热气体流的涡轮加热是至关重要的。除了有效的冷却，尽量减少热交换之间的气体流和涡轮的设计是工程师的一个主要目标。由于splat事件对流动和浸入表面之间的换热有重大影响，本文采用splat检测和可视化方法来模拟涡轮叶栅的案例研究</p><p>由于splat事件是小现象，本文使用直接数值模拟解决湍流作为分析基础。结果显示了对splat形成及其与旋涡结构的关系的有希望的见解。这可能会导致未来更好的涡轮设计。</p><div class="note default modern"><p><strong>[S] Extreme-Scale Stochastic Particle Tracing for Uncertain Unsteady Flow Visualization and Analysis <a href="https://www.osti.gov/servlets/purl/1366303">[PDF]</a></strong></p></div><p>本文提出了一个有效的和可扩展的解决方案来估计不确定运输行为，使用随机流图(SFM)用于可视化和分析不确定非定常流，SFM计算是非常昂贵的，因为它需要许多蒙特卡洛运行来跟踪流中的密集种子粒子。本文通过解耦SFMs中的时间依赖关系来减少计算成本，这样就可以独立处理相邻的时间步长，然后在更长的时间内将它们组合在一起。自适应优化还用于减少每个位置的运行次数。然后，团队在任务(粒子包)上并行化，以实现MPI/线程混合编程的高效率。这样的任务模型也支持CPU/GPU的协同处理。团队在两台超级计算机上展示了可扩展性，Mira(最多1M蓝色基因/Q核)和Titan(最多128K)Opteron核心和8K gpu)，可以在数秒内追踪数十亿个粒子</p><div class="note default modern"><p><strong>[S] FlowNet: A Deep Learning Framework for Clustering and Selection of Streamlines and Stream Surfaces <a href="http://www.nd.edu/~cwang11/research/tvcg20-flownet.pdf">[PDF]</a></strong></p></div><p>为了有效地显示流场，识别有代表性的流线或流面是一个重要的研究课题。然而，没有任何工作可以同时解决线和面的问题，本文提出FlowNet，一个单一的深度学习框架聚类和选择流线和流表面。给定流场数据集生成的流线或流面集合，本文方法将它们转换为二进制卷，然后使用一个自动编码器来学习它们各自的潜在特征描述符，这些描述符用于重构二进制量，用于误差估计和网络训练。特征描述符一旦收敛，就能很好地表示潜在空间中的流动线或表面。作者团队对这些特征描述符进行降维，并对投影结果进行聚类。这就产生了一个视觉界面，通过聚类、过滤和选择代表来探索流线或表面的集合。直观的用户交互非常容易地提供了可视化推理的集合。本文从多个角度验证和解释了提出的深度学习框架，使用不同特征的流场数据集演示了FlowNet的有效性，并将方法与最先进的流线和流表面选择算法进行了比较</p><div class="note default modern"><p><strong>[S] Hyper-Objective Vortices <a href="https://pdfs.semanticscholar.org/ef77/73e37c62caf8cd1e0a9f8ead42ae88b36143.pdf">[PDF]</a></strong></p></div><p>向量场的几乎所有性质，包括大小、方向以及涡量都随着观察者的任意运动变化，这是不可取的，因为物理特性的测量在理想情况下不应该依赖于(虚拟)测量设备的移动方式，有一些属性在某些类型的参照系变换下是不变的:伽利略不变性(匀速平移下的不变性)和客观性(任意平稳旋转和参考系平移下的不变性)。在本文中，引入了比客观性更困难的条件:要求任何平滑相似变换都具有不变性(旋转、平移和均匀标度)以及在参考系的任何光滑仿射变换下的不变性。文中表明，这些新的超客观措施允许提取旋涡，改变其体积或变形。此外，本文提出了一种通用的方法，可以将几乎所有的涡流测量转换为超目标测量。团队将方法应用于二维和三维矢量场的涡旋提取，并分析了伽利不变量、目标和两种新的超目标方法的数值鲁棒性、提取时间和最小残差</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMAP：安全多方联合降维可视化方案</title>
      <link href="2020/10/20/SMAP/"/>
      <url>2020/10/20/SMAP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>IEEE引用格式：J. Xia et al., “SMAP: A Joint Dimensionality Reduction Scheme for Secure Multi-Party Visualization,” 2020, [Online]. Available: <a href="http://arxiv.org/abs/2007.15591">http://arxiv.org/abs/2007.15591</a>.</p></blockquote><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>在多方数据被融合到一个站点来建立点集关系时，传统的可视分析方法(如降维)可能会暴露数据隐私，可视分析中的数据隐私是一个重要的需求，比如几个医院想要执行其病人数据的联合分析，同时保持他们的数据隐私</p><p>应用可视化技术帮助人们理解多方高维数据的时候，通常会采用降维技术，比如主成分分析(PCA)，多维尺度(MDS)，t-SNE，将所有的数据点投影到一个公共空间，然而降维技术首先就会破坏数据的隐私性，比如<strong>传统的降维方法是为单站点计算设计的</strong>，需要从所有站点收集原始数据来创建联合嵌入，如果在多方数据之前简单地匿名化数据又会减少数据的效用，导致不准确的布局，而且匿名的数据也有被保护的必要。其次当其他人采用可视化设计来检查隐私敏感数据时，数据隐私也会受到威胁</p><p>基于此，文章提出了一种安全的多方可视化联合降维方法，允许在可视化生成和可视化消费两个阶段保护隐私数据，首先开发了一个安全的t-SNE嵌入多方计算方案，对t-SNE的重设计中核心的挑战就是原始数据和数据点中间的距离矩阵都可能威胁到数据的隐私，这些都不应该暴露给参与者，其次建立了一个在线可视化系统SMAP，支持隐私感知的嵌入结果探索</p><p>总的来说，文章的贡献分为两个部分：</p><ol><li>一种安全的联合t-SNE多方降维方案</li><li>一个在线可视化系统，以支持隐私保护的探索和在线任务组织</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="安全感知的分布式机器学习和数据挖掘"><a href="#安全感知的分布式机器学习和数据挖掘" class="headerlink" title="安全感知的分布式机器学习和数据挖掘"></a>安全感知的分布式机器学习和数据挖掘</h3><p>在机器学习和数据挖掘领域，解决原始数据分布在多个参与者中的安全问题的一个常见方法是差异隐私理论，采用随机机制更改原始的输入数据并且保持数据的实用性，常用的随机扰动有高斯噪声和拉普拉斯噪声，显然噪声越多越能保护隐私但同时解释结果的偏差也越大，在以往的研究中，并没有能做到降维的同时保持距离矩阵不暴露</p><h3 id="可视化中的隐私保护"><a href="#可视化中的隐私保护" class="headerlink" title="可视化中的隐私保护"></a>可视化中的隐私保护</h3><p>与数据挖掘对应方法类似，可视化领域的隐私保护针对两种主要风险类型：身份披露(个人身份被链接到特定数据)和属性披露(敏感的属性)，一个常见的解决策略是在敏感信息的显示中应用视觉不确定性(比如模糊效果或者聚合集群)</p><p>本文的方法旨在将数据嵌入低维空间，在低维空间中身份和属性的暴露可以自然地被消除，而集群或异常可以被保留，若点级别关系是高度敏感的，则可以使用聚合可视化来隐藏点级别信息</p><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>降维指将高维数据投影到低维空间，同时保留特定的属性，比如主成分分析(PCA)保留了数据点之间的方差，线性判别分析(LDA)试图保持簇之间的可分离性，t距离随机邻点嵌入(t-SNE)和多维标度(MDS)则保护基于距离矩阵的数据点之间的相似性</p><p>降维意味着数据的压缩，因此在很多应用中被用于保护数据的隐私，这些研究和本文的区别是，他们是利用降维来解决隐私问题，降维在单地点进行，但是本文的目标是在多方降维的过程中防止其他参与者的数据暴露</p><h2 id="场景，需求与方法概述"><a href="#场景，需求与方法概述" class="headerlink" title="场景，需求与方法概述"></a>场景，需求与方法概述</h2><h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h3><p><strong>多方数据分析</strong></p><p>在该场景中，参与者希望在全局数据的上下文中分析本地数据，同时对彼此保持数据的私密性，比如多个社区医院的分析人员希望探索社区之间的差异，识别异常患者，然而因为隐私保护原因他们不能融合他们的数据。通过安全的联合嵌入，可以将局部数据点投影到共享空间中，在共享空间中可以可视化分析所有数据点之间的相似性</p><p><strong>数据采购</strong></p><p>在数据驱动的应用程序中，用户往往需要购买丰富的数据，通过数据市场训练自己的机器学习模型，出于成本考虑，必须仔细选择合适的数据集，比如覆盖失败样本或者支持少数的数据集，然而这些信息在购买数据集之前是未知的，安全多方可视化为用户提供了一种工具，可以在不影响数据隐私的情况下，将本地数据与销售数据进行比较。这种信息透明性有助于用户做出购买决策</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>R1：在多方可视化中保留隐私</strong></p><p>考虑到所有参与者对数据都很好奇，应该保证在整个过程中所有参与者都不能获得或推断出原始数据</p><p><strong>R2：在可视化过程中保护隐私</strong></p><p>在散点图中，每个参与者应该只允许探索全局数据点的低维表示，而不是高维表示</p><p><strong>R3：支持隐私感知可视化结果的交互式探索</strong></p><p>参与者只能通过局部数据和相似度来推断高维信息</p><p><strong>R4：支持在多个参与者之间组织在线联合嵌入任务</strong></p><p>除了联合嵌入算法外，还需要一个连接不同站点参与者的在线系统，在真实环境中设置框架</p><h3 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h3><p>基于上述需求，本文提出了一种联合t-SNE方案，开发了一个安全多方可视化的在线可视化系统</p><p>首先，提出了一种安全的多方联合t-SNE协议，旨在保护数据隐私，只有<strong>加密的和有噪音的数据</strong>被传送给两个外部合作者，其次，设计了一个在线可视化系统，该系统支持隐私保护可视化，此外，在线系统连接来自不同站点的参与者，组织在线联合嵌入任务</p><h2 id="安全多方投影"><a href="#安全多方投影" class="headerlink" title="安全多方投影"></a>安全多方投影</h2><h3 id="t-SNE算法"><a href="#t-SNE算法" class="headerlink" title="t-SNE算法"></a>t-SNE算法</h3><p>在高维空间中，两个数据点$x_i$和$x_j$之间的相似性用对称概率$p_{ij}$表示，即$x_i$是$x_j$的邻居的概率，$p_{ij}$表示为</p><p>$p_{ij}=\frac{(p_{j|i}+p_{i|j})}{2N}$</p><p>其中N是点的数量，条件概率$p_{j|i}$的计算方法为</p><p>$p_{j|i}=\frac{\exp(-||x_i-x_j||^2/2\sigma_i^2)}{\sum_{k\neq l}\exp(-||x_i-x_k||^2/2\sigma_i^2)}$</p><p>在低维空间中，t-SNE采用了一个单自由度的t分布来描述分布，表示$y_i$点和$y_j$点相似性的联合概率$q_{ij}$被定义为</p><p>$q_{ij}=\frac{(1+||y_i-y_j||^2)^{-1}}{\sum_{k \neq l}(1+||y_k-y_l||^2)^{-1}}$</p><p>$y_i$和$y_j$是$x_i$和$x_j$的嵌入</p><p>t-SNE算法通过最小化高维空间和低维空间概率分布之间的KL散度来优化嵌入。KL散度表示为</p><p>$C=KL(P||Q)=\sum_i\sum_jp_{ij}log\frac{p_{ij}}{q_{ij}}$</p><h3 id="联合t-SNE的安全多方协议"><a href="#联合t-SNE的安全多方协议" class="headerlink" title="联合t-SNE的安全多方协议"></a>联合t-SNE的安全多方协议</h3><p>通过对t-SNE算法的回顾，可以知道其中关键的一步是计算高维空间中的条件概率$p_{j|i}$，而其计算依赖于高维空间中成对距离的计算，这是将传统降维方法转化为安全的多参与者版本的一个障碍，因为成对距离矩阵不能暴露给任何的参与者，因此$p_{j|i}$的计算必须重新设计</p><p>为了解决这个问题，文章中提出了一个安全的多方协议t-SNE，除了数据的拥有这，还引入了两个协作者S和T来提供计算服务，体系结构如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-1.png"></p><p>T只加密没有私钥的数据，而S只加密有噪声的数据。S和T相互协作计算t-SNE布局，并将结果分发给参与者。在假设这两个协作者不会相互串通的情况下，数据隐私得到保护</p><p>协议的过程如下图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-2.png"></p><p>协议中采用的符号说明见下表</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-3.png"></p><p><strong>Step1：密钥的生成与传播</strong></p><p>S生成用于数据加密的公钥PK和用于数据解密的私钥SK，S广播PK到T和所有的P，在协议中，使用加性同态加密进行数据加密，在加性同态加密(AHE)下，保留了加法和标量乘法，有SK(PK(a) ◦ PK(b)) = a + b，SK(PK(a) ⋄ PK(b)) = a − b，以及SK(a ⋆ PK(b)) = a ∗ b，PK()和SK()指用公钥和私钥加密，◦，⋄和⋆表示加密数据的加法减法和标量乘法</p><p><strong>Step2：加密数据收集</strong></p><p>每个参与者P将本地数据X加密的数据PK(X)发送到T</p><p><strong>Step3：加密数据加入噪声</strong></p><p>给定来自所有参与方的数据X，T给加密数据的每个条目添加一个随机的噪声</p><p>$PK(\bar{x_{ij}})=PK(x_{ij})◦PK(\sigma_{ij})$</p><p>$\sigma_{ij}$是一个随机的噪声，然后T将噪声加密数据发送给S</p><p><strong>Step4：噪声距离计算</strong></p><p>首先协作者S用$SK(PK(\bar{x_{ij}}))=x_{ij}+\sigma_{ij}$来解密数据，然后噪声欧几里得距离可以通过如下公式计算</p><p>$z_{ij}=\sum_{k=1}^m((x_{ik}+\sigma_{ik})-(x_{jk}+\sigma_{jk}))^2$</p><p>m是数据点的维度</p><p>接着S将噪声距离矩阵加密为PK(Z)并发送给T，Z是加密噪声距离矩阵</p><p><strong>Step5: 加密的距离计算</strong></p><p>在这个步骤中，协作者T计算加密的精确距离矩阵D</p><p>对$\sigma_{ik}-\sigma_{jk}$替换为$\delta_{ijk}$，可以将上式转化为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-4.png"></p><p>将$x_i$和$x_j$之间的距离记为$d_{ij}$，可以进一步将式子转化为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-5.png"></p><p>加密的平方距离$PK(d_{ij}^2)$可以被计算为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-6.png"></p><p><strong>Step 6：在加密距离中加入噪声项</strong></p><p>在此步骤中，协作者T在加密距离矩阵PK(D)中加入了噪声并将其发送给S</p><p><strong>Step 7：对称概率计算</strong></p><p>这一步中，S计算高维空间中的对称概率</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-7.png"></p><p><strong>Step 8：t-SNE嵌入</strong></p><p>T将矩阵恢复顺序后用KL散度优化式计算t-SNE</p><h3 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h3><p><strong>安全性</strong></p><p>在整个过程中有两个隐私敏感数据项：原始数据和距离矩阵，有了全距离矩阵，人们可以很容易地恢复原始数据，因此需要保证没有任何参与者可以得到两个数据项中的任何一个</p><p>首先对于参与者P，其只有自己的局部数据和分布的嵌入结果，从t-SNE嵌入恢复精确的成对距离是非常不切实际的</p><p>协作者S有公钥PK，私钥SK，以及噪声加密数据和重排列的距离矩阵，因为噪声仅T执有，所以S既不能恢复原始数据，也不能恢复距离矩阵</p><p>T只有加密的数据和加密的距离矩阵，没有私钥无法恢复成对隐私敏感的数据项</p><p>所以总的来说协议可以保证数据的安全性</p><p><strong>准确性</strong></p><p>嵌入结果与标准的t-SNE算法完全一致</p><h2 id="SMAP系统"><a href="#SMAP系统" class="headerlink" title="SMAP系统"></a>SMAP系统</h2><h3 id="架构与实现"><a href="#架构与实现" class="headerlink" title="架构与实现"></a>架构与实现</h3><p>S和T属于两个不同的没有共谋的信誉实体，由服务器组织，S和T彼此连接，并发送加密或噪声数据给对方。参与者按照安全多方协议连接到两个协作者。S向它们广播公钥。它们将加密的数据发送给T，并从T接收可视化结果。在每个参与者中都安装了一个客户端交互界面，用于任务管理和可视化结果的探索。</p><p>SMAP是一个基于web的系统，前端用JavaScript和D3.js实现，后端用python实现，采用基于python的库来进行部分同态加密，并开发了一个多线程实现</p><h3 id="参与者用户界面"><a href="#参与者用户界面" class="headerlink" title="参与者用户界面"></a>参与者用户界面</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SMAP-8.png"></p><p>如图所示，在任务列表面板(a)中，参与者可以浏览在线任务，加入一个准备任务，并提出一个新的任务，在列表中选择一个任务之后，任务描述面板(b)显示任务信息，，例如数据的内容和参与者，对于参与的任务，参与者可以直接切换到”我参与的任务”选项卡，其中显示了所有协作者和参与者的详细信息，包括他们的角色，IP地址，状态和贡献的数据点，此面板还支持任务操作，包括数据加密和上传</p><p>全局投影试图(c)显示了来自所有参与者的数据的嵌入结果，在单个投影试图(d)中，根据全局嵌入，只显示所选参与者的数据，为了满足隐私保护的需求，本文提供了两种可视化策略，当参与者想知道点集关系的时候，结果会议散点图的形式呈现，其中颜色编码了数据所有权或者数据类，在散点图模式下，参与者可以自由活动，由于参与者只能访问原始的本地数据，只能通过选择附近的本地数据来推断他人数据的高维表示。当参与者涉及到点级隐私性的时候，聚合的可视化被提供来显示联合嵌入结果</p><h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2><p>三个案例</p><ol><li>模拟了一个数据市场场景，其中数据消费者(M)购买数据来改进他自己的小数据集，邀请了一个机器学习专家来作为消费者M，每个零售商提供3000个数据点，消费者只有1000个数据点(专家操作过程和建议详见论文)</li><li>分散学习场景，解决non-IID issue，五个包含800个数据点的不同子集分别被分配给五个具有机器学习研究背景的硕士研究生</li><li>将SMAP部署到三个社区医院，以进行安全的多方可视化分析，为了防止两个协作者之间的共谋，作者团队作为协作者T来保存加密的数据。合作伙伴由一家外部公司服务，该公司受到所有医院的信任</li></ol><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ol><li><p>本文的协议可以直接支持PCA，因为它只需要计算协方差矩阵而不是距离矩阵，其敏感信息更少，而应用于UMAP和isomap可能会面临一些挑战，因为这两种方法必须计算k个最近邻之间的距离，这是距离矩阵的子集，无法在Step7进行分数约简来保护距离矩阵，需要更多研究来评估这个子集的风险</p></li><li><p>在不同的场景中组织安全的协同视觉分析将是一项有趣的未来工作</p></li><li><p>安全多方可视化方案耗时较长，关键部分是数据加密、解密和对加密数据的算术运算</p></li><li><p>点数增加，散点图中不可避免地会出现重叠，影响了基于散点图的嵌入结果分析，入识别离群值等，文章中的处理方法是以随机顺序呈现数据点，未来可以采取更多的解决方案，比如可以透明底呈现数据点，也可以采用离群值检测算法来检测并突出检测到的离群值</p></li></ol><h2 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h2><ol><li>加速安全的多方预测</li><li>通过联合嵌入实现的安全协作分析</li><li>其它数据类型的安全多方可视化</li></ol>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> VIS </tag>
            
            <tag> 数据降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的算法竞赛入门教程：基础语法与函数思想</title>
      <link href="2020/10/19/Re0-1/"/>
      <url>2020/10/19/Re0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>针对没有任何编程经验的同学写一份C++的教程是十分困难的，因为C++光是语法部分就能填充一本如同字典一般厚的书，而在算法竞赛中，我们仅仅是选择学习一些需要用到的，足以完成问题求解即可</p><p>学习程序语言和学习语言的过程是类似的，可以通过反复地模仿来熟悉，不断地尝试来积累，然后慢慢地能够做到自我创造，所以呢，不要踌躇不前，不要觉得难以下手，去模仿，去写去尝试</p><p>本教程基于USACO Training，结合题目内容讲解，随缘更新，如果对零基础的同学能够起到一些帮助，那就再好不过了</p><p>由于知识的诅咒，我可能已经很难明白初学者可能会遇到什么问题了，如果感觉写的某些东西晦涩难懂，欢迎与我交流，但是最好，你可以善用搜索引擎和手头的工具书来自行找到解决问题的方法</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>[Your Ride Is Here]</p><p>将两个字符串按照规则转化成数字，判断是否相等</p><p>规则：A-Z对应1-26，将串中每个字母转化成数字，相乘后对47取模</p><figure class="highlight plain"><figcaption><span>INPUT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMETQ</span><br><span class="line">HVNGAT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>OUTPUT</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h2><p>首先写下头文件和命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span></span><br></pre></td></tr></table></figure><p>这是在算法竞赛中非常常用的一个头文件，里面包含了相当多的库函数，std命名空间是C++标准为了不与原来的头文件(C)混淆而建立的，当然你也可以建立自己的命名空间，引入std是为了std名字空间的东西全部暴露到全局域中</p><p>比如原来想使用cout，要写成std::cout</p><p>在暴露到全局域中之后直接写cout就可以了</p><h3 id="数组与变量"><a href="#数组与变量" class="headerlink" title="数组与变量"></a>数组与变量</h3><p>在程序中变量的作用就是承载值，比如你需要保存一个值，读入一个值，或是对某个值做反复的计算，那就需要用到变量了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> y = (x + <span class="number">5</span>) * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>比如上述代码就是定义了一个变量x为3，然后用x去计算变量y，y用于承载式子的计算结果</p><p>int是数值型变量，字符型变量则需要用char，更多的类型大家可以在使用中自行查阅资料</p><p>而数组呢，就是变量的一个有序集合，比如说，我想要计算一个数列，并且保存下每个数列中的元素，那我就需要使用数组了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>上述代码定义了一个长度为10的数组a，在c++中，数组是0-base的，也就是说定义的a[10]，包含了0到9为下标的10个变量，我们只要在方括号里写入下标，就可以使用对应的变量</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">a[<span class="number">3</span>] = a[<span class="number">1</span>] * <span class="number">3</span> + a[<span class="number">2</span>] * a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在题目中通常会有一些固定的值，比如这道题中的模数47，我们通常用const常量来表示这些值，使得自己的代码更具有可读性，也防止了常量变大(比如999999997)导致的在反复使用中产生的抄写错误</p><p>题目中用到的数组，一般也是用<strong>略大于数值上限的</strong>常量来定义大小</p><p>而这道题中我们需要用到的就是数组的长度L和模数mod</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">47</span>;</span><br></pre></td></tr></table></figure><p>对于题目描述的两个字符串，我们可以用字符数组来定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> team[L], comet[L];</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环可以看成是相似行为的有序处理队列，比方说，你想要计算一个数列$a_n=a_{n-1}+a_{n-2}$，难道说得一个一个来计算么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] = a[<span class="number">2</span>] + a[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">4</span>] = a[<span class="number">3</span>] + a[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">5</span>] = a[<span class="number">4</span>] + a[<span class="number">3</span>];</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>求a[100]，a[1000]简直不敢想</p><p>循环呢，就是通过一个下标变量的变化来表示重复过程的计算</p><p>比如要计算a[100]，可以这么实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">100</span>; i++) </span><br><span class="line">    a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><p>for是循环的一种实现方式，更多的循环方式比如while，do-while大家可以自行去了解</p><p>for循环用分号隔开的三个位置起到的是不同的作用，均可以为空，第一个位置在循环的开始前执行，可以定义，也可以计算，第二个位置在循环的每轮计算进入前进行判断，满足条件则进入循环，否则结束循环，而第三个位置，则在循环的每轮计算结束后执行</p><p>当然循环也可以强制结束，比如我算到大于100的数列值就不继续算了，那就用break语句来结束循环(示例下面会有)</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>条件判断其实很好解释，就是如果(if)，如果今天下雨，那么我要带上雨伞，否则，不带，那么程序如何实现这样的逻辑呢，答案就是条件判断</p><p>那么来看一下如何实现之前提到的，算到大于100的数列值就不继续算的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">100</span>; i++) &#123; </span><br><span class="line">    a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先代码中我用大括号将两句话括在了一起，这样的操作在C++中表示它们同属于这个循环(或者说属于某个过程)，如果不加大括号，那么循环就只能执行一句话</p><p>那如何用条件判断来处理比较复杂的分类呢，比如60分及以上且75以下给及格，75及以上且85以下给良，85及以上给优，那就要用if else了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">60</span>)&#123;</span><br><span class="line">    给不及格</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">75</span>)&#123;</span><br><span class="line">    给及格</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">85</span>)&#123;</span><br><span class="line">    给良</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    给优</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>else表示将之前的判断排除在外的剩余部分，可以嵌套</p><p>好了，我们现在有了以上的工具，就可以来看看能在这道题目中做些什么事情</p><p>第一步，要将字符串计算为对应的数字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s), sVal = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) </span><br><span class="line">    sVal = sVal * (s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) % mod;</span><br></pre></td></tr></table></figure><p>首先我们用字符数组的strlen函数(库函数)来计算其长度sLen，定义一个初始变量sVal来表示最后计算的结果，然后用一个循环来遍历字符串中所有的字母，计算其对应的数字并乘到sVal上</p><p>我们对两个字符串分别算出对应的值，比较结果就可以完成题目的要求</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>最后我们来讲一下函数，这是程序设计中一个非常重要的内容，函数的目的是，让程序不重复做同一件事，让程序更模块化，同时也使得程序能够递归(之后遇到再讲)</p><p>比如说，对于两个字符串，转化为值，我们做的操作其实是一样的，只是换了变量名而已，所以我们就可以将这个过程定义为一个函数</p><p>格式如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s), sVal = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) </span><br><span class="line">        sVal = sVal * (s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> sVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的本质是将输入映射到输出，这里我们希望输入一个字符串，输出其对应的值，可以看出这个函数返回值是int，写在cal前面，如果函数不需要返回值，只是希望对某些变量做一些事情，则可以将返回值设为空void</p><p>在C++中，我们首先需要一个主函数main，表示程序的入口，除此之外可以自己建立函数来合并重复功能或者使得代码更有逻辑性</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的长度设置最好略大于上限</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">47</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> team[L], comet[L];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串对应的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s), sVal = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) </span><br><span class="line">        sVal = sVal * (s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="comment">// 函数返回值</span></span><br><span class="line">    <span class="keyword">return</span> sVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符数组读入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, team, comet);</span><br><span class="line">    <span class="comment">// 三目表达式，自行查阅资料</span></span><br><span class="line">    <span class="built_in">puts</span>(cal(team) == cal(comet) ? <span class="string">&quot;GO&quot;</span> : <span class="string">&quot;STAY&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success modern"><p>Accept</p></div><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>Q1：好像很多内容没写清楚，太过简单了</p><p>A1：确实是这样，面面俱到的工程量太大了，入门的语法光看这篇文章一定是不够的，除了辅以语法书之外，可能还要多去完成类似的题目，多练多查才会快速熟悉起来，我只是扔了一块砖，希望你们可以自己去发现玉石</p><p>Q2：这题写的过复杂了，直接在主函数里计算，判断一下输出似乎就可以完成了</p><p>A2：主要是想强调一下函数这个内容，对于重复要做的事情，将其函数化，可能在短的程序里面体现不出什么优势，但是当要实现的内容增多，且存在大量复用时，这样的习惯会让你写出易读易调试的代码</p>]]></content>
      
      
      <categories>
          
          <category> 🍭算法幼儿园 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>散点图缩放所产生的偏见</title>
      <link href="2020/09/29/GeometricScaling/"/>
      <url>2020/09/29/GeometricScaling/</url>
      
        <content type="html"><![CDATA[<blockquote><p>IEEE引用格式：Y. Wei et al., “Evaluating perceptual bias during geometric scaling of scatterplots,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 1, pp. 321–331, 2020, doi: 10.1109/TVCG.2019.2934208.</p></blockquote><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>在现代数据分析场景中，散点图经常被缩放以适应不同的显示，同时在不同显式设备上共享散点图是协作数据分析交流中的一种常规操作</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GeometricScaling-1.png"></p><p>缩放散点图最直接的方法几何缩放(同步和比例地放大或缩小整个图以及其中的对象)。几何变化会导致视觉感知偏见，从而影响数据特征的感知一致性(数量、相关性和聚类)，不利于交互式数据探索，如上图所示，在讲述者的散点图中有两个簇，然而显示在移动设备上的时候，这是无法区分的，在下图中，左右两个方框内具有相同数量的点，但是人们总会认为右边方框中的点是更多的，此外，心理学研究证明，当patch的大小增加时，patch的点被认为是稀疏的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GeometricScaling-2.png"></p><p>已有的研究考虑了散点图的设计决策(点颜色，宽高比和动画)，和散点图在移动设备，高分辨率显示和浸入式环境中的使用问题，然而散点图尺度并没有得到系统的研究</p><p>为了弥补这一研究空白，作者团队进行了对照实验来研究这种偏见。具体来说，偏见是指视觉特征的感知值与物理值之间的偏差。文章强调了三个视觉特征(即:数量、相关性和聚类分离，如图所示)，并提出了三个假设：几何尺度可能导致偏见；数据分布会影响偏见；而改变点的半径可以减少偏见</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GeometricScaling-3.png"></p><p>实验采用两间隔强迫选择(2IFC)方法和双向阶梯(2WS)设计来模拟散点图缩放场景，并收集参与者根据主观经验比较一系列原始和缩放散点图对的选择模式。选取7个层次的尺度比和点半径，利用精心准备的合成数据生成13个层次的视觉特征，2个分布(正态分布和均匀分布)的散点图。在几次初步研究确定实验后，招募了20名参与者并进行了3轮试验，每一轮由准备、介绍与辅导、预实验、正式实验、主观问卷组成</p><p>作者记录了被试的选择模式和主观问题回答作为实验结果并进行了主观平等点(PSE)分析，从这些选择模式中得出定量偏见，并对这些偏见进行了一系列统计分析。分析结果表明，第一个假设得到了充分的肯定，第二个假设得到了充分的否定，第三个假设得到了部分的肯定。作者还从主观问卷调查中得到了其他有趣的发现，并系统地总结了这些成果</p><p>本文首次尝试理解由几何尺度引起的散点图的感知偏差，贡献了一个精心设计的评估和一系列有益的发现</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>视觉感知根据认知复杂性，可以分为三个层次，从直接的视觉刺激(如位子，颜色和密度/数量)中获得的低级感知被称为注意力前处理(preattentive processing)，中层感知是从刺激模式中获得的理解，如相关性和聚类分离，更高层次的感知，如记忆性、美学和参与性是建立在理解基础上的用户认知，在这项工作中，研究了散点图缩放对感知视觉特征的影响。主要研究了一个低级的(数值，在视觉分析的大多数场景中被视为密度)和两个中级的(相关性和聚类分离)视觉特征</p><p>许多作品研究了散点图视觉编码的设计评价和自动决策，设计评价研究了特定场景中散点图的视觉编码，并在许多方面提供了经验指导，如点的大小和颜色，高宽比，维度的选择，娱乐，互动和动画，质量度量，例如杂乱减少和集群检测，度量图表执行某些分析任务的能力。然而，现有的研究主要集中在散点图固定不变时的设计决策，而本文感兴趣的是改变显示尺寸的情况</p><p>随着显示设备的发展，对分析不同显示器上的数据的要求越来越高，而不仅仅是桌面显示器。研究人员已经注意到显示尺寸强烈影响散点图的可用性。他们研究了显示尺寸对散点图设计决策的影响，如手机上的交互作用、大分辨率显示的认知过程，以及沉浸式环境下的图形布局，此外，显示技术的进步为探索性分析提供了新的场景。一方面，大型显示器允许同时显示许多图表，从而形成多视图接口。另一方面，由于空间感知和无线连接技术的应用，多设备组合越来越多地用于提供涉及多人的协作数据分析。这些新场景导致了散点图的频繁缩放。然而，很少有研究研究散点图尺度的影响，在这项工作中，目标是寻找可能的解决方案，以减轻散点图缩放对视觉一致性的影响</p><p>感知偏见是一个被广泛研究的重要问题，它考虑了场景之间的感知差异，包括三种情况：1.感知到的视觉特征与定量统计的差异；2.个体间感知的差异；3.不同设计中感知到的视觉差异，已有的研究中还没有系统地评估散点图缩放所引起的感知偏见</p><h2 id="问题和假设"><a href="#问题和假设" class="headerlink" title="问题和假设"></a>问题和假设</h2><p>如前文所提到的，为了保持显示的感知一致性，最直接的方法就是采用几何缩放，但是作者的基本观察是几何缩放会导致感知偏见，这种偏见会影响感知一致性</p><pre><code>当事实的信念偏离现实时，就会产生知觉偏见 —— Jerit</code></pre><p>根据经验，当散点图被缩放时，人们经常会误配视觉特征的感知值和实际值(当笔记本电脑上的散点图投射到窗帘上的时候，人们可能会觉得放大后的散点图有更少的点)，因此作者产生的想法是几何尺度会导致感知偏见，此外，作者对影响偏见的因素感兴趣(是否涉及某种规则，能否找到减少偏见的方法)，在这项工作中的，团队进行了对照试验来探究这些问题，为了指导实验设计，提出了如下假设：</p><ol><li><p>假设几何尺度会导致散点图中感知到的视觉特征出现偏差，包括数量、相关性和聚类分离，并且偏差和尺度比存在线性关系</p></li><li><p>假设几何尺度引起的偏见会受到数据分布的影响</p></li><li><p>假设改变点的半径可以减少偏见</p></li></ol><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p>实验中的外部刺激是2D散点图的视觉编码和渲染选项，作者将所有散点图的纵横比设为1来消除纵横比造成的干扰，所有的散点图都用灰色背景和黑色细边界来渲染，将所有散点图的x和y维域归一化为[0,1]，散点图中的点用黑色的圆圈表示(唯一例外是两种颜色的圆圈表示两个聚类)，散点图中的半径是相同的，当散点图被缩放时，视觉编码，包括散点图的宽度和高度，轴的长度和点的半径，都按比例缩放</p><p>作者采用带有双向楼梯设计(2WS)的双间隔强迫选择方法(two-interval forced choice，2IFC)来模拟散点图缩放场景，并测量人们的主观体验</p><p>2IFC是一种通过一个人的选择模式来衡量其主观体验的方法，在2IFC试验中，受试者被要求在参考刺激和测试刺激对之间做出判断。判断是一种主观比较，以获得视觉特征值较大的刺激，每种视觉特征和尺度比的组合，在2IFC任务中都需要进行一系列的试验</p><p>合理的2IFC序列的构建涉及两个重要的考虑因素。(1)检测视觉特征的等级必须覆盖一个合适的范围。太少的水平会使偏差测量不够精确，太多的水平会导致过多的试验。(2)在一系列试验中，特征层次出现的顺序必须精心设计。一个随机序列需要许多试验来获得一个准确的偏差，而参与者可以找到规律性水平排序</p><p>作者使用2WS设计来确定特征级别的出现顺序。楼梯式设计是指，测试散点图的特征水平不同，使得下一次试验困难或简单，参考散点图保持在基线水平。顺序可以从- 6层(前梯)或+6层(后梯)开始;两者都位于基线附近，因此形成了一个双向楼梯</p><p>图中展示了一个参与者在2WS序列中的实验结果。在前梯或后梯中，由于参考散点图和测试散点图的特征水平非常接近，使得判断变得困难，所以在多次单调变化(箭头)后，试验在基线(高亮区域)附近的一定间隔内波动</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GeometricScaling-4.png"></p><p>这种波动的选择模式正是2IFC &amp; 2WS方法的目的，通过这种方法，可以使用PSE来测量参与者的主观体验，从而得出偏差，每个方向的试验次数设置为15次，共30次。该次数大于特征级别数的两倍，从而保证了波动模式的发生</p><p>E1用于测量几何尺度对散点图的三个视觉特征:数量、相关和聚类分离所造成的感知偏差。E1的变量包括scale ratio、feature、feature level。对于每种尺度比和fea- ture组合，每个参与者被要求完成30个试验的2IFC和2WS序列，从而获得偏倚测量的选择模式。每个参与者对应7个尺度比，完成7个序列，共210次试验，检测尺度比变化时的变化趋势，三个特征一共630次试验，所有点的位置被限制在一个以(0.5,0.5)为中心，0.5为半径的约束圆内。如果任何点超过了这个约束圆，那么这个点被删除并重新生成。因此，点云在散点图中心呈正态分布，且分布范围适中，重叠极小</p><p>E2关注的是数据分布的影响，因此它与E1共享相同的变量设置，其数据生成与大多数设置中的E1相似。不同的是点集是从均匀分布中采样的。注意，对于E2中的相关检验，作者构造了一个约束椭圆，然后从椭圆内的均匀分布中采样。约束椭圆的中心点为(0.5,0.5)，主轴沿散射图的对角线方向从左下到右上，主轴的长度被设置为1，而副轴的长度是一个随机数。因此，作者生成几个候选点集并计算它们的相关系数。随后选择了满足各层次值要求且误差小于0.005的候选值</p><p>E3旨在研究改变点半径对感知视觉特征的影响。研究了三个变量:点半径、特征和特征水平，E3中使用的数据与E1中相同。唯一的区别是这些点是用不同的半径渲染的</p><p>考虑到实验任务耗时且视觉吃力，团队招募了20名参与者，使用有散点图进行数据分析经验的非应届毕业生和研究生，年龄19-25岁，中位年龄21岁，而非使用亚马逊的土耳其机器人，这样可以观察被试的心理状态，控制实验过程，此外，提供了一个独立安静的实验室，最小的外部干扰，我们要求参与者在实验前至少早睡三天，这样他们就能得到充分的休息和充分的体力。团队还准备了咖啡和零食，帮助参与者在休息时放松。完成这项研究的参与者每小时得到6美元的报酬</p><p>团队邀请了5名参与者进行了3次试点研究。这些研究有助于确定实验设计的细节。在试点研究中，作者发现2IFC判断的稳定性在白天比在晚上要高得多。这表明，人的精神和实验环境对2IFC判断的形成有很大的影响。因此，本文在白天安排了所有的实验</p><p>为了确定实验顺序，首先遵循E1、E2和E3的顺序。每个实验都包含这三个特征。注意到，在一次实验中，参与者不得不重新关注不同的特征。因此，团队在第二个试验中使用了以特性为主的顺序。在E1 - E3的一轮测试中，只有一个特征被测试以保持参与者思维模式的连续性，此外，作者反复调整数据生成参数(如特征值范围和间隔)，界面和程序(如增加练习试验和预试验阶段，调整休息时间跨度)</p><p>作者为正式研究设计了一个三轮的实验过程。这三轮的核心变量是视觉特征。即每个参与者在一轮中完成一个特征的三个实验(E1, E2, E3)，并通过三轮完成所有特征(numerosity, correlation, cluster separation)。每一轮有四个实验阶段</p><p>准备阶段：实验指导老师首先带领参与者进入实验室，然后帮助参与者调整显示器的位置和高度，确保屏幕中央的点与眼睛平齐</p><p>介绍阶段：这个阶段让参与者熟悉实验过程、任务、视觉特征和数据。这个阶段通常需要大约10分钟</p><p>预备实验：在完成教程之后，参与者需要为当前要测试的特性执行一个简单的预实验来确定参与者是否充分准备好了</p><p>正式实验：参与者点击“开始”按钮开始进行个人判断。在完成一个实验的所有试验后，参与者休息2 - 3分钟，然后继续进行下一个实验</p><p>在完成了一轮实验后，参与者被要求填写一份问卷来收集他们对当前被检查的视觉特征的主观感受。问卷设置了两类问题：第一类询问的是对做2IFC判断的整体难度水平(DL)的主观感受。例如，”散点图大小的变化是否会使你难以判断正态分布的数值?”如果是的话，那么有多难呢?参与者使用李克特五分制对它进行评分，从1(最低难度)到5(最高难度)不等，第二类是询问在不同的标度比或点半径下进行2IFC判断的困难倾向(DT)的主观体验。例如，”随着散点图大小从小到大的变化，对正态分布数值的感知做出判断的难度是如何变化的?”</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>从实验中收集所有客观和主观的结果。客观结果记录了参与每个2IFC试验的参与者的信息，包括选择、参考散点图的位置、实验变量和完成时间。主观结果从问卷中提取，包括24个问题和对每位参与者的访谈记录。以下主要从以下三个方面对结果进行分析</p><p>—— 异常选择模式识别</p><p>一些参与者在2IFC判断的几个小时内会偶尔分心，导致在一系列试验中出现异常的选择模式，作者进行了方差分析来识别剧烈波动的选择模式，计算一个序列的10个基本实验的特征水平的方差，一个大的差异同行表明出现剧烈波动的选择模式，这是基于十点研究中参与者的反馈得到的，此外，团队通过观察序列在第二次或第三次试验中是否波动，手工检查了具有早期波动选择模式的少量序列。最后，识别了16%的异常序列。将这些参数标记为离群值，并用具有相同实验变量的所有参与者的偏差均值来代替从这些离群值中测量的偏差</p><p>—— 偏见测量</p><p>基于人类心理测量功能和韦伯定律，某一参与者在一个比例比/点半径上对一个视觉特征的偏差可以通过他/她对一系列试验的选择(使用主观相等点(PSE)和客观相等点(POE))进行定量测量。在这种情况下，当试验的试验散点图和参考散点图在本质上具有相同的特征值时，被试做出随机选择。因此，PSE是在一系列试验中选择test &lt; reference的0.5概率点，POE是基准特征值，其中试验特征值与参考特征图的实际特征值客观相等。因此，如果散点图缩放引起了感知偏差，则对2WS序列中的PSE与POE进行一定间隔的分离，间隔就是偏差，等于PSE减去POE</p><p>—— 显著性分析</p><p>作者对每个实验进行了两次显著性分析，第一个是参与者之间的偏见。首先使用夏皮罗-威尔克检验检验正态性，发现大多数结果不遵循正态分布(p &lt; 0.05)，然后使用非参数Friedman和ANOVA检验进行检验。结果表明，对于每个实验和视觉特征，不同参与者的偏误没有显著差异。因此，不同参与者的偏见可以得到平等对待。第二个显著性分析是不同尺度比/点半径之间的偏差。夏皮罗-威尔克检验表明，所有结果不遵循正态分布(p &lt; 0.05)。因此，使用非参数Friedman检验来检查每个视觉特征的7个尺度比/点半径的偏差是否存在显著差异</p><p>作者假设几何尺度对三个视觉特征的感知存在偏差，且偏差可能与尺度比成线性关系。这一假设得到了充分的证实。随着偏差的存在，当尺度比不为100%时，所有特征都表现出一定程度的偏差，而当尺度比为100%时，偏差非常接近于0。这说明增大和缩小测试散点图会影响三个特征的感知一致性</p><p>作者假设偏差会受到数据分布的影响。通过特征和尺度比对E1(正态分布)和E2(均匀分布)的偏差进行两两t检验，以检验其显著性差异，然后采用Bonferroni校正将显著性水平从p = 0.05降低到0.00714(0.05/7)，因为在t检验中作者将每个特征的偏倚测量结果除以7个尺度比。三种特征的E1和E2在7个尺度比上的偏差均无显著差异(p &lt; 0.00714)。这一假设被完全否定了。作者认为，正态分布形成的视觉模式可能与均匀分布形成的视觉模式存在效率低下的差异</p><p>作者假设改变点的半径可以减小偏差。E3中，试验散点图按固定比例缩放，其点半径变化了7个层次，而参考散点图的基线半径不变(r = 2)，即E1中所有散点图的点半径。选择两个比例比(63%和252%)对放大和缩小情况进行测试。这个假设在一定程度上证实了该观点</p><p>实验结果如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GeometricScaling-5.png"></p><p>客观结果反映了三个主要发现。首先，几何分割会导致对三个视觉特征(聚类度、相关性和聚类分离)的感知偏见。偏见与标度比呈线性关系；即当标度比增大或减小时，偏差的绝对值增大。其次，从正态分布和均匀分布的散点图测量的偏差之间没有显著性差异。第三，改变点的半径可以纠正偏差。这种校正只出现在一定的半径范围内，在数度和大尺度比的情况下，校正效果较大</p><p>主观结果发现也分三个方面，首先，数量的影响最大，参与者大致能认识到偏差和量表比率的关系，第二，一些参与者报告说，在均匀分布的散点图中，集合尺度对偏差的影响比在正太分布的散点图中要小一点，第三，参与者对改变点半径b的偏差校正效果不明显</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>文章中研究了散点图低水平和中水平分量，但高水平分量除外，作者认为，偏见在散点图缩放中是普遍存在的，但是可以以不同的形式表现出来，作者初步研究了正态分布和均匀分布的影响，多样化的数据分布在未来值得探索，文中只研究了点半径对偏见的影响，其它视觉通道需要进一步研究，如颜色，对比度，不透明度和亮度等</p><p>实验设计中得到的最重要的教训是试点研究的重要性，在试点研究中团队验证了2AFC方法，实验的随机序列以及从E1到E3的实验顺序是不合理的，作者发现，如果实验持续进行，参与者的表现会随着时间的推移而下降，为了尽量减少疲劳对实验结果的影响，作者建立了各种严格的休息机制，在一个实验中完成所有的实验后，要求参与者休息2 - 3分钟，然后继续进行下一个实验。在一轮实验结束后，参与者有一个小时的休息时间，在下一轮实验开始前会进行一个预实验来测试参与者的心理状态。参与者被允许在几天内完成所有的实验，如果他们报告强烈的疲劳感或在实验中遇到了意想不到的情况，此外实验中的散点图均在一个统一的桌面显示器上显示，这种做法减少了可控实验，降低了生态效度。可以进一步探讨不同的显示设备和屏幕分辨率如何影响几何缩放引起的偏差</p><p>从少量异常序列测量的偏差被替换为具有相同实验变量的所有参与者的偏差平均值。作者仔细检查了这些序列，以确保它们都有明显的错误选择模式，但这样的替换仍可能对实验结果产生潜在的影响，在E1方面，作者对各量表比中所有参与者的偏差均值进行线性回归和趋势分析，因为参与者之间的偏差不存在显著差异。团队没有调查所有个体的偏见，而是关注总体的平均表现，这与Harrison等人的研究相似，对于E3，还没有得到一个准确的模型来指导偏差校正。主要原因可能是点半径和比例尺比率的测试水平仍然不够</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> bias </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息可视化中的认知偏见</title>
      <link href="2020/09/22/cognitive-biases/"/>
      <url>2020/09/22/cognitive-biases/</url>
      
        <content type="html"><![CDATA[<blockquote><p>IEEE引用格式：E. Dimara, S. Franconeri, C. Plaisant, A. Bezerianos, and P. Dragicevic, “A Task-Based Taxonomy of Cognitive Biases for Information Visualization,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 2, pp. 1413–1432, 2020, doi: 10.1109/TVCG.2018.2872577.</p></blockquote><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>可视化设计师必须考虑三种限制:计算机的限制、显示器的限制和人的限制，对于人的限制来说，设计师必须考虑人类视觉的局限性以及人类推理的局限性。本文关注的是后者，强调人类判断和决策的缺陷</p><p>我们的判断和决定通常依赖于近似值、启发式和经验法则，即使我们没有意识到这些策略，这些策略的缺陷表现为认知偏差，虽然可视化工具是用来支持判断和决策的，但人们对认知偏见如何影响人们使用工具知之甚少，要理解可视化如何支持判断和决策，我们首先需要理解人类推理的局限性如何影响可视化数据分析</p><p>在信息可视化社区中，人们对决策和认知偏差越来越感兴趣，IEEE VIS会议已经举办了两个关于信息可视化中的认知偏差的研讨会，其他论文也承认了在视觉数据分析中研究认知偏差的重要性，尽管兴趣日益增长，但实证研究仍然有限。大多数可视化的评估不包括决策任务，而那些包含决策任务的评估通常假设人类决策是一个理性的过程，此外，证实或否定信息可视化中特定认知偏差存在的研究很少。与此同时，认知偏差研究中的大多数实验任务都使用文本表示，给出的信息由非常小的数据集组成——或者根本没有数据。因此，认知偏差和视觉数据分析之间的相互作用在很大程度上仍未被探索</p><p>本文的目标是通过对认知偏差的广泛回顾，帮助弥合认知心理学和可视化研究之间的差距，目标是信息可视化研究人员。作者根据用户的任务定义了认知偏差的分类，而不是建议对偏差产生的原因进行心理解释。这篇论文的目的是展示问题空间，促进假设的生成，并指导未来的研究，这些研究将最终帮助可视化设计者预测——甚至可能减轻——人类判断的局限性</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="认知偏见"><a href="#认知偏见" class="headerlink" title="认知偏见"></a>认知偏见</h3><p>判断和决策的规范性模型假设人们遵循理性的公理，有一组固定的偏好，并做出最大化自己利益的决策。由约翰·冯提出期望效用理论制定了一套规范的规则，任何违反这些规则的决定都被认为是不合理的</p><p>Kahneman和Tversky系统性地定义了违反这些规则的证据，称之为认知偏差，例如，在一个实验中，人们会选择程序框架有33%的机会拯救生命胜与拥有66%的死亡机会，尽管两个项目是一样的，这种偏见被称为框架效应。另一个众所周知的例子是确认偏见(confirmation bias)，指的是人们会寻求并偏爱能证实自己信念的信息</p><p>Pohl将认知偏见定义为一种认知现象：可靠地偏离现实，系统地发生，不自觉的发生，很难或不可能避免，并且和信息处理的正常过程截然不同</p><p>因此，认知偏见是一种认知现象，涉及到对现实的偏见，是可预测的，并且在人们之间时相对一致的，一个受认知偏见影响的人并不意识到它，并相信他们的决定，判断或记忆是公正的，偏见往往仍然存在，即使当人们被告知和训练如何克服他们</p><h3 id="认知偏见概念的难点"><a href="#认知偏见概念的难点" class="headerlink" title="认知偏见概念的难点"></a>认知偏见概念的难点</h3><p>认知偏见概念的一个主要难点在于判断什么构成了对”现实”的偏离，这与视觉偏见的研究形成了鲜明的对比，在视觉偏见中，现实是被物理定义的，一个人可以表明视觉客观地偏离了哪个现实，然而对认知偏见来说，现实往往难以操作化。现实通常是基于判断和决策的规范模型来定义的，但这些模型并没有被普遍接受，未来可能会出现新的规范模型，从而改变”现实”的构成。与遵循规范原则的成本相比，没有关于”错误”决策成本的完整信息，这使得决定和判断的价值难以评估，因此，认知偏见的概念在决策领域引发了长期的争论，然而，一些研究人员坚持认为，认知偏见是真实存在的，具有重要的影响，另一些人认为，在实验中产生错误的认知实际上是解决现实世界中复杂问你题的有效策略</p><p>答案可能介于两者之间:在许多情况下，鉴于人类的时间和认知资源有限，启发式和经验法则可以简化复杂的问题并产生有效的决策。然而，我们知道启发式并不总是导致最优决策，一些启发式通常会以一种系统的、可预测的方式导致偏离最优性的决策，可能会带来现实生活中的后果。因此，尽管很难定义和研究认知偏差，但认知偏差是重要的，可视化研究人员需要意识到它们</p><h3 id="认知偏见分类"><a href="#认知偏见分类" class="headerlink" title="认知偏见分类"></a>认知偏见分类</h3><p>作者回顾了来自不同领域(心理学、决策系统、情报分析、可视化)的现有分类。发现大多数现有的分类都是解释性的：它们根据产生偏见的原因，通过考虑认知机制和解释性理论来组织偏见，相比之下，本文分类法是基于任务的。它根据观察到的实验任务来组织偏差，以帮助可视化研究人员识别可能影响可视化任务的偏见</p><p>作者在可视化文献中没有发现关于认知偏见的全面综述，一些研究已经开始整理和视觉分析特定方面相关的偏见，科学家们对于认知偏见的原因仍然没有达成一致，此外，在某些情况下，偏见和复杂数据处理之间预先存在的练习并不总是得到强有力的支持，虽然理解偏见的本质和来源很重要，但本文采取了更实际的方法。基于对偏差进行实验研究的论文，根据他们所观察和测量的任务对其进行分类</p><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><p>在标准的书目搜索之后，作者收集了偏见的初始列表，第二步是搜索最具代表性的论文，对列表中的每一种偏见进行了实证检验，第三，采用一种类似卡片分类的自下而上的分组方法对认知偏见进行分类，分类和其标签被迭代精炼，试图使它们对可视化研究人员更有用，本文对所有的偏见进行分类，并从可视化的角度审视每一个偏见：1)搜索现有的相关可视化工作(如果有的话)；2)头脑风暴未来可视化研究的机会(报告在各自的类别描述)</p><p>本文提出的新的认知偏见分类是根据观察到偏见时用户所执行的任务来组织的。例如，估计心脏病发作或乳腺癌的可能性被认为是一项估计任务。在不同的健康保险政策之间进行选择是一项决策任务，造成偏见的原因可能已经被研究过(例如，错误的概率估计可能导致错误的保险选择)，但是在我们对偏见的分类中忽略了这一点。本文的分类侧重于出现偏见的任务，而不是像以前那样关注为什么会出现偏见</p><p>作者决定从维基百科页面上发现的认知偏见(以及它们的同义词)开始，”认知偏见清单”-检索于2017年11月20日，总共有176中偏见，是迄今为止作者找到的最长的偏见列表，作者将其称为维基百科列表页面，这个列表的每个条目都指向一个单独的维基百科页面来描述这种偏见。尽管维基百科是发现的最大的偏见列表，但它并不是由研究人员策划的，因此接下来介绍如何验证哪些认知偏见是通过可靠的实验协议检测出来的</p><p>因为有大量的偏见，为了保持数量，每个偏见只保留一篇代表性的论文，对于这176个偏见中的每一个，采取以下过程：</p><ol><li><p>在谷歌学术中输入搜索词 偏见名+信息可视化 来搜索是否在InfoVis文献中提到过偏见，作者收集了所有提及偏差的InfoVis论文，在提到偏见的可视化论文中，收集了用于描述偏见的源参考，并确定它是否是一个合格的源，作者只保留一份原始文件</p></li><li><p>当找不到一篇提到这种偏见的InfoVis论文时，或者如果这些论文没有引用一个合格的来源，我们就在维基百科的列表页面或个人维基百科页面中搜索合格的来源，如果在维基百科中没有找到合适的来源，则通过在谷歌学术中输出搜索词 偏见名+信息可视化 来搜索一个来源</p></li><li><p>当根本找不到来源时，偏见就从名单中删除</p></li></ol><p>合格的源的标准：1.这是一篇同行评议的论文；2.文档可以获取；3.报告了一项人类受试者研究，以测试存在的偏见或引用了另一篇报道该研究的论文，并详细描述了论文的实验任务</p><p>对于非专业人士来说，表中的一些偏见可能看起来很相似，但作者在偏差研究者认为不同的情况下将它们分开。此外，如果两种偏差以不同的名称出现在不同的研究论文中，团队会同时保留这两种偏差，即使它们看起来很相似</p><p>为了生成基于任务的分类，首先必须确定研究偏见时使用的任务类型。然后使用开放卡片排序分析来生成类别，任务标签被分为7个类别，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cognitive-biases-1.png"></p><p>每个类别都包含了相当多的偏见，因此增加了子类别</p><h2 id="基于任务的认知偏见分类"><a href="#基于任务的认知偏见分类" class="headerlink" title="基于任务的认知偏见分类"></a>基于任务的认知偏见分类</h2><p>这部分内容通过提供任务的例子来回顾每个类别，使用来自心理学研究的例子来描述偏见的子集，讨论可视化方面的相关工作，并强调可视化研究的潜在研究机会</p><h3 id="估计任务中的偏见"><a href="#估计任务中的偏见" class="headerlink" title="估计任务中的偏见"></a>估计任务中的偏见</h3><p>在评估任务中，要求人们评估一个数量的价值。例如，在现实生活中的决策任务中，一个人可能需要估计盗窃的可能性来决定是否为自己的车投保，或者估计自己未来的退休需求来选择退休计划</p><p>在认知偏见研究中，许多评估任务需要评估某一事件在假设情况或未来发生的可能性，一些心理学实验包括一个概率估计任务，在这个任务中，正确的答案可以通过计算得到(例如，通过应用贝叶斯定理)。对真实答案的系统性偏见被认为是一种认知偏见。例如，对基础概率谬误的研究表明，人们会过分高估某一事件发生的可能性(例如，乳房x光检查结果呈阳性后患乳腺癌)，因为他们往往只关注具体事件实例，而忽略了适用于一般人群的概率，有明确的事实基础的概率估计任务有助于发现其他认知偏差，如合取谬误，即人们认为特定事件比一般事件更有可能发生。此外，根据保守主义偏见的研究，人们通常不会根据新信息充分修正他们对概率的估计</p><p>一些实验涉及没有GT的概率估计任务。在这里，评价回答不是基于他们与真实答案的一致性，而是基于他们与理性的基本规范原则的一致性。例如，根据乐观偏见的实验，当人们被要求对未来的事情做出预测时(例如，找到一份理想的工作，离婚，或患肺癌)，他们往往会对自己做出比别人更乐观的预测</p><p>许多实验使用的估计任务不涉及明确的概率，但有一个概率成分。频率估计就是这样一个例子。作为偏见的一个例子，人们倾向于认为以字母”R”开头的单词比以字母”R”在第三位的单词出现的频率更高，人们认为，这是因为人们使用了”可用性启发式”(availability heuristic)，即以”R”开头的单词更容易从记忆中检索出来，因此被认为出现的频率更高，时间预测是”准概率”估计任务的另一个例子，因为估计未来事件的时间或持续时间与估计事件在某一时刻之前或之后发生的概率有关。有几项研究要求参与者预测完成一项任务所需的时间<br>(例如学术项目或任务)，并将预测与实际结果进行比较，这些研究一致表明，人们倾向于过度乐观的预测，不管他们过去的经验，这种偏见被称为计划谬误</p><p>最后，一些实验显然涉及非概率估计任务，例如估计国家人口，例如，Tversky和Kahneman让参与者转一个幸运轮，然后估算联合国中非洲国家的数量，人们的回答倾向于接近幸运轮降落的数字，由于这个数字与问题没有关系，它对答案的影响强烈暗示着不合理。人们的定量估计倾向于他们最初接触到的一个值，这种倾向被称为锚定效应(anchoring effect)，同时，Goldstein和Gigerenzer表明，当学生们被要求比较城市人口，他们对本国城市的判断表现得比较好(如果我从未听说过一个城市，那么它必须是小的)，这个实验表明，启发式不一定会导致认知偏差，有时甚至可以产生更准确的判断</p><p>尽管评估任务在可视化任务分类中没有明确列出，但它们在可视化数据分析中无处不在，当不可能或不需要一个准确的答案时，分析任务就可能包括估计</p><p>最近的两项研究考察了锚定效应在信息可视化环境中的影响，Valdez等人给参与者一系列的散点图分类任务，并发现他们的反应收到第一张散点图的影响，Cho等人要求参与者使用视觉分析系统探索真实推特数据集，他们发现他们对于定量估算问题的回答受到锚的存在的影响，虽然Cho等人只发现锚以数字形式出现时才会产生影响，但用户日志分析表明，可视化锚会影响参与者的分析过程</p><p>Xiong等人利用一项估计任务，为可视化通信中存在的知识的诅咒提供了初步但令人信服的证据。”知识的诅咒”(The curse of knowledge)指的是人们倾向于高估自己与他人分享知识或专业技能的程度，Xiong等人的研究表明，在观看可视化图像之前，先接触文本叙事的参与者会发现与文本叙事相关的模式更为突出。至关重要的是，参与者倾向于预测，同样的模式对没有了解的观众也会很明显</p><p>除了经验性的工作，信息可视化文档已经产生了讨论可视化设计如何减轻估计偏见的文献，比如Dragicevic和Jansen列举了使用可视化和数据管理工具来减轻计划谬误的四种可能策略，而Dimara等则提出了使用可视化来减轻可用性偏见的三种方法，然而还没有开发出任何工具，也没有进行任何实验来评估这些策略的有效性</p><p>虽然自我报告的自信是信息可视化评估中常见的度量标准，但是它可能会受到偏见的影响，认知偏见研究的结果表明，信心指标需要校准，并将其置于任务准确性的背景下，即使置信度判断可以与规范统计原则兼容[70]，它们也很容易受到环境的影响。先前的可视化研究表明，间接的信任评估(例如，”如果推荐系统给你另一个建议，你改变选择的可能性有多大?”)可能比直接的信心评级(例如，”你对自己的选择有多自信?”)更可靠，然而，据我们所知，以前没有可视化研究检查与性能评估相关的偏见</p><p>在这一点上，可用的经验数据太少，无法为从业者提供强有力的指导方针。一种可能的建议是，可视化应该设计为最小化获得问题答案所需的估计数量，实现这一点的一种方法是计算并可视化地将相关的汇总值呈现给用户，然而，设计签名者通常不可能预料到用户可能会对数据提出的所有问题，当用户很可能通过结合几条信息来得到不太起眼的问题的答案时，对贝叶斯估计问题的初步研究表明，将数字显示在可视化的旁边(或顶部)可能会适得其反，原因是数字会提示用户进行计算，而计算错误会产生比不完全近似更大的错误，除非需要精确的值，否则建议对所有数据进行编码量化</p><h3 id="决策任务中的偏见"><a href="#决策任务中的偏见" class="headerlink" title="决策任务中的偏见"></a>决策任务中的偏见</h3><p>通过决策任务，作者引用任何涉及从多个备选选项中选择一个的任务。使用这种任务的心理学实验称为选择研究</p><p>当人们面对不确定性的时候，就会产生一些决策偏见，比如，在模糊效应中，人们倾向于避免与模糊结果相关的决策；或者在零风险偏见中，如果一组选择中包含一个完全消除风险的替代选项，即使这不是最优决策，他们也会坚持下去。人们还常常根据问题是受益还是损失，或者简单地被定义为受益或损失，即框架效应，显示不同的偏好</p><p>然而，并非所有的决策偏差都与不确定的结果或框架有关。当人们做出这样或那样的选择时，他们常常会无意识地受到与所做决定无关的因素的影响。在大多数情况下，决策者不是孤立地评估备选方案，而是在备选方案出现的上下文中进行评估。一个被充分研究的例子是吸引力效应，即一个人在两个选择之间的决定会受到不相关(低劣)选择的存在的影响</p><p>某些偏见，比如越少越好效果(less is better effect)，人们的决定会受到选择项是单独出现还是并列出现的影响，或者这些选择是否在更极端的选择中出现(妥协效应)，或不可用的选项(幻影效应)，或更熟悉的替代品(刚接触效应)</p><p>其他的认知偏见指的是那些看起来更容易被能够立即得到奖励的选择所吸引的人，比如双曲线折扣，或者他们之前投入了自我努力，比如宜家效应。例子还包括对人们过去拥有的替代品的吸引力(禀赋效应)，或者避免做出任何需要改变当前状态的决定(现状偏见)</p><p>Dimara等人发现散点图在可视化中存在在吸引效应，并证实即使数据被正确地可视化和理解，决策也可能是不理性的，最近的研究表明，可视化可以通过允许用户从显示中删除不应该影响理性决策过程的信息来缓解吸引效应，Zhang等人进一步表明，采用静态表格可视化星级评级的初创公司往往容易受到损失厌恶倾向的影响</p><p>另一个在可视化背景下研究的决策偏见的例子是可识别的受害者效应，与大量抽象或统计描述的人相比，人们更倾向于帮助一个被具体描述的需要帮助的人。相比之下，Boy等人发现，使用类似具体的拟人化图标的数据图形不会增加用户对弱势群体的同情。这一结果表明，将认知偏差的发现与可视化设计结合起来，很难预测结果</p><p>视觉化也可以用来寻找认知偏见的证据。这种决定偏见的一个例子是在政府选举中。有几项科学研究对候选人在选票上的顺序会影响选举结果这一假设进行了很长时间的调查，但它们只找到了非决定性的证据，有研究收集了2010年5月6日举行的大伦敦地区地方选举的5000名候选人的数据，使用分层空间排列的可视化方法对他们进行了分析，结果表明候选人名字在选票上的位置确实影响了他们获得的选票数量。Wood等人的视觉分析技术表明，候选人按字母顺序的表格表示可能导致选举结果有偏见</p><p>虽然决策偏见对于以支持决策为目标的可视化系统来说是至关重要的，但大多数决策支持可视化很少评估用户决策的质量</p><h3 id="假设评估任务中的偏见"><a href="#假设评估任务中的偏见" class="headerlink" title="假设评估任务中的偏见"></a>假设评估任务中的偏见</h3><p>假设评估任务指的是调查一个或多个假设是否正确的任务。这里的”假设”一词并不一定指正式的统计假设，而是指任何非正式的或正式的、可以用以前的或新的知识加以证实或否定的陈述，作者确定了11种假设评估偏见</p><p>最具影响力的偏见之一就是确认偏见，人们在潜意识中忽略否定证据的同时证实最初假设的证据，这一类别的相关偏见是”虚假真理效应”，即人们在反复接触某一命题后，认为该命题为真；一致性偏见，即人们在检验一个假设是否正确时不考虑其他假设；以及当人们考虑不存在的变量之间的关系时产生的错觉相关偏见</p><p>科学家自己在假设评估中也会受到偏见的影响。例如，根据对”前围观者效应”的研究，实验者可以潜意识地影响参与者，使他们的行为符合他们的实验心理假设</p><p>假设评估任务在使用可视化工具进行数据分析和推理中很常见，例如探索卡车是否比普通汽车发生更多事故；是否一辆汽车的马力与其重量相关；或者地球温度是否在上升。Keim等人将这种类型的高级任务称为验证性分析，Amar和Stasko在他们的分类中将其定义为确认假设任务</p><p>虽然假设评估偏见被认为是信息可视化的关键挑战，但我们不知道有任何实证研究试图对其进行评估。自然的第一步应该是通过经验来确认，在使用可视化时，假设评估偏见确实会发生</p><p>为了减轻确认偏见，心理学文献中提出了几种策略，包括”竞争假说分析”和”证据整理”，这些方法分别鼓励分析师产生多个假设，并在得到任何结论之前仔细记录证实或拒绝每一个假设的证据，一些软件工具帮助用户遵循这些方法，方便记录和证据与假设的联系，这些方法可能会减轻这一类别中的其它偏见，为研究开辟新的机会</p><p>作为可视化设计师，我们可以考虑其他可能的设计特征作为可能的方法来减轻假设评估偏见。例如，我们可以研究是否可以通过显示哪些数据已经在我们的视觉化中被检查过，哪些被忽略，来减少可信度和其他相关偏见，或者当我们建议或要求在我们的工具中遵循特定的分析工作流时，它们是否可以被减少。虽然我们努力给所有的展示贴上清晰的标签，但在某些情况下，暂时隐藏标签可以通过模拟一种”盲测”的情况来减少假设评估的偏见，例如，考虑一位分析人员检查有关犯罪的证据或输入基于种族的统计数据。如果在最初审查收入或犯罪数据时，可视化显示的是简单的标签(如A、B和C)，而不是实际的种族值，那么它可以删除可能的种族偏见，使得分析师考虑他们所掌握的所有证据</p><p>除了确定测试这些偏见的机会并以可视化的方式减轻它们之外，我们还希望提高对我们社区中存在的假设评估偏见的意识，因为作为研究人员，我们可能容易产生这些偏见。我们希望这种认识将有助于可视化研究人员采用更稳健的方法来应对这些偏见</p><h3 id="因果归因任务中的偏见"><a href="#因果归因任务中的偏见" class="headerlink" title="因果归因任务中的偏见"></a>因果归因任务中的偏见</h3><p>因果归因任务指的是任何涉及因果关系评估的任务，在社会心理学中，归因理论研究人们如何解释行为和事件的原因，例如，在解释一个事件时，人们可以将事件归因于外部因素(例如，John出了车祸，因为路况不好)，也可以归因于内部因素(例如，John出了车祸，因为他不是一个好司机)，这个类别下作者一共总结了12种偏见</p><p>归因偏见主要是在社会心理学中研究的，所以实验场景通常集中在对人类行为的判断上。它们揭示了人们在给出解释时倾向于偏爱自己，例如，自我中心偏见表明，当被要求解释为什么一个共同的成就是成功的时，人们倾向于高估自己的贡献，同样，这种自我服务的偏见表明，人们倾向于把成功归因于自己的能力和努力，而把失败归因于外部因素，例如，一个学生可以把好的考试成绩归功于自己的努力，而把不好的成绩归功于外部因素，比如老师的素质太差或者考试中的问题不公平，当谈到失败时，根据”行动者-观察者偏见”，人们倾向于将自己的失败归因于情境因素，而将他人的失败归因于个性弱点，例如，他们更可能把交通事故归咎于糟糕的路况或其他司机，而把其他人的交通事故归咎于他们糟糕的驾驶技术。人们有时也倾向于将他人模棱两可的行为归因于故意的负面原因，例如，我看到我的同伴在笑，他们可能是在笑我</p><p>归因偏差不仅发生在人们不公正地评价自己的行为和他人的行为时，也发生在群体成员(内群体成员)对外部群体成员(外群体成员)的行为，在判断外群体成员的行为时，人们也倾向于对个体的行为进行过度概括。例如，在群体归因错误中，人们倾向于将群体做出的决定泛化到个体身上</p><p>因果归因任务在使用可视化时也很常见。Amar和Stasko将这些任务明确标识为在其分类中表示因果关系的任务。原则上，任何分析任务都可以涉及因果归因，当用户在探索数据时试图解释现象为什么会发生，比如试图解释峰值或异常值。例如，当分析师试图确定”为什么美国的大规模杀戮比其他国家更多?”或者”是什么原因导致了法国最近交通事故死亡人数的下降?”</p><p>数据分析活动包括描述数据中的模式，但也包括根据这些模式制定决定性步骤，通常依赖于用户的内部因果模型，即哪些因素会影响数据中的哪些结果。已有一些可视化工具可以帮助进行此类分析(如因果分析图)，但还需要对其有效性进行进一步研究</p><p>尽管因果归因偏差还没有成为可视化领域大量研究的主题，但该领域的研究潜力已经成熟。过去的研究发现，分析师基于相关性的存在得出了错误的因果结论。例如，当观察到激素替代疗法(HRT)患者的非典型心脏病发病率也低于平均水平时，医生建议HRT预防听力疾病；后来的一项分析表明，更有可能的是，因为激素替代疗法的患者来自社会经济地位较高的群体，当存在相关性时，研究可视化设计可能会减少错误的因果归因，这可能是富有成效的</p><p>另一个可能的研究方向来自一个有趣的数据，仪表盘用户更有可能从可视化数据中做出没有根据的因果声明。一份图表显示，使用新GPS系统的司机发生事故(每年1%)比使用旧系统的司机(每年2%)多，观察者很可能错误地认为新GPS设备导致更多事故，为了得出正确的结论，查看者必须考虑预先存在的驾驶员行为。在这种情况下，大多数安全的司机没有使用新的系统。决定使用新的GPS系统的大多是那些冒险的司机(无论如何，他们往往会发生更多的事故)，因此增加了新系统的事故数量，事实上，当单独考虑时，新系统提高了两类驾驶员的安全性。收集经验数据来证明这类潜在的关键性错误的存在是很重要的，这些错误源于选择可视化的数据组合</p><p>错误的因果归因的另一个副作用是人们不能正确地监控共同行动的结果或低估了他人的贡献，然而，有效的协同工作在视觉数据分析中是必不可少的，例如，当多个调查人员监控不同的可疑个体时，一个危险的情况在实时发展。如果添加展示同事活动的可视化效果，是否能促进对他人工作的更平衡的欣赏，这将是一个有趣的研究</p><h3 id="回忆任务中的偏见"><a href="#回忆任务中的偏见" class="headerlink" title="回忆任务中的偏见"></a>回忆任务中的偏见</h3><p>记忆不是对过去经历的复制，而是在回忆的时候重建的，这意味着事件后的信息可以改变记忆，这被称为错误信息效应。更普遍的是，人们倾向于更好的回忆，人们还会把别人的想法误认为是原创的，这可能是剽窃的一个潜在原因，相反，人们将一些虚构事件视为真实，这是在对犯罪证人进行采访时，经过误导的暗示后经常看到的现象</p><p>从理论上讲，通过对所有相关信息无偏见地补充记忆，使用可视化可以帮助观众克服有限的(和有偏见的)记忆回忆过程。但在复杂的数据集中，并不是所有的信息都能被显示，即使可以，也不可能全部被查看者处理。此外，观看者仍将依赖一个有限的、有偏见的记忆系统来将观看的数据点与例子、上下文和情绪联系起来。所以视觉化能够减少，但不能消除，有偏见的回忆过程，这个问题的一个解决方案可能是注释系统，它引导观察者记录对已查看数据子集的观察和判断，然后组织并提供用户偏好的自动比较</p><p>可视化的一些特性可以使它们更容易记住。包括真实世界的图像或物体或不同于其他人的视觉化可以引导参与者更好地回忆他们看到的那些视觉化。一些工作正在开始另外显示记忆可以改善在可视化中描绘的数据模式，将传统的柱状图转换成一堆物体的图标图片(例如，将一些棒球比赛描述成一堆棒球)可以提高对所描述信息的短期记忆。将数据模式链接到真实的对象可以提升模式的长期记忆，一个为数据形状助记提供建议的自动化系统可以增强人类有限的记忆力</p><h3 id="观点报告任务中的偏见"><a href="#观点报告任务中的偏见" class="headerlink" title="观点报告任务中的偏见"></a>观点报告任务中的偏见</h3><p>尽管参与者的观点在许多其他偏见类别中扮演着重要角色，但在观点转证类别中，任务是明确地报告这个观点(例如，美国人很聪明)。相比之下，在因果归因类别中，任务是解释一种现象(例如，美国人享受经济增长是因为美国人聪明)，在假设评估类别中，目标是调查一个陈述是对的还是错的(例如，根据这些数据，即美国的智商分数，文章，事实，美国人聪明吗?)在估计类别中，目标是评估一个数量或预测一个结果(例如，美国可能会增长，因为美国人很聪明)，观点报道的偏见不同于其他类别，因为有某些信念的人不一定会基于这些信念来推理或预测未来</p><p>根据从众效应，人们对堕胎等问题的信仰可以根据多数人的观点而改变。然而，人们往往认为，与自己相比，他人更有偏见(天真的犬儒主义)，更容易受到大众媒体宣传(第三人称效应)。人们还倾向于将某个群体成员的某些特征(如种族、民族、性别、年龄)归纳到整个群体，而往往忽略相互矛盾的证据(刻板印象)。最后，人们倾向于根据结果而不是行为来承担道德责任(道德)</p><p>意见报告这一类别本质上与人们的态度、道德信念和行为有关，而不是在一般性分析任务中观察到的偏见，这对可视化研究人员可能没有太大用处。然而，类似于所有其他偏见类别，这些错误与可视化系统的可能联系是一个未探索的话题，特别是当它涉及到减轻偏见</p><h3 id="其它偏见"><a href="#其它偏见" class="headerlink" title="其它偏见"></a>其它偏见</h3><p>最后一个类别包括所有的系统偏见，这些偏见是通过实验观察到的，与前面讨论的任何任务都无关</p><p>这一类别的一些偏见涉及观察行为而不是评估反应。例如，根据单位偏见，人们倾向于在较大的邻域吃更多的食物，投资者倾向于当投资表现出负面信息时，减少对其投资组合的监控(鸵鸟效应)，一旦人们的安全意识增强，他们也会倾向于发展更危险的行为，例如，开一辆安全气囊更好的车会开得更快。(风险补偿)</p><p>尽管这些偏见并不局限于特定的任务类别，但它们可能与可视化设计有关，例如，单位偏见可能与数量的视觉判断有关，例如，由于轴缩放的选择，散点点周围增加的空白可能会影响对有多少数据点的判断，鸵鸟效应与人们可能淡化或忽略浏览者认为是负面的信息的数据或分析显示有关，这表明自动化系统可以突出这些信息来抵消这种偏见，当查看者考虑如何为显示在视图中的数据值设置阈值，并根据有关其他参数的新但不相关的信息更改阈值时，可能会出现类似于风险补偿的偏差</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="基于任务分类的好处"><a href="#基于任务分类的好处" class="headerlink" title="基于任务分类的好处"></a>基于任务分类的好处</h3><p>本文提出的分类法是按照任务来组织的，而以前的分类法是基于经常未经测试的、难以理解的、甚至是矛盾的对认知偏见产生原因的解释。我们相信，这种组织将使可视化研究人员更容易发现哪些偏见可能与他们的系统或研究领域相关。它假设已经进行了任务分析(这是一个标准的用户界面设计实践)，而不是要求视觉化研究人员猜测用户可能必须遵循的内部认知过程</p><p>最后，我们的分类保留了指向原始实验的指针，这可以帮助可视化研究人员使用在其他领域已经建立的方法进行新的评估</p><p>很可能将来会发现更多的偏见，而偏见的列表将不得不进一步扩大。据我们所知，这一分类是迄今为止文献中最大的，包括在不同研究领域(如心理学、消费者研究、社会学)研究的偏见</p><h3 id="可视化任务"><a href="#可视化任务" class="headerlink" title="可视化任务"></a>可视化任务</h3><p>作者通过对用于检测这些偏见的实验任务的分析，得出了偏见的类别。因此，这些分类捕获的任务不一定与可视化分类中描述的可视化任务保持一致，此类任务通常是较低级别的任务，但可以作为分类法中许多较高级任务的构建块，然而，正如在类别中看到的，本文的一些任务确实与可视化分类共享，例如假设评估或因果公式，然而，所确定的所有任务都与可视化系统和研究的目标高度相关。例如，决策支持系统的用户经常必须做出选择，而决策类别揭示了偏见，当用户执行这些任务时，偏见可能是一个因素，同样，对可视化设计的可记忆性感兴趣的可视化研究人员可以关注回忆偏见。研究验证性分析任务的研究人员可以从假设评估类别开始，而研究不确定性可视化的研究人员可能需要关注估计类别</p><h3 id="未来研究的机会"><a href="#未来研究的机会" class="headerlink" title="未来研究的机会"></a>未来研究的机会</h3><p>目前关于视觉认知偏见的研究很少，这为未来的可视化研究提供了很多机会。研究人员可以从附录表中提供的丰富的认知偏见集合中选择一个偏见，测试当提供标准的可视化图像时，偏见是否仍然存在，如果是，研究是否可以通过使用改进的设计来减轻偏见</p><p>在信息可视化的背景下研究认知偏见也为扩展心理学的方法和结果提供了机会。例如，吸引力效应是一种决策偏见，在数值表中只能用三种改变来定义。在一项可视化研究中，Dimara等人将吸引力效应的定义扩展到三种以上的选择，并提出了构建刺激数据集的程序</p><p>心理学文献经常提出缓解偏见的方法，其中一些策略可以应用于可视化实验。由于缓解策略是有偏向性的，本文不可能全部涵盖，每种偏见都需要自己的文献调查。作者希望本文的分类法将通过提供参考作为起点来促进这类调查</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>偏见是很多的，但很可能会发现更多的偏见。虽然所有的偏差都在附录表中列出和分类，但本文本身只能讨论偏见的一个子集。我们把讨论的重点放在那些对形象化最重要、在心理学中最完善、最反映了理性违背的偏见上</p><p>此外，每一种偏见都被划分为一个类别。在不同的研究中，同样的认知偏见可能存在于不止一种任务类型中，尽管大多数学术研究倾向于不断重复同样的任务，这种担忧确实是一种可能，但不一定是一种限制。分类法背后的假设是，研究人员应该以不同的方式处理不同的用户任务，关于吸引效应的文献中有一个很好的例子，在两个不同的任务中观察到同样的偏见。吸引效应作为一项决策任务在三种商业产品中被大量复制，有一些论文测试了视觉判断任务中的吸引力效应，如识别两个矩形中哪个更大或寻找圆和线对的相似性，尽管这些情况看起来与吸引效应相似，也可能有相似的根源，但最好是把它们当作感知偏见来对待，因为人们通常无法对物体的视觉属性进行编码</p><p>而且，最初的编码和排序是由一个人进行的。这可以通过包含所有五个作者的多次审查和迭代过程来缓解。为了使总引用的数量可控，对具有代表性的论文的搜索在满足来源资格要求的第一个部分停止，而不是彻底的搜索。本文的分类是一个起点，但是要深入研究特定的偏见，需要单独的文献综述</p><p>最后，根据定义，认知偏见假定”脱离现实”，这是一个复杂而有争议的概念。我们仍然没有确凿的证据证明已知的认知偏见实际上反映了非理性。因此，InfoVis研究者应该尝试在他们的研究中验证错误反应确实反映了不合理性，而不是基于任务的替代解释某种最佳策略。我们也鼓励可视化研究人员对当前围绕非理性概念的认知偏见研究的争论保持更新</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇论文分类了154种认知偏差，即人们系统地、非自愿地偏离预期的理性“现实”的情况。例如，他们的决定往往受到与决策方案的可预见品质无关的原因的影响。本文的分类是基于任务的(偏差是什么时候出现的)，而不是解释的(为什么会出现)，以帮助可视化研究人员识别可能影响他们的可视化任务的偏差</p><p>在视觉化文献中，认知偏见经常被认为是重要的。一些研究确实在视觉化的背景下讨论了认知偏差，但是他们没有提供在使用视觉化时检测或减轻偏见的证据。在本文的综述中，只发现了一项实证研究，该研究利用可视化设计减轻了认知偏差。更普遍的是，似乎很少有可视化研究为可视化中存在的认知偏见提供证据。这个空间为可视化的研究提供了充足的机会，并且作者希望本文在不同的偏见类别中提出的方向能够启发未来的工作</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> bias </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化中知识的诅咒</title>
      <link href="2020/09/21/Curse/"/>
      <url>2020/09/21/Curse/</url>
      
        <content type="html"><![CDATA[<p>这篇是VIS的Bias &amp; Patterns标签下的一篇文章</p><blockquote><p>IEEE引用格式：C. Xiong, L. van Weelden, and S. Franconeri, “The Curse of Knowledge in Visual Data Communication,” IEEE Trans. Vis. Comput. Graph., pp. 1–1, 2019, doi: 10.1109/tvcg.2019.2917689.</p></blockquote><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>在专家发表演讲时，与观众的信息处理能力相比，可视化的数据往往传递的过快过复杂而让人难以接受，而演讲人则通常忽略这一事实，这个现象称为知识的诅咒</p><p>知识的诅咒对交流有极大的影响，若人们认为信息已共享，则他们通常不会把信息传递给他人，这意味着演讲者必须准确知道观众知道什么，不知道什么，才能包含观众需要的信息</p><p>与数字和文本格式相比，数据可视化可以有效地突出显示数据中的关系和模式，但同时理解复杂的可视化就像读一个段落，不同的解读方式得到不同的结果，通过可视化数据进行交流能否成功，部分取决于预测，避免和纠正沟通失败的能力</p><p>本文的实验结果表明了，由于可视化专家不能从麻瓜观众角度出发而导致沟通失败的情况确实是存在的，这对于信息可视化的研究具有现实和理论意义，在两项研究中，团队告诉参与者图表的背景并要求他们预测不知情的观察者会注意到什么，作者预测，当参与者得到的信息使得他们认为数据中的一个故事在视觉上很突出时，他们会相信其他人也能体会到相同的显著性，即使他们被明确告知观众并不知道这些信息，这种想法也会持续下去</p><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>实验的目的是证明在视觉可视化的视觉感知中知识的诅咒，即知识是否会对个人如何看待可视化产生拍哪件，以及这些偏见是否预示着无知的观众也会有同样的偏见</p><p>实验的参与者完成了一项调查，在调查中，他们阅读了一个故事，故事传达了一个描绘政治投票数据的图表的背景知识，参与者被告知，实验的目的是想调查众包如何能很好第预测人们在类似图表中想看到的特征，同时，他们被告知，实验者想给100个人展示他们刚看到的图表，只有简短的描述但是没有故事，理由是后来的研究者有更严格的时间限制，而给他们一个故事的原因是为了了解数据是从哪里来的</p><p>然后让他们预测不知情的观众会看到的图表中最显著的视觉特征，他们并不知道具体要预测几个特征，只是被要求一次预测一个特征，从最突出的到第五突出的，因此他们不能提前计划他们要写下的五个特征，这最好地保证了这些特征被记录下来的顺序与参与这认为这些特征在视觉的突出程度相匹配，于此相反，实验性的实验证明了，一次性列出所有特征会导致参与者按照从左到右或者从上到下的顺序列出特征，而不管访谈中他们发现的最突出的特征是什么</p><p>在参与者写下他们预测的每个特征之后，还在一张纸的图形上圈出了对应于每个特征的区域，然后，他们报告了这五个预测的特征在视觉上对他们的突出程度，从1到5，1表示在视觉上并不突出以及5表示视觉上非常突出，最后，他们将自己的5个预测尽可能与电脑屏幕上呈现的5个预先确定的特征匹配。为了避免实验者的偏见，这种配对是由参与者而不是实验来完成的</p><p>作者假设参与者会：</p><ol><li><p>在五个预先确定的特征中，预测(写并圈出)他们读到的故事中突出的特征比故事中没有突出的特征在视觉上更加突出，突出的特征的排名高于没有突出的特征</p></li><li><p>对不知情的观众来说，他们认为视觉上最突出的特征对他们自己来说也是最突出的</p></li></ol><h2 id="线形图实验"><a href="#线形图实验" class="headerlink" title="线形图实验"></a>线形图实验</h2><p>18名西北大学的学生(10名女性)参与了这项实验，以换取心理学导论课的学分。如果需要，所有参与者都被要求带上矫正眼镜</p><p>第一个自变量是五个预先确定的特征的排名，这对应于参与者认为一个不知情的图观察者会描述的图中视觉上最显著特征到第五显著特征的优先顺序，第二个自变量是每个参与者对自己预测的特征在视觉上的突出程度打分，从1到5分</p><p>参与者读了一篇关于欧洲小国的总统选举的故事，四个主要政党：工党，保守派、联盟和联合，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-1.png"></p><p>这个故事突出了四个政党中的两个之间的竞争，说明公民投票意愿如何随着时事而波动，这些故事和数据都是虚构的，没有描述任何真实的人或事件，尽管没有明确地告诉参与者，起初，在两个突出的政党中，其中一个民调要遥遥领先，在最初的辩论中，领先的政党把选民转向了不那么受欢迎的政党，最终失去了领先地位，然而，在后来的辩论中，最初领先的政党却能收回候选人失去的选票，并在他的对手辩论表现不佳后再次领先</p><p>参与者被划分为三组(middle,top和bottom)，每个参与者都听到了同样的故事，但是在每个故事中，强调竞争的两方都有所不同</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-2.png"></p><p>图中显示的是工党和保守党之间的关系，工党和联盟党之间的关系，以及联盟党和联合党之间的关系。在每对线中，较高线的一方将选票让与较低线的一方，然后较高线的一方获得选票</p><p>读完故事后，研究人员向参与者展示了一个线形图，该线形图描绘了选举期间四个政党的民意调查信息</p><p>在图中，参与者通过使用突出显示的数据模式对故事点进行注释，虽然故事总是一样的，但是顶部、中间和底部的条件在图表上都突出了各自的特征，在这三种情况下，这两种辩论都与每张图上的左右框特征分别描述的两种波动有关。最初的辩论导致最初的领导政党的选票减少，这在左翼框中突出，而后来的辩论则为最初的领导政党挽回了失去的选票，这在右翼框中突出</p><p>在参与者预测一个不知情的图表观察者会认为什么是图表上最显著的特征之前，他们被展示了一个没有注释的折线图，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-3.png"></p><p>他们被告知，这个没有注释的图表没有故事，是不知情的图表观察者所能看到的全部。这个没有高亮显示的图表的纸质副本被提供给参与者来记录他们的预测</p><p>当参与者将自己的预测与五个预先确定的特征相匹配时，他们会参考自己在没有标注的纸上的标记，如下图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-4.png"></p><p>这五个特点都是在故事中突出的特点，但在三个不同的条件下。顶部的特性A和B对应于在top-prime的故事中描述和突出显示的特性。右下角的特性C和D对应于bottom-prime故事中描述和突出显示的特性，特征E对应middle-prime情况</p><p>所有的故事，实验刺激，和数据文件可在<a href="http://viscog.psych.northwestern.edu/VisualizationCurse2017/">Link</a>找到</p><p>通过检查参与者在没有标注的图表上标注的内容，我们发现这三种情况在性质上有明显的差异，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-5.png"></p><p>总的来说，这些定性结果支持了第一个假设，即在所有三种情况下，参与者都预测了故事中被描绘和突出的特征对于不知情的观众来说是最突出的视觉特征</p><p>在定量分析中，为了更直观地可视化，作者对预测特征的排名进行了反向编码，对预测的视觉上最显著的特征取倒数5，显著性第5的特征取1，利用实验的特征匹配部分的数据，对五个预先确定的特征进行排序，如果参与者认为五个预先确定的特征中没有一个与他/她的预测相匹配，那么这个特定的预测就会与”N/a”相匹配，那么统计分析就不考虑该预测，而将该预测的排名点计入，如果参与者将两个特征匹配到一个预测的特征，这两个特征将得到相同的等级</p><p>把故事明确反映出来的特征(一致性)和故事没有直接反映出来的特征(不一致性)放在一起，而不是单独比较，可以得到更清晰的区别。下图显示了参与者认为在故事中描述的特性对其他麻瓜查看者来说是突出的，比没有在故事中描述的特性更突出</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-6.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-7.png"></p><p>作者利用非参数Wilcoxon符号秩检验，计算了非同余特征秩和同余特征秩的差值，对应的特征等级是三种情况下故事中描述的特征的平均等级，任何没有排名的特征都被分配到6的等级，这样它就会低于所有排名的特征</p><p>同时，实验还测试了自我评价的显著性，也就是这些预测的特征在视觉上对参与者本身有多显著。在他们预测其他不知情的图表阅读者会认为视觉显著性的特征被标记下来后，参与者按照1到5的等级对他们自己的视觉显著性进行评分，随后作者计算了一个简单的线性回归来预测基于特征顺序的自评显著性，如下图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-8.png"></p><p>参与者通过阅读故事获得的知识会使他们的预测产生偏差，因此，一般来说，他们认为故事中描述的特征比故事中没有描述的特征在视觉上更显著，更重要的是，在获得了这些背景知识之后，参与者会有偏见地预测，其他不知情的图表观看者也会认为这些特征在视觉上更加突出</p><p>本实验的定性和定量统计分析都是事后进行的。为了确保研究结果的有效性，团队接下来在一组新的参与者上重复了这个线形图实验，并按照相同的程序和数据分析方法分析了数据</p><h2 id="线形图实验复刻"><a href="#线形图实验复刻" class="headerlink" title="线形图实验复刻"></a>线形图实验复刻</h2><p>过程与线形图实验一致，略</p><h2 id="条形图实验"><a href="#条形图实验" class="headerlink" title="条形图实验"></a>条形图实验</h2><p>和线形图实验非常相似</p><p>预设特征如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-9.png"></p><p>定性和定量分析结果如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-10.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Curse-11.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在三个使用两种图形的实验中，参与者被要求模拟别人在可视化中看到的东西，这让他们遭受了知识的诅咒。当参与者被告知三种可能的背景故事中的一种，每一种都使图形中的特定图案在视觉上突出时，参与者认为麻瓜观察者也会认为同样的图案在视觉上突出，尽管有明确的指示，让他们忽略自己知道的东西，并采取一种无知的观点，但这种效应还是发生了</p><p>这些结果与其他最近发现的知觉和认知偏差对解释数据可视化模式的影响有关，改变自写作和更多认知任务的讲故事技巧会影响我们从视觉化中提取数据的方式，知识的诅咒已经在不同的认知领域得到了很好的研究，但是在视觉感知方面却很少。考虑到数据可视化对于信息探索、参与和理解的重要性，作者认为它是这种可能性的理想测试平台</p><p>演讲者、论文作者和数据分析师在交流数据模式时可能无法与听众沟通。目前的结果提供了一个经验证明，知识的诅咒可能是主要的责任</p><p>知识的诅咒是难以察觉和抑制的。批评提供了一个反馈循环，关于什么被沟通，什么没有被沟通。在一个强有力的知识诅咒案例中，一组可视化研究人员设计了一幅蒙德里安(Mondrian)绘画风格的公交时刻表可视化，并把它挂在学校的餐厅里。只有在得到反馈后，他们才意识到，许多观众根本没有意识到这是一个公交时刻表可视化，而是假设它是艺术作品</p><p>知识的诅咒还可能导致观众对数据集中给定的模式产生关注，让他们不太可能看到新的或替代的模式。因为可视化的设计可以强烈影响比较</p><p>此外，出于交流的目的，透视法的研究表明，人们通过将自己投射到陌生人身上，可以更准确地预测陌生人的反应。加强演讲者和听众之间的互动可以帮助演讲者衡量最有效的沟通方式，而不是压倒他们的听众</p><p>参与者是否发现某些数据模式很突出——并且认为其他人也一样——是因为他们知道这个故事，还是因为在视觉上引导他们看到一个图表中的特定模式?答案可能是”两者都有”，但未来的研究可能会梳理出这些因素的相对作用</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> bias </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Changes Everything</title>
      <link href="2020/09/18/dataChanges/"/>
      <url>2020/09/18/dataChanges/</url>
      
        <content type="html"><![CDATA[<p>这是看的第一篇关于可视化方向的顶会文章(VIS2019 Best Paper)，感觉跟CVPR的行文思路差别有点大，大致翻译了一下，可能会有些纰漏</p><blockquote><p>引用格式：J. Walny et al., “Data Changes Everything: Challenges and Opportunities in Data Visualization Design Handoff,” IEEE Trans. Vis. Comput. Graph., vol. 26, no. 1, pp. 12–22, 2020, doi: 10.1109/TVCG.2019.2934538.</p></blockquote><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>创建自定义可视化是一个具有挑战性的、多方面的问题，需要结合用于数据分析、设计和开发的技能和工具，设计人员和开发人员必须通过数据探索了解数据集及其特征，然后基于它设计数据映射、美学和交互，这些设计也需要实现和部署，通常是通过编写软件，有时，如果有足够的时间和资源，一个人可以完成所有这些活动，然而，对于具有有限时间线的更复杂的可视化项目，将这些活动分配给具有特定角色的人员是更可行的</p><p>角色的这种分布产生了在项目中从事不同角色的人员之间进行交接、编码和信息交换的挑战，以及跨角色交流领域知识的相关挑战，这个问题在一般的软件设计中已经很常见了，交互设计人员通常与软件开发人员是不同的，在过去的二十年里，出现了各种各样的专门工具，帮助交互设计师以减少图形设计和代码之间的摩擦的方式来勾画和原型化界面，像Adobe XD、InVision和Sketch这样的商业工具支持表达性和精确的视觉设计、动画的交互式原型化、过渡、交互，以及协作者的规范和资源的简化导出</p><p>不幸的是，对于可视化设计人员来说，这些工具缺乏对数据驱动设计的健壮支持，在实践中，许多具有编程能力的可视化设计人员仍然主要使用代码，使用像D3这样的库通过迭代原型设计来探索数据集，我们称之为”设计即开发”，但是，使用这些低级工具需要相当多的技术技能，并且可能会增加清晰、细化和完善可视化设计所需的时间和精力，对于大型可视化项目来说，这一比例很低，不仅涉及开发人员，还涉及交互设计人员、数据专家和客户，每个人都有自己的工具集和制度流程，在这些协作设置中，不同的设计目标和用于描述数据特征、设计可视化和开发应用程序的工具之间的差距可能会加剧由于缺乏数据驱动的支持而导致的问题，虽然小型灵活的团队可以迅速地处理意外问题，但这些问题很容易在大型团队中被放大</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-1.png"></p><p>作为设计团队的一员，作者利用了五个复杂数据可视化项目的经验，这些项目旨在大规模公开发布，在每个项目中，作者观察并参与了共同工作的设计人员和开发人员团队之间的交互，以确定数据的特征，创建初始设计，并将这些设计转化为可生产的应用程序，基于这些经验，作者强调了在数据可视化设计项目中设计人员与开发人员协作的具体挑战和机遇</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-2.png"></p><p>虽然在作者之前的其他人已经讨论了实际的可视化设计项目和设计研究，但本文的重点是不同的。本文专注于构建可视化的实际工作和协调，虽然项目雇佣了一些研究人员，但他们也雇佣了设计和开发人员。本文的项目还涉及到与数据提供商方面的项目协调员和数据专家的密切协调，这种复杂的结构以及不同团队在物理上和时间上的分离，提高了可视化设计过程中仍然面临的一些实际挑战的可见性，这项工作阐明了具有非常实际性质的问题，并且作者期望从事实际可视化工作的其他人经常会经历这些问题，作者认为本文的贡献为这个以从业者为导向的研究领域增加了价值，特别是考虑到可视化研究社区最近将从业者视为”精力、想法和应用问题”的关键来源</p><h2 id="可视化设计过程中的角色"><a href="#可视化设计过程中的角色" class="headerlink" title="可视化设计过程中的角色"></a>可视化设计过程中的角色</h2><p>可视化设计和开发需要几种独特的技能，包括以人为中心的设计、感知、评估、统计和图形编程方面的经验，”全栈”可视化设计人员的概念证明了这一传统观点，即开发人员能够执行全面的“数据争论、动态图形和大胆行动，然而，现实世界的可视化设计项目(尤其是大型的项目)通常包括各种团队成员，他们具有不同的和重叠的这些技能子集，随着项目的发展，这些团队可以被分割，设计和开发的责任被委派给那些技能集和首选工具越来越脱节的个人或团队，特别是，制度和学科的划分会导致早期设计任务(如数据分析、构思、创建模型和原型)和开发任务(如实现、测试、部署和维护)的划分</p><p>在实践中，设计人员和开发人员之间的学科划分非常明显。交互设计文献从多个角度研究了设计师和开发者之间的分歧，包括:设计师和开发者如何在合作中协调工作，它们是如何远程工作的，以及设计工具如何作为边界对象来缓解设计者对软件缺乏”材料”经验的问题，<a href="https://dl.acm.org/doi/10.1145/2998181.2998190">Maudet et al</a>最近的工作引起了人们对设计切换中的设计故障的关注，<a href="www.baidu.com">Leiva et al</a>对这一概念进行了扩展，指出了几种特定类型的故障——包括忽略关键细节、忽略边界情况和忽略技术限制——这些故障通常会导致项目的困难，包括设计人员和开发人员之间的交接</p><p>与其他交互式系统一样，新可视化的设计和开发需要大量的迭代，并且在设计从概念到实现的过程中涉及到多套工具之间的转换，然而，与交互设计中的其他工作不同，新可视化的形式本质上依赖于它们要传达的数据，因此，可视化设计的过程往往是一个复杂的、迭代的过程，需要经过多轮的数据检查、构思、创建和部署，这些活动给设计师带来了挑战，他们可能需要在交互工具之间反复转换，这些工具允许他们检查数据，探索各种各样的设计，以及更低层次的数据驱动开发和编码</p><p>随着项目的发展，设计、开发和部署的职责被划分为多个个人或团队，每个团队都有不同的技能集和优先级，这些问题就变得复杂起来，大型的多样化团队可以创建、部署复杂的可视化，并为其提供长期支持，然而，这种分工揭示了各种新的设计切换和迭代挑战，可视化设计的数据驱动特性可能使这些挑战复杂化</p><h2 id="可视化设计项目概述"><a href="#可视化设计项目概述" class="headerlink" title="可视化设计项目概述"></a>可视化设计项目概述</h2><p>作者对可视化设计和开发中的切换的思考是基于作为设计团队成员在2012年至2019年进行的5个大型数据可视化设计项目中的个人经验。每个项目都打算进行大规模的公开发布，涉及到6个月到几年的数据描述、设计和开发工作</p><p>对于每个项目，工作都是由外部客户指导的，他也是数据提供者。设计团队由设计师、可视化研究人员、博士后、研究生和实习生轮流组成，负责大部分的数据表征和可视化设计，在所有的项目中，至少有一个(通常是更多)的作者作为设计团队的成员直接参与了整个过程，一个独立的开发团队负责为最终的基于web的应用程序创建、部署和提供初始维护</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>—— 美洲开发银行的能源可视化</p><p>最早的项目是在2012年至2016年期间与美洲开发银行合作实施的，该项目制作了一套可视化文件，展示了美洲国家以及其他基准国家的能源发电、进出口、传输和消费情况，结果可视化从2013-18年公开托管，但到2019年不再可访问。在这个项目中，设计和开发团队比在其他项目中更紧密地结合在一起，两者都在数据描述、设计和开发中扮演着重要的角色</p><p>—— <a href="http://apps2.cer-rec.gc.ca/dvs/">能源未来</a></p><p>这个项目在2016年进行了4个多月，基于加拿大能源生产和消费的预测，开发了4个可视化版本，该项目的第二个7个月的迭代在2017年增加了第五个可视化项目，展示了加拿大各省和地区的能源需求预测变化</p><p>—— <a href="http://apps2.cer-rec.gc.ca/pipeline-incidents/">管道事件</a></p><p>该项目于2017年开发，历时8个月，开发出交互式可视化系统，支持对联邦监管管道上或周围发生的事故进行可视化探测</p><p>—— <a href="http://apps2.cer-rec.gc.ca/imports-exports/">能源进出口</a></p><p>另一个类似范围的项目在2017-18年进行了16个月，包括创建一组5个可视化图像，显示历史上加拿大各种能源产品的进出口情况</p><p>—— 管道条件</p><p>最近的项目在2018 - 2019年进行了18个月，重点是可视化政府监管部门对新管道建设的条件。在发表时，这个项目已接近完成，但尚未公开</p><h3 id="设计团队角色"><a href="#设计团队角色" class="headerlink" title="设计团队角色"></a>设计团队角色</h3><p>设计团队的成员需要履行各种与设计相关的角色，这个项目需要团队成员能够通过争论数据来描述数据特征，在现有的可视化工具，电子表格或代码中探索数据，以及理解特定的数据类型，所有的团队成员都需要创建和理解从数据到可视化表示的数据映射，包括不同程度的想法，基本的感知理解，以及可视化变量的应用知识，该项目还需要具有视觉设计技能的人员，他们能够设计图形、页面布局和排版，同时还要注意可访问性，该团队包括交互设计专家，包括原型设计和动画设计，同样，一些团队成员开发可视化原型来验证和演示设计，并设计文档中技术复杂的部分，所有的团队成员都需要与数据提供者和开发团队进行协作和沟通</p><p>在美洲开发银行项目期间，设计团队由一名主要可视化设计研究员和视觉艺术专业的学生组成(一个本科生和两个研究生)，开发团队由一名初级计算机科学研究员和一名博士生组成。这些团队以迭代的方式紧密合作，并且位于同一校园</p><p>在其余的项目中，设计和开发团队是分开的，设计团队由两名主要调查员(可视化研究员)、一名项目协调员、一名设计研究员、1-2名博士后可视化研究人员，2-3名本科或刚毕业的计算机专业学生，0-1名信息设计专业本科生，1-4名从事设计、开发和专门数据理解的全职员工，开发团队由位于同一城市的专业软件开发公司的5到9名成员组成。在所有项目中，数据提供者都来自不同的机构，并且与设计和开发团队在物理上是分离的</p><h3 id="分析合成过程"><a href="#分析合成过程" class="headerlink" title="分析合成过程"></a>分析合成过程</h3><p>通过正在进行的reflection过程，作者确定了本文中描述的与数据相关的挑战，通过这个过程，努力改进设计团队的工作和沟通实践，在每个项目中，团队保存了为会议、数据探索、构思草图、计划时间线和设计文档而产生的工件的记录，作者也经常反思团队内部的沟通和设计挑战，在整个过程中，团队使用基于日记和自传体研究的方法记录和审查了整个过程，设计团队的每个成员，作为他们个人实践的一部分，用笔记和图片记录他们的工作，后来，作为这个自传体过程的一部分，团队仔细地重新检查了基于日记的记录，并使用它们来确定差距和挑战</p><p>团队利用最初的观察创建了共享工具和过程来跟踪团队的进程，在每个项目的实施阶段，团队还与所有涉众举行了面对面的设计评审会议，最后，在后面的三个项目之后，团队组织了与数据提供者以及设计和开发团队成员的正式流程讨论，以帮助改进后续项目的协调，团队在所有会议上都做了详细的合作记录</p><p>基于这些思考，团队将更多的精力集中在余下的项目中，以改善团队内部和团队之间的设计交流，作为这项工作的一部分，作者的团队使用详细的个人记录、团队记录、设计移交文档和移交文档修订来记录会议和设计过程，通过利用这些详细记录，对本文中提出的挑战进行了详细的剖析。在讨论一个特定的挑战时，严格地重新检查每个设计被创建、传递、实现、再讨论、再实现和最终发布的时间戳过程</p><p>在反思过程中，注意到许多反复出现的切换挑战不仅仅是交互设计问题，而是根植于设计对数据的深度依赖，从这些反思中，团队综合了最突出的未解决的数据相关挑战，并使用来自项目的真实例子来说明它们。在可能的情况下，最初的反映由最接近实例问题的团队成员起草</p><h2 id="可视化设计与开发"><a href="#可视化设计与开发" class="headerlink" title="可视化设计与开发"></a>可视化设计与开发</h2><p>对设计项目中过程和交流的反思的一个产出是设计项目主要阶段的正式模型，此模型产生于与多方协调时需要使用的词汇表，并可作为在本文其余部分讨论的设计和沟通挑战的有用锚点</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-3.png"></p><p>在设计人员即开发人员的场景中，单个人员或小型团队可能会完成所有这些阶段，而对正式流程的需求较少。相反，在作者遇到的场景中——主要涉及多个不共享日常工作空间的团队——该模型强调角色和职责的分配，此外，它强调了经常可以促进阶段间通信的工件的种类</p><p>—— 项目概念</p><p>这个阶段发生在客户端，在设计团队直接参与之前。客户端为设计团队提供了项目的愿景和目标以及数据集。这些工件的交接范围从简单的电子邮件传递到客户端数据专家与设计和开发团队之间更复杂的全天研讨会</p><p>—— 数据特征化</p><p>在这个阶段中，设计团队探究并描述数据，根据项目愿景对分析进行优先级排序。这包括理解数据类型、数量和极值，以及数据和项目目标之间的关系，在某些情况下，设计团队建议使用更集中的数据集进行可视化，这个过程有时需要与客户端数据团队进行多次迭代，这个阶段通常涉及一些数据争论，但更类似于探索性数据分析或领域问题描述，作者使用了许多工具来支持这个阶段，包括电子表格、手工编码脚本和可视化探索软件，以及用于初步构思的手绘，最后，团队创建了数据特征摘要，通常通过当面演示将其交付给客户端数据专家，在这一阶段获得的见解和共享的理解是未来设计工作的基础</p><p>—— 可视化设计</p><p>设计阶段包括嵌套模型的抽象和编码/交互设计阶段，以及部分算法设计和广泛的视觉表示设计，这是一个两阶段的过程。首先，团队开发了一个可视化概念，并得到了客户的初步批准。然后，改进和完善了最终的设计，并通过可视化设计文档与客户和开发人员共享，团队在数据表征的基础上开发了一个数据映射，在Adobe Illustrator等工具中，团队非常依赖手绘和手绘插图，在某些情况下，使用图表生成工具和实用工具(包括RAWGraphs)和和使用库(如D3)的手工编码原型，团队主要使用adobeillustrator来开发演示设计——可视化的总体大小和布局。此外，使用各种工具开发交互设计，包括纸质原型、文本和草图描述，以及通用交互原型工具，最终的开发文档最初是PDF格式的，但后来演变为基于web的文档。最近的设计文档基于Idyll，它允许将模型、编码原型和解释性文本组合在一个文档中</p><p>—— 可视化开发</p><p>这个阶段由软件开发团队领导。作为设计团队，角色主要是保守的:回答关于设计的问题，当问题出现时建议重新设计，并验证实现是否按预期功能运行，这个阶段的大多数讨论都基于设计文档和实现可视化的日益完善的迭代</p><p>—— 部署和使用</p><p>由于可视化被部署为公共使用，软件开发团队承担了维护的任务，包括实现季度数据更新。如果数据更新包含现有设计不支持的意外值，则设计团队将参与其中</p><h2 id="使用数据进行设计时的挑战"><a href="#使用数据进行设计时的挑战" class="headerlink" title="使用数据进行设计时的挑战"></a>使用数据进行设计时的挑战</h2><p>基于反思和观察，以下描述了数据可视化设计过程中的六个缺口</p><p>C1：适应数据更改</p><p>数据更新可以对数据特性描述、可视化设计和开发阶段产生级联效应，因为可视化开发的所有方面都依赖于数据。数据提供者可能不清楚这些影响的影响</p><p>根据经验，在可视化开发过程开始之前，很少能得到完整的最终形式的数据，通常需要在过程的后期——有时甚至是部署后——进行数据更新，如果数据更改更改了数据特征描述或可视化设计中用于生成视图的数据，则数据更改的影响特别大，即使数据更改看起来是无害的，不会改变整个数据映射，它也可能会影响实现阶段，特别是在加载、聚合或准备数据的服务器端机制已经建立的情况下，例如，更改列名或单元符号可能会破坏现有的数据解析器</p><p>数据更新不一定是不可取的。它们可能提供更正或附加数据，并且它们可能反映出数据提供者为可视化发布数据的方式的积极发展。这种演变本身可能是由可视化设计过程的中间结果所推动的。因此，挑战不是完全避免数据更新，而是能够有效地处理它们</p><p>例如，在美洲开发银行项目的后期，设计和开发团队创建了一个成熟的，后期可视化设计，到目前为止，所有的设计决策都是基于客户提供的初始数据和团队的工作做出的，这种特性导致了一种设计，将不同能源的数据排列在一个圆上，显示能源输入(圆的上半部分)与能源产生和损失的关系</p><p>在这一阶段，新增的数据为基准国家比如中国等，其中单一能源(在这个例子中是煤)在视觉上压倒了其他来源的价值，这极大地改变了可视化的形式和易读性，将所有原始数据挤在图表边上的一个小切片上，并重叠了弧线和标签，考虑到设计过程的后期，没有足够的资源来迭代设计，最终的可视化结果与最初的概念有很大的不同</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-4.png"></p><p>后期的数据更新还会对可视化的感知方式造成微妙的变化。例如，在能源未来项目中，最初使用基于能源生产阶段的数据设计了按能源来源划分的需求份额的可视化，设计团队描述了数据，然后进入设计阶段，创建一个D3原型</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-5.png"></p><p>这里的重点是支持在规模上有数量级差异的省份之间进行比较，后来，将数据集改为基于终端能源需求的数据集，两个数据集的特征非常相似，所以设计工作继续，注意力转移到其他方面，然而，在新的数据集中有一个关键而微妙的区别:几乎所有的可再生能源都被包括在电力类中，而不是可再生能源类中，原始数据集中的可再生能源类别已经相当小，所以这种变化没有被注意到。虽然最终的可视化结果仍能准确地显示数据，但它很容易被误解，因为它没有清楚地传达这样一个事实，即电力类别也包括大多数可再生能源</p><p>C2：预测边界情况</p><p>设计者很难预测和测试可视化可能接收到的所有可能的交互输入组合。因此，很难预测图表设计或数据映射可能中断的情况</p><p>过滤或聚合等常见可视化交互实际上会实时更改数据映射，在带有实际原型的设计即开发场景中，这些相互作用可以在开发过程的早期进行测试，并根据需要调整设计，然而，当设计和开发分离时，设计师并不总是有工具或技能来完全测试输入的所有可能组合，因此，潜在的问题可能只会在许多设计决策最终确定之后的开发阶段才会被发现，在这个阶段，对设计的任何更改都可能导致重大的设计和开发工作，从而限制了调整可视化设计以减轻问题的可能方式</p><p>在能源进出口可视化设计中，设计团队开发了一个镜像图表，可以过滤以显示美国各州和加拿大各省任意组合之间的平均季度电价，此数据映射对于绝大多数视图都很有效，包括设计团队在创建初始文档时使用的测试数据的各种组，然而，一旦这种设计被实施，通过州和省的特定组合进行过滤就可以清楚地揭示出在最初的样本中被掩盖的异常值</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-6.png"></p><p>该设计方案受到柱状图尺寸固定和可用空间非常有限的限制，以及需要在可视化的其他部分保持数据映射的一致性，在开发阶段的后期，重新配置可视化的其他部分也是不可行的，最终，设计团队选择对这些异常值使用压缩的比例中断，这种解决方案使得不可能在尺度断点以上的大值之间进行直接的视觉比较，并减少了大值的视觉影响，但仍然在可用空间内传达相对的尺度差异，并将可视化其他部分的变化最小化，在管道条件可视化开发的后期，也出现了几个相关的规模问题，需要在实施过程中进行新的设计工作，在所有情况下，如果在设计过程中较早地识别了边界情况，那么整个设计可能会有不同的构思</p><p>C3：理解技术限制</p><p>设计人员可能没有意识到在开发阶段可能出现的所有技术限制和挑战。这可能导致设计可行性的不确定性，也可能在开发过程中触发更多戏剧性的修改</p><p>什么类型的软件和硬件限制可能对设计构成挑战并不总是清楚的。可视化设计人员往往将相当多的注意力集中在可视化映射的选择和提供有用和吸引人的交互体验上，与此同时，Web和应用程序开发人员更有可能被分派交付健壮、高效、符合标准的设计实现的任务，虽然合作者通常对其他人关注的领域有欣赏之处，但要意识到其他团队所面临的所有潜在问题是很困难的，从设计的角度来看，这可能会导致不确定性，特别是在提出独特或非传统的设计时，在我们的项目中，设计师经常试图通过原型化和用代码测试设计的新片段来减轻这种不确定性，然而，在开发过程中，我们仍然经常遇到技术问题</p><p>例如，在管道条件可视化的设计过程中，设计团队创建了几个复杂组件的详细工作版本，包括利用第三方物理引擎的交互式关键字浏览器，但是，开发团队在不同的约束条件下工作，包括跨浏览器兼容性、未来的代码可维护性，以及使用不同的底层web框架来实现站点的决定，因此，他们选择从头开始重新实现这些组件。这导致控制表面上与最初的设计相似，但行为却截然不同，因此，他们需要大量的额外改进，以实现已经存在于设计团队原型中的行为</p><p>通常，这些问题不是由于可视化库本身的限制，而是由于可视化实现的临近方面，如数据加载、跨浏览器兼容性和可访问性需求，在能源进出口项目的开发阶段，设计团队惊讶地发现政府授权的易访问性模板，其中的设计也应用于可视化的各个组件，这意味着可视化的每个可选择元素都将被一个带有主导色的笔触矩形框包围，这个后期的发现导致了设计的视觉美感与可访问性模板产生的明亮光晕之间的不匹配</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-7.png"></p><p>模板的使用还迫使设计团队重新访问数据映射，以确保可访问性覆盖使用的颜色不会与用于编码导入和导出数据的调色板冲突</p><p>C4：阐明数据依赖的交互</p><p>在构思和指定新的依赖数据的交互时，设计人员通常需要生成各种不同的数据精确视图，以多种状态显示可视化。这种额外的成本使得数据驱动的交互对于开发和与其他团队成员的交流具有挑战性</p><p>大多数可视化交互的结果取决于数据本身，通常，这些依赖于数据的交互生成可视化的新视图可能代表了数据的不同子集，数据的不同转换，或数据的不同编码，例如，过滤操作减少了要考虑的数据集。这可能导致剩余元素的位置或外观的改变，类似地，每次扫过(brushing)和链接交互都需要对应用于跨多个视图的一组非常特定的标记的编码进行更改，当手工或使用图形设计工具构建这些交互的原型时，设计人员必须手动管理和更新大量的单个数据元素，对这些视图之间的转换进行建模甚至更加困难，特别是当需要复杂的动画时</p><p>下图中的转换尤其具有挑战性，在这个示例中(来自管道事件项目)，与流可视化的简单交互可以添加一个额外的列，从而引入几十个甚至数百个新的弧</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-8.png"></p><p>这个单独的交互给视图增加了相当大的复杂性。出现多个分叉曲线，它们的位置和厚度都不同，都与之前的选择有关</p><p>使用传统的图形设计工具创建数据精确版本的视图是非常困难的，需要手工计算大量边缘的大小、位置和连接性，然后手工将它们添加到模型中，每当底层设计发生更改或数据更新时，这种开销就会成倍增加。即使是一些微不足道的变化，比如改变屏幕尺寸或配色方案，也需要手工修改这些设计，在这些视图之间指定过渡和动画也很困难，即使在使用交互式线框图和动画工具时也是如此，因为它们不包括对这些细粒度元素的数据绑定或动画支持，最后，因为这个视图只表示许多可能的应用程序状态之一，探索交互的有效性需要为其他视图复制该流程</p><p>不幸的是，通过编写能够支持这种交互的低保真交互原型来探索这种交互也需要付出相当大的努力，与平面设计工具相比，低保真度的交互原型也使得检查替代布局、字体、控件和设计的其他方面变得相当困难。在一个编码的原型中有效地测试像素级的交互和转换版本需要投入并实现整个设计</p><p>在这五个项目中，作者的团队经常采用两种方法，使用图形设计工具勾画和在视觉上美化组件和可视化视图，同时实现原型来测试交互的影响。团队还使用交互式图表工具，如Tableau和RAWGraphs来创建数据精确的可视化元素，然后可以导出到图形和交互设计工具中，以创建更丰富的模型。然而，这些工具之间的差距是相当大的，交互原型设计消耗了大量的设计</p><p>C5：通信数据映射</p><p>正确地实现数据映射需要比从可视化视图的模型中容易推断出的更多细节和精度。然而，当前的设计工具并没有很好地支持精确和完整的数据映射规范</p><p>从数据到可视化表示的映射是可视化最基本的方面。因此，设计人员在创建可视化映射时要能够将他们的意图传达给团队中的其他人，特别是开发人员，这一点非常重要，当前用于通信数据映射的选项是有限的，必须手动创建，如果可视化设计为便于非专业人员阅读，那么视图的静态呈现似乎就足够了，然而，示例视图可能无法捕获对实现目的很重要的许多细微差别和细节。例如，正确地将数据值映射到可视标记通常需要数据转换或查找，这可能涉及多个隐藏步骤(例如使用分类算法存储热图值)，此外，数据的复杂性可能使在提供的视图中显式地显示所有数据用例变得困难，特别是在涉及交互的情况下</p><p>这个问题的一个明显的例子出现在能源未来项目的后期</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-9.png"></p><p>概述此可视化的可视化设计文档包括在Adobe中创建的气泡图的一个静态视图，以及关于哪些数据列要映射到圆的大小的信息，可视化的设计师期望，但没有明确说明，”大小”将解释为面积，而不是直径，这种期望来自于他们自己对通用可视化指导方针的领域知识，然而，这一指导原则在本质上并不明显，尤其是对非专业人士而言。在这种情况下，最初的实现将数据映射到圆的直径，而不是它们的面积，这种绘图上的细微差别很难仅通过目测来发现，最终，偶然事件捕获了错误。然而，一旦发现了这种差异，就需要额外的开发时间来将映射更改为设计者最初打算的样子</p><p>管道条件项目的另一个示例表明，即使在面对面的对话中，数据映射规范也具有挑战性。</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-10.png"></p><p>该可视化的一部分显示了一个水平滚动的项目列表，在这个列表的两边都有一个栏表示左边和右边的项目数量，在一次面对面的设计评审会议上，由于分配给bar的空间非常小，人们提出了如何最好地将剩余项目的数量与bar的大小相匹配的问题，口头上商定了一个简单的解决办法，然而，下一个实现周期表明，事实上，即使这个简单的解决方案可以以多种方式解释:一个团队明白bar将被设置的最大大小根据条目的最大数量的物品，而对方明白的最大大小bar将代表一个固定值。这种混乱最终需要进行第三组后续讨论，以便团队达成共识</p><p>C6：跨迭代保存数据映射的完整性</p><p>由于很难系统地将实现与设计文档进行比较，因此在开发期间和开发之后，数据映射的误解或误用可能会被忽视</p><p>在实现设计时，各种因素可能会导致差异，包括错误、数据更新、初始设计中的不一致以及对数据映射的误解。部分原因是实现与设计文档是分开的，测试实现对设计的遵守程度的主要方法是视觉检查和与原始规范的比较。此外，实现的每一次新的迭代通常都会引入大量的小更改，这使得手动跟踪哪些检查了，哪些没有检查，或者知道什么时候是标记问题的合适时间都变得很困难，即使所有各方都认识到保存数据映射的重要性，在任何给定的迭代中，仅对实现进行视觉检查可能不会揭示对设计或数据映射的误解</p><p>图中的示例显示了可视化设计文档的一小部分与该设计的实现之间的比较。与表示设计和数据映射相关的许多小差异是明显的，包括排版和对齐问题。此外，图例中的一组蓝色箭头指向上，但应该指向下，以便在可视化的其余部分中与向下的导出箭头保持一致</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/dataChanges-11.png"></p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们强调的挑战直接源于可视化和驱动它们的源数据之间的内在联系，与其他类型的界面相比，数据对元素的可见性、布局和外观的影响要大得多。这些工具的查看者不仅与界面交互，而且与数据交互，因此，在考虑性能和交互能力时，开发人员和软件工程师还必须处理数据集的实际限制，然而，对于设计师来说，预期给定数据集的规模和交互的所有含义仍然是一个挑战。在设计过程中和之后，数据集可能会被多次更新，这一事实放大了这一点，总之，这些挑战为研究和工具创建提供了各种机会，这些研究和工具创建可以特别支持可视化设计过程，对个人和协作团队都是如此</p><h3 id="数据特征化"><a href="#数据特征化" class="headerlink" title="数据特征化"></a>数据特征化</h3><p>在为可视化设计工作做准备时探索和描述新数据集的过程与数据分析有很多共同之处，因此许多现有的数据分析工具可以在这个领域中使用，数据特征的更改会对最终可视化结果产生重大影响，因为可视化设计选择通常反映给定数据集的形状和参数。然而，新数据对可视化的健壮性的影响程度在数据更新过程中可能并不清楚</p><p>数据描述工具可以帮助设计人员更好地理解数据从一个版本到下一个版本是如何变化的，以及这些变化如何改变可视化的设计，从而消除这种脱节，这可以包括用于突出显示数据列名称、极值和数据统计分布的更改的工具，或者用于基于当前值分布模拟未来可能发生的更改的工具，最近在数据挖掘工具箱(如Orange或DataTours)中的离群点检测和分析的半自动方法上的工作可以提供一个有用的起点，类似地，用于快速比较不同数据集中的值分布的可视化工具可以帮助设计人员更容易地检测出有问题的变化，而不需要依赖统计摘要</p><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>数据驱动可视化意念：我们遇到的许多挑战基本上都与构想数据驱动的可视化设计的挑战有关。现有的用于手工基于矢量的图形设计的商业工具(如Adobe Illustrator)对创建复杂的、数据驱动的视图支持很少，而可视化探索和生成工具(如Tableau或RAWGraphs)对定制可视化和交互的支持有限，与此同时，编程工具和较低级别的库要用作快速的创意平台，可能会给非程序员带来挑战。幸运的是，最近的项目如Data Illustrator，Data Ink和数据驱动指南强调了更具表现力的数据驱动图形设计工具的潜力，我们经历的几个挑战强调了在这个领域进一步工作的必要性。使用数据进行设计的更直接、动态和表达性的工具可以促进对不同设计方案的快速探索，甚至在面对变化的数据时也是如此，类似地，对datadriven设计替代方案进行更快速的探索，可以更容易地发现意外的边界情况(C2)和原型依赖数据的交互(C4)</p><p>在工件创建不能统一到一个创作平台的地方，更好的切换工具还可以为设计人员和开发人员提供跨多个系统同步工件的机会。像Hanpuku这样的工具已经探索了连接Adobe Illustrator的图形设计表现力和D3的数据驱动原型功能，然而，在这类现有工具之间设计双向工作流通常需要折衷——通常会交叉每个工具的限制，限制可以转换的功能部分。这表明，单向切换工具，像那些现在在交互设计中广泛使用的工具，更有可能是第一步</p><p>—— 数据驱动的交互原型设计</p><p>在可视化设计中构建数据驱动交互的原型对于探索不同的交互选项、确保这些交互选项的可伸缩性和可理解性以及与开发人员沟通交互设计(C4)非常重要，然而，数据驱动的交互对于原型来说可能很复杂，因为一个交互可能同时导致设计中大量数据驱动元素的更改。不幸的是，商业上可用的用户界面原型工具不能解决这个问题，商业交互设计工具可以直接使用静态模型生成交互和转换的原型，甚至还为数据驱动的原型设计提供了一些有限的支持——例如填充用户配置文件或信息列表，但是，它们几乎不支持创建可视化视图，这些视图的布局、外观和交互性都是由数据驱动的，因此，新工具仍然有机会允许设计师通过在现有可视化工具之上的自举或通过新的创作界面，更明显地原型化和测试潜在的交互</p><p>—— 数据映射文档</p><p>沟通和记录设计意图不仅对向开发团队解释可视化设计很有用，而且在与其他团队成员或涉众沟通以及生成项目文档时也很有用。挑战C5(数据映射)强调的一个机会是为数据映射通信设计工具和方法，这样的工具将支持数据结构与其图形表示之间关系的显式通信，提供足够的细节来传递所需的任何转换、计算和算法</p><p>现在仍需要一些数据映射工具，这些工具对于没有编程技能的设计人员来说是可以访问的，但是它们仍然能够传达数据映射的细微差别，以足够的细节来以编程的方式再现数据映射</p><p>—— 数据可视化设计文档</p><p>尽管数据映射是可视化的基础，但它们只是可视化设计的一部分。最终，任何数据映射都必须作为更大的设计文档的一部分进行交流，设计文档也要捕捉图形表示(包括布局、排版和颜色)以及交互。虽然目前这个文档通常是特别的和非正式的，但是用于捕获和交流设计细节的更系统的工具在大型可视化设计项目中可能是有价值的，鉴于可视化设计的高度可视化和交互性，这类文档的一个基础可能是可探究的解释或其他交互式文档。Bret Victor推广的这种格式在数据分析实践中越来越多地使用，而最近的编程工具，如Observable、litvis和Idyll，可能为创建和记录可视化设计提供了良好的平台</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>正如挑战C6(完整性)所强调的，任何根据设计文档对已实现的可视化进行测试的人都必须能够识别预期设计和实现之间的差异，这一点很重要。此外，他们应该能够区分由于数据差异造成的差异、由于不完整实现造成的差异以及由于沟通错误或错误造成的无意差异。最重要的差异是与数据映射相关的差异(c5 -数据映射)，但是，与屏幕大小、对齐方式、布局、排版和非数据颜色相关的表示差异也会造成影响，在这些情况下，支持可视化之间的差异和可视化比较的新工具可能特别有价值。另一方面，交互差异可能更难以检测，但当它们影响对数据的理解时，就特别重要。模拟最终交互的工作可视化原型可以减轻其中一些问题，但只有在设计和开发团队的技术约束提前对齐时(c3 -约束)</p><h3 id="实现可视化设计的多种途径"><a href="#实现可视化设计的多种途径" class="headerlink" title="实现可视化设计的多种途径"></a>实现可视化设计的多种途径</h3><p>除了第一个项目之外，数据编译、可视化设计和开发之间的物理和时间分离都比较高，并不是所有的可视化项目都以这种方式配置。一些项目需要多个同时工作的人担任高度专业化的角色(例如在新闻编辑部中，记者、数据分析师、设计师和程序员可能会紧密合作)，与此同时，许多项目仍然需要单独的设计人员和开发人员同时承担许多角色。有大量的文献讨论管理设计团队的沟通，包括开发任务、团队和过程的共享思维模型，分享有意义的制造活动，以及管理设计工作的组织，因此，很明显，技术只是帮助缓解沟通挑战的一种方式，而流程、沟通框架、教育、环境、相互信任/舒适度，以及增加的面对面时间都是影响设计过程的因素</p><p>我们团队的分离可能会放大，并使我们更容易识别我们阐明的一些挑战，然而，我们所确定的挑战与数据渗透到设计过程各个方面的方式更为密切相关，并且在某种程度上，无论团队配置如何，这些挑战都将继续存在，正如我们所展示的，数据几乎影响可视化设计的每个方面。对数据分布的一次更新就可以完全改变可视化的有效性(C1-变化)。在设计中加入标准数据交互会增加需要考虑的应用程序状态的数量，并使找到边界情况(C2-边界情况)变得更加困难，此外,基本依赖可视化的数据可能需要一个健壮的和复杂的后端实现,并不总是很明显的约束在设计阶段,很难预测技术挑战或提供编码的原型,可以很容易地转换成最终的实现(C3-约束)，与数据的交互原型化也可能涉及繁琐的计算和从视图到视图的重大更改(C4-交互)，同样，明确和测试从数据到可视化表示的映射是一项基本而复杂的任务，传统的用户界面设计工具并没有很好地支持这项任务<br>(C6-完整性 C5-数据映射)，在我们之前的其他人已经明确了设计切换的困难，包括明确的边界情况，然而，可视化设计中的一切——映射、平面设计和交互设计——都深深依赖于数据，因此，数据增加了这个过程的每一步的复杂性找到并处理支持复杂性的机会可以使可视化设计过程更有效、更有表现力，并且对具有各种技能的人更容易访问</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基于对我们作为设计师在几个大型协同可视化项目的数据描述、可视化设计和开发阶段的经验的反思，我们强调了数据从根本上引入到设计过程中所增加的复杂性，与数据相关的挑战跨越了设计的所有阶段，包括适应后期数据更改、预测边缘情况、明确依赖数据的交互、通信数据映射，以及在实现中保持数据映射的完整性，这指出了创建通过特定数据相关特性直接支持可视化设计过程的工具的几个机会。创建这些功能更强大的工具可以使设计过程更加健壮、高效，并对各种设计角色的人具有可访问性</p>]]></content>
      
      
      <categories>
          
          <category> 💄VIS胭脂铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> VIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Causal TDE Inference [因果效应]</title>
      <link href="2020/09/14/causalTDE/"/>
      <url>2020/09/14/causalTDE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2002.11949">Paper Download Address</a></p><p><a href="https://github.com/KaihuaTang/Scene-Graph-Benchmark.pytorch">Code Download Address</a></p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>场景图生成(SGG)——图像中对象和其关系的视觉检测任务，似乎从未真正实现其承诺：以一种全面的视觉场景表示支持高级任务的图推理，如视觉字幕和VQA</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-1.png"></p><p>图中展示了SOTA模型的SGG结果，可以发现在几乎所有被检测到的物体之间的视觉关系大多是琐碎的，信息量也不大，如图c，在二维关系中除了near，has和on之外，我们所知甚少，这种严重偏见的生成来自于有偏见的训练数据，即存在长尾效应，因此，要执行合理的图推理需要区分出更细粒度的关系，比如将near替换成behind/in front of，将on替换成parking on/driving on</p><p>然而，我们不应该责怪有偏见的训练，因为我们的视觉世界本身和我们描述它的方式都是有偏见的：比如人带着包的情况总归是比狗带着包的情况要更多一些的(长尾理论 long-tail theory)，对于人和桌子的关系，near的标注总比eating on要简单的多的(有限理性 bounded rationality)，我们更喜欢说person on bike而不是person ride on bike(语言或表述偏见 language or reporting bias)，事实上，大多数有偏见的注释可以帮助模型学习到良好的上下文检验，过滤掉不必要的搜索候选项，比如apple park on table和apple wear hat</p><p>对于机器和人来说，决策是内容(内因)和上下文(外因)的协作，在大多数SGG模型中，内容是主体和客体的视觉特征，上下文是主体-客体联合区域和成对对象类的视觉特征。而我们人类，在有偏见的天性中出生和成长，接受好的内容同时避免坏的，根据内容做出公正的决定，其内在机制是因果性的(causality-based)，决定取决于内容主要的因果效应，而非语境的副作用，而机器通常是基于概率的(likelihood-based)，预测相当于在一个巨大的可能性表中查找内容及其上下文，作者认为学习的关键是教会机器识别主影响和副作用</p><p>这篇文章中，作者建议赋予机器反事实因果的能力，以追求无偏预测当中的”主效应”：即如果我没有看到内容，我还会做出同样的预测吗</p><p>反事实存在于”I see”的事实和”I had not”的想象之间，事实和反事实的对比可以自然地移除内容的偏见，因为上下文是两个选项之间唯一没有改变的东西</p><p>为了更好地说明似然因果关系和反事实因果关系之间深刻而微妙的区别，举个简单的例子a dog standing on surfboard，如图所示，一个有偏见的训练会致使模型预测词on，请注意，尽管剩余的选择并不都是完全正确的，但由于这种偏见，它们仍然有助于过滤掉大量不合理的选择，为了更细致地观察它在语境偏差中的关系，作者在做的事情本质上就是在比较原始场景和反事实场景，消除dog和surfboard的视觉特征，而保持其它的视觉特征不动，这种做法可以专注于关系的主要视觉效果而不失去背景</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-2.png"></p><p>作者提出了一种基于因果推理中全直接效应(TDE)分析框架的无偏SGG方法，下图中展示了事实和反事实两个场景的潜在因果图，更正式的介绍会在下文给出，现在可以简单地将节点理解为数据特性，将定向的链接理解为数据流</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-3.png"></p><p>这些图提供了计算TDE的算法公式，准确地实现了反事实思维。提出的TDE显著改进了大多数谓词，并且，改进性能的分布不再是长尾的，这表明改进确实来自于提出的方法，而不是更好地利用了上下文偏差，TDE是一种与模型无关的预测策略，因此适用于各种模型和融合技巧</p><p>此外，作者提出了一个新的SGG框架，可以更全面地评估SGG，出了传统的评估方法，还包含了偏见敏感的方法：mean Recall，以及一种更全面图级别度量的句子到图的检索，在这个框架和几个主流的baseline下，作者验证了现有的模型存在严重的偏差，证明了无偏预测相比于其它去偏策略的有效性</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="场景图生成"><a href="#场景图生成" class="headerlink" title="场景图生成"></a>场景图生成</h3><p>SGG在计算机视觉界受到越来越多的关注，这是由于其对于下游视觉推理任务可能带来的革命，大多数现有的方法都在努力寻找更好的特征提取网络，<a href="https://arxiv.org/abs/1711.06640">Zellers et al</a>首先引入SGG的偏差问题，提出了无偏度量(mean Recall)，但是他们的方法仍然局限于特征提取网络，使得有偏的SGG问题得不到解决，<a href="https://arxiv.org/abs/1902.00313">最相关的工作</a>只是删除了训练集中那些显性且易于预测的关系</p><h3 id="无偏训练"><a href="#无偏训练" class="headerlink" title="无偏训练"></a>无偏训练</h3><p>在机器学习中，偏见问题已经被研究了很久，现在的去偏方式大概可以分为三类：1.数据扩展或者重采样；2.通过精心设计的训练或者损失函数来实现无偏学习；3.从无偏表示中分离有偏表示。文章中提出的TDE输出第三类，主要区别在于TDE不需要训练额外的层来建模偏见，而是直接通过英国图上的反事实方法将偏见从现有模型中分离出来</p><h3 id="干预分析"><a href="#干预分析" class="headerlink" title="干预分析"></a>干预分析</h3><p>干预分析又被称为效应分析，广泛应用在医学，政治，或心理研究，作为研究某些治疗或政策效果的工具，然而，多年来它一直被计算机视觉界所忽视。最近很少有研究试图赋予模型因果推理的能力</p><h2 id="因果图中的有偏训练模型"><a href="#因果图中的有偏训练模型" class="headerlink" title="因果图中的有偏训练模型"></a>因果图中的有偏训练模型</h2><p>作者在下图中以因果图的形式总结了SGG框架，这是一个有向无环图，说明一组变量如何通过因果关系相互作用，它揭示了因果关系背后的数据和变量如何获得他们的值</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-4.png"></p><p>在操纵节点值和修剪因果图进行反事实分析之前，我们首先在图形视图中回顾传统的有偏见的SGG模型训练</p><p>图(b)中的因果图适用于各种SGG方法，因为它是高度通用的，对具体的实现没有限制，我们来研究三个有代表性的模型公式：传统的VTreansE，SOTA模型MOTIFS以及VC-Tree，用节点和链接来表示</p><p>Node I(Input Image &amp; Backbone)：一个预训练的Faster R-CNN被固定在这个节点，其输出了bbox的集合以及图片I的特征图M</p><p>Link I $\to$ X(Object Feature Extractor)：其首先提取ROI特征，以及暂定的对象标签L，然后像MOTIFS或VCTree一样，可以使用以下模块为每个对象编码视觉上下文</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-5.png"></p><p>MOTIFS用BiLSTM来实现而VCTree采用BiTreeLSTM，而早期工作诸如VtransE则简单地采用了全连接层</p><p>Node X(Object Feature)：成对的对象特性X从每对x中获取值，作者将i和j表示的组合表示为下标e：$x_e=(x_i,x_j)$</p><p>Link X $\to$ Z(Object Classification)：每个对象的微调标签通过$x_i$计算:</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-6.png"></p><p>MOTIFS和VCTree采用LSTM和TreeLSTM作为解码器来捕捉对象标签的同现性，每个LSTM/TreeLSTM单元格的输入是特征和前面的标签的连接，而VTransE则使用常规的全连接层作为分类器</p><p>Node Z(Object Class)：包含了一对独享标签的独热编码：$z_e=(z_i,z_j)$</p><p>Link X -&gt; Y(Object Feature Input for SGG)：对于关系分类，两两特征X由以下模块合并为联合表示：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-7.png"></p><p>同样，MOTIFS和VCTree在这一步采用了Bi-LSTM和Bi-TreeLSTM，然后连接这对对象特征，VTransE则采用全连接层和元素级减法来完成特征合并</p><p>Link Z $\to$ Y(Object Class Input for SGG)：在该链接中通过联合嵌入层计算语言先验$z_e’=W_z[z_i\otimes z_j]$，其中$\otims$为每对对象标签产生独热编码R</p><p>Link I $\to$ Y(Visual Context Input for SGG)：此链接提取上下文联合区域特征 $v_e’=Convs(RoIAlign(M,b_i\cup b_j))$，其中$b_i\cup b_j$表示两个RoI的合并box</p><p>Node Y(Predicate Classification)：最终的预测结果logits Y由三个分支的输入通过一个融合函数得到</p><p>Training Loss：所有的模型都使用了传统的目标标签和谓词标签的交叉熵损失进行训练，为了避免任何单一的链接自发地支配了logit $y_e$的生成，特别是$Z \to Y$，我们进一步增加了辅助交叉熵损失，单独预测每个分支的$y_e$</p><h2 id="因果效应的无偏预测"><a href="#因果效应的无偏预测" class="headerlink" title="因果效应的无偏预测"></a>因果效应的无偏预测</h2><p>一旦完成上述训练，就可以通过模型参数了解变量之间的因果依赖关系，传统的偏见预测只能看到图像整个图像的输出，不知道特定的一对对象如何影响它们的谓词，因果推理鼓励跳出黑盒子去思考，从图形的角度看，不再需要将整个图形作为一个整体，我们可以在因果图上操作几个节点，看看会发生什么，比如切断链接I $\to$ X，并对X指定一个虚拟值，然后观察谓词是什么，上述操作被称为因果推理中的干预，接下来，我们将通过干预及其诱导的反事实来进行无偏见的预测</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>干预：可以表示为$do(\cdot)$，它删除变量的所有输入链接，并要求变量取某个值，$do(X=x)$表示X不再受其因果父母影响</p><p>反事实：意思是”与事实相反”，并进一步赋予变量”世界冲突”的值组合，比如在X上执行了干预$do(X=\bar{x})$，Z依旧采取原来的z值就像x时一样</p><p>因果效应：使用pairwise对象特性X作为进行干预的控制变量，目的是评估其效果，如果这对对象不存在，则不存在任何有效关系，观测到的X记为x，干预未见值记为$\bar{x}$，设置为训练集的平均值或是零向量</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-8.png"></p><p>在执行干预$X=\bar{x}$之后，logits Y可以计算为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-9.png"></p><p>u是SGG的输入图片，按照上面的符号，原来的和反事实的Y被记为$Y_x(u)$和$Y_{x,z}(u)$</p><h3 id="总直接影响-DTE"><a href="#总直接影响-DTE" class="headerlink" title="总直接影响(DTE)"></a>总直接影响(DTE)</h3><p>与趋向于有偏见的静态似然不同，无偏见的预测于观察结果$Y_x(u)$和其相反的替代结果$Y_{x,z}(u)$之间的差异，后者是我们想要从预测中去除的特定背景偏差。直观上讲，我们所追求的无偏预测是从空白到观察到的具有特定属性，状态和行为的真实物体的视觉刺激，而不仅仅是来自环境和语言先验，这些物体的特定视觉线索是更细粒度的，信息更客观的预测的关键，因为即使整个预测偏向于dog on surfboard，”straight legs”会使得standing on比sitting on更具说服力，在因果推断中，上述预测过程可以被计算为总直接效应(TDE):</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-10.png"></p><p>第一项来自原图，第二项来自反事实</p><p>注意到这里还有另一项影响，总影响(TE)，容易和TDE混淆，TE并不像TDE一样推导反事实的偏见$Y_{x,z}(u)$，TE允许X所有的子节点通过干预$do(X=x)$改变，因此TE可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-11.png"></p><p>主要差别是$Y_{\bar{x}}(u)$不受原对象标签的限制，所以TE仅取出了数据集中的一般偏见，而不是我们所关心的干预导致的特定偏见</p><p>最后，用TDE来替代传统的一次预测，本质上是二次思考，得到无偏预测</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验采用Visual Genome (VG)数据集，测试了三个model：VTransE，MOTIFS和VCTree，以及两种融合方法SUM和GATE，所有模型共享相同的超参数和预训练检测器模型</p><p>文中提出的SGG框架有三种评价方式：</p><ol><li><p>Relationship Retrieval (RR)：这个评价可以被分为三个子任务：(1)Predicate Classification (PredCls): 以GT的bbox和表现作为输入；(2)Scene Graph Classification (SGCls)：使用没有标签的bbox；(3)Scene Graph Detection(SGDet)：从零开始检测SGs，RR的传统评价方法是Recall@K(R@K)，由于存在报道偏见，被本文所弃用，为了有价值的”tail”而非微不足道的”head”，本文采用了mean Recall@K(mR@K)，mR@K分别检索每个谓词，然后对所有谓词的R@K取平均值</p></li><li><p>Zero-Shot Relationship Retrieval (ZSRR)：ZSRR和RR有三个相同的sub-tasks</p></li><li><p>Sentence-to-Graph Retrieval (S2GR)：该算法利用图像标题作为查询语句，检索以SGs表示的图像，RR和ZSRR都是三级评价，忽略看图形级的一致性，因此，作者设计了S2GR，使用人类描述检索SGs，作者并没有使用图像字幕和VQA这样的代理视觉语言任务，因为他们的实现有太多和SGG无关的组件，且数据集受到自身偏见的挑战，在S2GR中，检测到的SGs(使用将SGDet)作为图像的唯一表示，切断了对黑盒视觉特征的所有依赖，对SGG的任何偏差都会敏感地破坏SGs的相干性，导致检索结果较差，举个例子，如果walking on被检测为偏见选项on，则图片会和sitting on以及laying on的图片混淆</p></li></ol><p>实验结果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-12.png"></p><p>可视化结果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/causalTDE-13.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> 2020 </tag>
            
            <tag> debias </tag>
            
            <tag> SGG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAMEN [early fusion]</title>
      <link href="2020/08/28/RAMEN/"/>
      <url>2020/08/28/RAMEN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1903.00366">Paper Download Address</a></p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>VQA问题要求模型理解并推理视觉-文本内容以回答端到端的关于图片的问题，正确回答这些问题需要模型具备许多能力比如：目标定位，属性检测，活动分类，场景理解，推理，计数等等，第一个VQA数据集包含了真实世界图片以及一系列问题和对应的答案，然而，许多高性能算法只是利用了偏见和表面的相关性，而没有真正理解视觉内容，后来的自然图像VQA数据集努力解决这个问题，VQAv2通过将每个问题与互补的图像和不同的答案练习起来减少了某种形式的语言偏差(bias)，TDIUC分析了多种问题和罕见答案的泛化，CVQA测试了概念的组合性，VQAcpv2测试了在训练集和测试集分布不同时的性能</p><p>虽然后来的自然图像数据集已经减少了偏差，但这些数据集中的绝大多数问题并没有严格测试推理技能，所以有了合成数据集对这一方面做了一个补充，为了正确评估算法的健壮性，这些数据集的创建者认为算法应该在两个领域进行测试</p><p>然而，几乎所有近期的文章都只是在两个领域的其中之一做报告，CLEVR上表现最好的算法并没有在真实VQA数据集中测试，反之亦然，作者发现大多数方法并不能同时在两个领域取得好的表现</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-1.png"></p><p>文章的主要贡献如下：</p><ol><li>在8个VQA数据集上对5种SOTA算法进行了比较，发现许多算法不能跨域泛化</li><li>VQA算法通常使用不同的视觉特征和回答词汇，这使得评估性能变得非常困难，作者尝试标准化扩模型使用的组件，比如所有算法采用相同的视觉特征，这需要优化合成场景使用候选区域的方法</li><li>发现大多数VQA算法都没有理解real-word(?)图像和执行合成推理的能力。所有这些方法在泛化测试中都表现不佳，这表明这些方法仍然在利用数据集的偏差</li><li>提出了一种新的VQA算法，在所有数据集上与SOTA方法相媲美，并且总体上性能最好</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="VQA数据集"><a href="#VQA数据集" class="headerlink" title="VQA数据集"></a>VQA数据集</h3><p>[VQAv1/VQAv2] VQAv1是最早的，端到端的VQA数据集，其中存在很多语言偏差(bias)，有些问题与特定的答案紧密相关，VQAv2通过在每个问题上收集导致不同答案的互补图像来减少这种语言偏差，但是其他类型的语言偏差仍然存在，例如推理问题相对于检测问题来说很少</p><p>[TDIUC] 通过将问题分成12种不同的类型，从而实现细致入微的任务评估，试图解决问题类型中的偏见，它有度量来评估跨问题类型的泛化 </p><p>[CVQA] 是VQAv1数据集的重组，用以测试模型的泛化能力，biubiu训练集中包含绿色的盘子和红色的灯，那么测试集中就是红色的盘子和绿色的灯</p><p>[VQACPv2] 是VQAv2的一个重组，答案分布在测试集和训练集中是不同的，因为测试和训练集的偏差(bias)是不同的，所以如果能够在这个数据集上表现良好，说明模型比较好地克服了偏差</p><p>[CLEVR] 是一个人工合成的数据集，包含虚拟场景和简单的几何图形，数据集中的问题通常需要一长串的复杂推理，问题是由程序生成的，包含五个类型：属性查询，属性比较，是否出现，计数和数字比较</p><p>[CLEVR-Humans] CLEVR中的问题从程序提供变为了人类提出</p><p>[CLEVR-CoGenT] 测试处理未知组合概念和记忆旧组合概念的能力，其包含两个部分：CoGenT-A以及CoGenT-B，包含互相排斥的形状+颜色组合，如果在CoGenT-A中训练的模型在CoGenT-B中不需要微调就可以表现良好，则说明了模型具备泛化能力，如果在CoGenT-B上微调过的模型依旧在CoGenT-A中表现良好，说明模型具有概念组合记忆能力</p><p>作者认为评估VQA系统需要同时测试自然和人工的数据集</p><p>VQA算法相关介绍略</p><h2 id="RAMEN-VQA"><a href="#RAMEN-VQA" class="headerlink" title="RAMEN VQA"></a>RAMEN VQA</h2><p>作者提出了Recurrent Aggregation of Multimodal Embeddings Network (RAMEN)，既可以适应复杂的自然场景，也能够回答复杂的合成推理链问题，模型框架如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-2.png"></p><p>模型分为三个阶段：</p><ol><li>[视觉和语言特征的早期融合] 已知视觉和语言特征的早期融合(early fusion)有助于合成推理，作者提出了通过连接空间定位的视觉特征和问题特征的早期融合</li><li>[通过共享映射学习双模态嵌入] 连接的视觉+问题特征通过共享网络传递，产生空间定位的双模态嵌入(bimodal embeddings)，这个阶段帮助网络了解视觉特征和文本特征之间的相互关系</li><li>[已学双模态嵌入循环聚合] 作者使用双向门控循环单元(bi-GRU)来聚合场景中的双模态嵌入，最终的前向和后向状态需要保留回答问题所需的所有信息 </li></ol><p>SOTA的自然图像VQA模型使用注意力机制或者双线性池化方法，RAMEN在没有这些机制的情况下也能够达到相同的效果，同样的，相比于在CLEVR数据集上的SOTA模型，RAMEN不适用任何推理单元和预定义模块，然而，实验证明它有合成推理的能力</p><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>RAMEN的输入是一个问题嵌入q和n个图片候选区域$r_i$，候选区域包括视觉特征以及空间位置，RAMEN首先将每个候选区域和问题向量连接，随后进行批归一化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-3.png"></p><p>$\oplus$表示矩阵连接</p><p>随后$c_i$向量将通过一个函数F，混合特征以产生双模态的嵌入$b_i=F(c_i)$，F是残差连接的MLP</p><p>然后将双模态嵌入和原始问题嵌入连接</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-4.png"></p><p>A函数采用了bi-GRU，A的输出由前向GRUs和后向GRUs的最终状态连接而成，最后将RAMEN嵌入a传入预测答案的分类器</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>[输入表示] 通过预训练的GloVe向量将问题表示为300-d的嵌入，然后用GRU对其进行处理，得到一个1024维的嵌入问题，每一个候选区域[R2560]包含bottom-up的2048-d的cnn特征，以及512-d的空间信息，将每个候选区域划分为$16\times16$带有坐标信息的网格，平展为512-d向量</p><p>[模型配置] F采用了是4层的MLP，包含1024单元，采用swish非线性激活函数，在第2,3,4层有残差连接，聚合器A是一个单层的bi-GRU，包含1024维隐藏状态，所以前向和后向状态的联合产生了2048维的嵌入，嵌入通过一个2048维全连接的swish层进行投影，然后是一个输出分类层，该层在数据集中对每个可能的答案都有一个单元</p><p>[训练细节] RAMEN是用Adamax优化的，follow了BAN，在前四个epoch使用渐进的学习速度热身($2.5\times epoch\times 10^{-4}$)，在epoch为5到10采用$5\times 10^{-4}$，然后以0.25每两个epoch的速率衰减，minibatch的大小为64</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>和两个领域的SOTA结果的比较，蓝框表示表现前三</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-5.png"></p><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-6.png"></p><p>样例展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RAMEN-7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTI-VQA [知识蒸馏]</title>
      <link href="2020/08/27/CTIVQA/"/>
      <url>2020/08/27/CTIVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1909.11874">Paper Download Address</a></p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>传统的VQA模型分为两类，一类是自由形式回答的Free-Form Opened-Ended(FFOE)，另一类是多选题Multiple Choice(MC)</p><p>两种VQA任务的传统方法主要是学习图像和问题的联合表示，而对答案的处理都是”被动”的，即只将答案视为分类目标，但是一个答案与其对应的问题图像输入具有很高的相关性，因此，从这三个输入中联合而明确地提取信息将会给出一个非常有价值的联合表示，因此作者在这篇文章中提出了一种新的三线性交互模型，以学习三种输入(图片，问题，答案)之间的高水平的关联</p><p>三线性交互的主要难点是维数问题，计算量大，内存需求大，为了解决这个问题，作者提出了利用PARALIND分解将一个大张量分解为小张量，从而减少了计算量和内存的使用</p><p>FFOE VQA中的答案信息只在训练阶段提供，在测试阶段不提供，为了将三线性交互应用于FFOE VQA中，作者提出利用知识蒸馏将三线性模型转化为双线性模型，提取的双线性模型只需要对图像和问题作为输入，因此可以用于测试阶段，而对于MC VQA，则可以直接利用三线性模型，作者在TDIUC，VQA-2.0和Visual7W上都取得了SOTA的结果</p><p>文章的主要贡献如下：</p><ol><li>提出了一种新的三线性交互模型，该模型能同时学习图像、问题和回答信息在VQA任务中的高水平联合表示</li><li>利用PARALIND分解来处理三线性相互作用中的维数问题</li><li>为了使提出的三线性交互适用于FFOE VQA，提出利用知识蒸馏将知识从三线性交互模型转移到双线性交互模型</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="VQA中的联合嵌入"><a href="#VQA中的联合嵌入" class="headerlink" title="VQA中的联合嵌入"></a>VQA中的联合嵌入</h3><p>在SOTA的VQA算法中，输入图像和问题的特征通常用矩阵形式表示。例如，每幅图像由若干感兴趣的区域描述，每个区域由一个特征向量表示，类似的思想也适用于问题，例如，一个问题包含若干个单词，每个单词用一个特征向量表示，一个图像区域和一个单词之间充分表达的交互作用应该是它们两个对应向量之间的外积，外积允许两个向量的所有元素之间的乘法相互作用，然而，在每一对可能的区域和单词之间使用外积完全双线性交互将极大地增加输出空间，大部分研究都试图压缩或分解完全双线性相互作用，而不是直接用外积计算完全双线性交互</p><p>不同于之前的学习双模态的联合表示或使用点积来简化三模态交互的研究，作者提出了一个三线性交互模型来同时学习三种模态的联合表征，首先推导了三种模态见的完全三线性相互作用，然后采用分解方法为交互产生一个紧凑的模型(compact model)</p><h3 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h3><p>在FFOE VQA中，以图像、问题和答案为输入的三线性交互模型只能用于训练阶段，而不能用于测试阶段，因为测试阶段没有答案，因此作者采用知识蒸馏的方式从三线性模型中将知识转移到双线性模型</p><p>主要灵感来源于Hinton’s seminar work</p><p>解读可见：<a href="https://zhuanlan.zhihu.com/p/24894102">https://zhuanlan.zhihu.com/p/24894102</a></p><h2 id="紧凑三线性交互"><a href="#紧凑三线性交互" class="headerlink" title="紧凑三线性交互"></a>紧凑三线性交互</h2><h3 id="完全三线性交互"><a href="#完全三线性交互" class="headerlink" title="完全三线性交互"></a>完全三线性交互</h3><p>设$M={M_1,M_2,M_3}$为三种输入，$M_t \in R^{n_t \times d_t}$，其中$n_t$是通道数，$d_t$是每个通道的维数，完全参数化三线性交互的结果为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-1.png"></p><p>$\tau$是一个可学习的张量，$vec(M_t)$是$M_t$的向量化，输出一个行向量，$\times_i$表示i-mode张量积</p><p>tensor $\tau$通过i-mode乘积学习了三个输入之间的相互作用，然而学习如此大的一个张量是不可行的，因此有必要减少$\tau$的大小</p><p>作者采用了unitary attention机制，令$z_p$表示通道的第p个三元组，每个三元组中的通道来自不同的输入，记每个通道在三元组中表示为$m_{1_i}$，$m_{2_j}$，$m_{3_k}$，那么z的完全参数化三线性交互结果为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-2.png"></p><p>依据unitary attention，z的近似可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-3.png"></p><p>作者计算了所有可能的三元组的加权和，第p个三元组和离散权值$M_p$相关，$M_p$集合即注意力图M，其计算方式如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-4.png"></p><p>最终联合表示z可以被写为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-5.png"></p><h3 id="参数分解"><a href="#参数分解" class="headerlink" title="参数分解"></a>参数分解</h3><p>虽然三线性相互作用模型的大张量T被两个较小的张量$T_M$和$T_{sc}$所取代，但这两个张量的维数仍然很大，给学习带来很大困难，为了进一步降低计算的复杂度，对$T_M$和$T_{sc}$采用了PARALIND分解</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-6.png"></p><p>R是切割参数，在分解率(直接与使用内存和计算成本相关)和性能之间建立平衡，$G_r$是一个学习的小张量，称为Tucker tensor，它的数量等于R，R的最大值一般设置为d1，d2，d3中的最大值，实验设置R=32，下图展示了PARALIND算法对Tm的分解</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-7.png"></p><p>所以PARALIND分解可以被表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-8.png"></p><p>代入注意力图的计算式子得到</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-9.png"></p><p>对Tsc的分解和Tm类似，这里设置切割参数R=1，Tsc最终可以表达为：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-10.png"></p><p>$z_T$的计算式子可以被重写为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-11.png"></p><p>因为$G_{sc}$秩为1，所以可以用点积近似计算</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-12.png"></p><h2 id="紧凑三线性交互用于VQA"><a href="#紧凑三线性交互用于VQA" class="headerlink" title="紧凑三线性交互用于VQA"></a>紧凑三线性交互用于VQA</h2><p>对于VQA来说，其attention map可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-13.png"></p><p>联合表示被计算为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-14.png"></p><h3 id="MC-VQA"><a href="#MC-VQA" class="headerlink" title="MC VQA"></a>MC VQA</h3><p>首先输入的问题和答案被裁剪到最大12个单词，空缺位置用0填充，之后每个单词都被嵌入一个300-D的GloVe word embedding来表示，每张图片被表示为$14\times14\times2048$的网格特征，从在ImageNet上预训练的ResNet-152的倒数第二层提取</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-15.png"></p><p>样本输入被分为正样本和负样本，正样本标记为1，负样本标记为0，然后将这些样本通过CTI得到联合表示z，将联合表示通过二值分类器进行预测。利用二元交叉熵损失对模型进行训练</p><h3 id="FFOE-VQA"><a href="#FFOE-VQA" class="headerlink" title="FFOE VQA"></a>FFOE VQA</h3><p>FFOE VQA需要将问题看出在一组预定义的答案上的分类问题，因此，每个问题-图像对的可能答案集合比MC VQA的情况下要多，对于每个问题图像输入，模型从其答案列表中获取所有可能的答案来计算联合表示，这将导致很高的计算成本，CTI在输入的时候要求V-Q-A，而在测试的时候是没有A的，因此作者对模型进行了改进，引入了知识蒸馏，模型如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-16.png"></p><p>teacher model用V-Q-A作为输入，得到联合表示，然后将联合表示传入分类器，损失采用交叉熵，student model作者采用BAN2和SAN，用V-Q作为输入，将答案预测作为一个分类问题，损失函数定义为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-17.png"></p><p>$L_{CE}$是交叉熵损失，$Q_s$是student model标准的softmax输出，$y_{true}$是GT答案标签，$\alpha$是用来调整各部分loss重要性的超参数，$Q_S^\tau$，$Q_T^\tau$是采用了相同温度的student和teacher的softmax输出，计算方法为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-18.png"></p><p>对于教师模型和学生模型，logit $l$是相应分类器输出的预测</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-19.png"></p><p>不同问题种类上的表现</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-20.png"></p><p>attention map可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-21.png"></p><p>在TDIUC上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CTIVQA-22.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2019 </tag>
            
            <tag> 迁移学习 </tag>
            
            <tag> 知识蒸馏 </tag>
            
            <tag> ICCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将迁移学习应用于VQA</title>
      <link href="2020/08/25/transferLearning/"/>
      <url>2020/08/25/transferLearning/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1810.02358">Paper Download Address</a></p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>VQA的方法依赖于大规模的图像数据集、问题和回答三元组，训练一个分类器，将图像和问题作为输入，然后生成一个答案，尽管最近取得了显著的进展，但这个框架有一个关键的局限性，即数据集中的图像、问题和回答三元组是学习视觉概念的唯一来源，这种缺陷可能会导致可扩展性的缺乏，因为标注人员可能会在质量控制有限的情况下人为地收集三元组，并且在视觉概念上多样性较弱</p><p>人类回答问题则是基于视觉概念的，视觉概念来自多个来源，比如书，图片，视频或是个人经验，但这些不一定和目标问题相关，机器也有很多可扩展的学习视觉概念的资源：图像类标签，边框和图像描述，那么能否学习没有标注的视觉概念并将其迁移到VQA系统中呢？</p><p>为了解决这个问题，作者引入了一个包含词汇表之外答案的VQA问题，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-1.png"></p><p>文章研究了在没有问题的情况下对视觉概念的学习，以及如何将学习到的视觉概念转化为VQA模型，文章提出的迁移学习框架有助于在词汇量不足的VQA中进行泛化</p><p>文章的主要贡献如下：</p><ol><li>提出了一种基于任务条件视觉分类器的视觉问题回答迁移学习算法</li><li>提出了一种非监督任务发现技术，用于学习任务条件视觉分类器，无需明确的任务注释</li><li>实验表明，该方法通过不带问题标注的可视化数据集的知识迁移来处理词汇表以外的答案</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>标准的VQA评估中训练集和测试集的分布是相同的，这种设置很容易遭到利用偏见(bias)的模型的攻击，因此有了许多替代的评估方式，一种方法是通过平衡个别问题的答案或有意地为训练集和测试集提供不同的偏差来减少观察到的偏差，另一种方法是构建组合，比如VQA-CP，作者研究的则是迁移学习，即从外部视觉数据中学习词汇之外的答案</p><p>为了更好地泛化，VQA训练通常使用外部数据，在ImageNet上预训练的卷积神经网络是多种VQA模型中被广泛使用的标准，而目标检测则是在Visual Genome数据集预训练，问题编码器的参数初始化经常使用预训练的语言模型，如词嵌入或句嵌入，也有一些研究利用欧冠知识库或者外部视觉算法的信息检索作为VQA模型的额外输入</p><p>从外部数据中迁移学习以应对词汇量之外的词汇在VQA中很少被研究，但在对象字幕中被积极研究，比如将图像字幕任务分解为视觉分类和语言建模，利用未配对的视觉和语言数据作为附加资源，分别训练视觉分类器和语言模型，有的方法结合了指针网络，并学习指向候选词的索引，其中候选词由经过外部视觉数据训练的多标签分类器或目标检测器检测，但是这些做法在VQA上不适用，因为它们专注于没有任务说明的目标词，而VQA需要任务条件视觉识别</p><p>作者的研究和零样本学习相近，都是在分类时考虑词汇外的答案，但是零样本学习旨在识别训练中看不到的物体或者类，因为目标是将其推广到完全不可见的类，所以在训练过程中严禁接触到零样本内容，而作者的目的是利用外部数据集中可用的类标签</p><h2 id="迁移学习框架"><a href="#迁移学习框架" class="headerlink" title="迁移学习框架"></a>迁移学习框架</h2><p>这篇文章工作的主要目标是在VQA中处理词汇表之外的答案，通过学习off-the-shelf视觉数据集中的视觉概念，将这些概念迁移到VQA中来回答问题，VQA可以被看做是一个任务条件分类问题，作者定义了一个任务条件视觉分类器，利用视觉输入和任务规范产生答案，作为学习和迁移用的视觉概念，整体框架如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-2.png"></p><h3 id="任务条件视觉分类器"><a href="#任务条件视觉分类器" class="headerlink" title="任务条件视觉分类器"></a>任务条件视觉分类器</h3><p>任务条件视觉分类器是一个以视觉特征和任务特征作为输入并产生答案标签概率分布的函数</p><p>在迁移学习中，任务条件视觉分类器使用现成的视觉数据集Visual Genome预训练，然后迁移到VQA，该阶段允许任务条件视觉分类器通过学习任务特征来处理不同的视觉识别任务</p><h3 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h3><p>学习任务的条件视觉分类器可以自然地表述为最大化以下期望对数似然</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-3.png"></p><h3 id="针对VQA的迁移学习"><a href="#针对VQA的迁移学习" class="headerlink" title="针对VQA的迁移学习"></a>针对VQA的迁移学习</h3><p>VQA模型包含任务条件视觉分类器$p_{\theta}(a|v,\tau)$，预训练的视觉概念通过共享学习参数$\theta$迁移到VQA，学习VQA模型本质上就是学习$p_{\theta}(a|v,\tau)$中的$v$和$\tau$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-4.png"></p><p>—— 弱监督任务回归</p><p>利用预先训练好的任务条件视觉分类器进行问题q指定的视觉识别，推断出最优的任务特征，这需要引入一个学习问题-任务回归-来生成一个encoder以正确预测任务特征，最小化误差要求对任务的额外监督，因此作者用VQA数据做弱监督，优化了间接损失</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-5.png"></p><p>鼓励$\tau_q^*$和$\tau_{\eta_{vqa}}(q)$尽量相似</p><p>—— 词汇表之外的回答</p><p>在固定好预训练的任务条件视觉分类器$p_\theta(a|v,\tau)$之后，通过改变输入的形式来训练VQA模型，这种方式允许模型学习从问题中推断视觉识别任务，而不需要所有可能答案的数据，一旦推断出任务特征$\tau$，任务条件视觉分类器$p_\theta(a|v,\tau)$就能够回答预训练的视觉概念，涵盖词汇表外的回答</p><p>—— 视觉特征匹配</p><p>为了能够重复使用预训练的视觉分类器而不需要微调，视觉特征v的语义不应该通过学习VQA数据集而改变，这一点在最近的VQA模型中得到了实现，这些模型不微调预先训练好的视觉特征提取器，而是在提取的特征图上专注于学习注意力机制，而在文章中，作者只是简单地对预训练和VQA采用相同的视觉特征提取器</p><h2 id="无监督任务发现"><a href="#无监督任务发现" class="headerlink" title="无监督任务发现"></a>无监督任务发现</h2><p>使用现成的可视化数据集学习任务条件视觉分类器并不容易，因为缺少对任务规范的标注，这对学习一个任务规范向量$\tau$的编码器来说是必需的，为了解决这一问题，作者提出了无监督任务发现，即利用语言知识资源从任务分布模型中抽取任务规范</p><h3 id="利用语言知识来源"><a href="#利用语言知识来源" class="headerlink" title="利用语言知识来源"></a>利用语言知识来源</h3><p>一个问题给出的视觉识别任务通常定义一个从视觉输入到一组可能的视觉概念(即一组单词)的映射，比如”那个女人手上拿着什么”在图片中定义了一个视觉识别任务”找到被手持的物品”，这是一个到词组{球,球拍,水杯,…}的分类，因此可以将任务视为单词组来建模模型的分布，使用语言知识源进行无监督任务发现的主要原因是语言知识源中经常可以访问到词汇组，作者考虑了两个语言知识来源：带有视觉数据的视觉描述和结构化词汇数据库WordNet</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-6.png"></p><h3 id="视觉描述"><a href="#视觉描述" class="headerlink" title="视觉描述"></a>视觉描述</h3><p>作者采用Visual Genome作为现成视觉数据集，定义了一个数据分布$P_v(a,I,b,d)$，这个数据集被设计为描述中明确提及答案a，因此答案和描述之间的关系是清晰的</p><p>作者将视觉描述中的答案替换为一个特殊词&lt;空白&gt;来定义任务规范$t_d$，该词正式表示为$t_d=\rho(d,a)$，$\rho(d,a)$为生成空白描述的函数，$t_d$的下标表示一个基于视觉描述提取的任务规范，任务规范为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-7.png"></p><p>对于任务规范使用空白描述的主要原因是定义一组候选词是有效的。例如，一个空白的描述”一个人持有_____”，将空白的候选词限制为一组可以持有的对象。因此，可以使用空白描述来隐式地确定表示视觉识别任务的单词组</p><h3 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a>WordNet</h3><p>WordNet是一个词汇数据库，他用synset消歧词实体的有向无环图表示，一个简单的WordNet的子图如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-8.png"></p><p>基于WordNet和可视化数据$(a,i,b,d)$的任务规范$t_w$采样过程如框架图中(b)WordNet所示，在WordNet中，作者将任务规范$t_w$定义为节点的synset，节点是多个单词的共同祖先，因为共享共同祖先的一组单词构造了一个单词组，而单词组还可以定义一个视觉识别任务</p><p>该过程的主要思想是将基于答案$p(t_w|a)$的任务分布建模为答案所属的可能的词组上的均匀分布，其中任务规范$t_w$是词组中词的共同祖先，建立分布$p(t_w|a)$分为两个步骤：1)构造一个词组表，该表将任务规范映射到词组；2)构造一个反词组表，它将回答词映射到一组任务规范，反词组表用于检索回答a的一组可能的任务规范，分布$p(t_w|a)$是该集合中任务规范的均匀分布，表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-9.png"></p><p>在WordNet中选择节点的一个synset作为任务规范$t_w$，并将其映射到与其所有后代对应的一组单词(一个单词组)，从而构造单词组表。任何词组都可以定义，无论其在WordNet层次结构的级别和其成员的词性;最大的词组包含所有的词；WordNet及其任务规范对应于WordNet的根。反向词组表的构造方式类似于词组表的反向索引，但是映射的范围不是一组索引，而是一组任务规范</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>词汇表之外的回答</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-10.png"></p><p>弱监督任务发现的结果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/transferLearning-11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2019 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUBi [question-only分支]</title>
      <link href="2020/08/20/RUBi/"/>
      <url>2020/08/20/RUBi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1906.10169">Paper Download Address</a></p><p><a href="https://github.com/cdancette/rubi.bootstrap.pytorch">Code Download Address</a></p><h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>VQA模型倾向于利用答案的出现和问题中的某些模式之间的统计规律来回答问题，虽然它们被设计来合并来自两种模态的信息，但在实践中，它们通常不考虑图像模态，当大多数香蕉都是黄色的时候，模型不需要学习正确的方法来回答香蕉颜色的问题，只要将单词”什么”、”颜色”和”香蕉”与最常见的答案”黄色”联系起来即可，这比通过看图像来判断香蕉的颜色要容易得多</p><p>量化每种模态统计捷径数量的一种方法是训练单模态模型，比如在VQAv2中训练的纯语言模型可以在测试集上达到44%的准确率，VQA模型没有放弃这种偏差，因为他们的训练数据集和测试数据集是有着同样的分布，然而在不同分布规律的测试集上评估时，其准确率会显著下降，然而在收集真实数据集时，很难避免这些统计规律，需要采取新的策略来减少来自问题的bias</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-1.png"></p><p>作者提出了一种训练策略RUBi，用以减少VQA模型的bias，这种策略降低了最biased的样本的重要性，也就是那些不需要看图像模态就能正确分类的样本，它隐式地迫使VQA模型使用两种输入模式，而不是依赖于问题和答案之间的统计规律，作者在训练期间在基础VQA模型的顶部添加一个question-only分支。该分支影响VQA模型，动态调整损失以补偿偏差，通过VQA模型反向传播的梯度对于偏度较大的样本被降低，对于偏度较小的样本被增加。在训练结束时，简单地删除question-only分支</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>真实世界的数据集由于其收集过程而显示出某种形式的固有偏差，因此，机器学习模型倾向于反映这些偏差，因为它们捕获了输入和GT标注之间虚假的相关性，有研究开始识别特定种类的偏差并减少他们，比如有些方法针对性别偏差，人类报告偏差，也有针对实验采集的数据和真实世界数据的偏差，在语言和视觉领域，一些研究评估单模态基线或者是利用语言先验</p><h3 id="单模态偏差"><a href="#单模态偏差" class="headerlink" title="单模态偏差"></a>单模态偏差</h3><p>尽管被设计为双模态融合，但是VQA模型通常只依靠单模态来解决问题，量化VQA模型可能学习到的单模态偏差的数量的一个有趣的方法是只使用两种模式之一的训练模型，纯问题模型是一个特别强大的baseline，因为可以从问题模态中利用大量的统计规律，通过RUBi学习策略，作者利用这个baseline模型来防止VQA模型学习问题偏差</p><h3 id="平衡数据集"><a href="#平衡数据集" class="headerlink" title="平衡数据集"></a>平衡数据集</h3><p>一旦识别出单模态偏差，克服这些偏差的一个方法就是创建更平衡的数据集，比如拒绝在一系列相关的问题中抽样来最小化通往正确答案的捷径数量</p><p>由于注释的成本，在真实的VQA数据集中做拒绝采样通常是不可能的，另一个解决方案是收集互补的示例来增加任务的难度，即使有了这种额外的平衡，问题的统计偏差仍然存在，并且可以加以利用，因此作者提出了一种方法来减少训练中的单模态偏差，RUBi被设计用于从有偏的数据集中学习无偏的模型，这种学习策略动态地修改损失值，以减少问题的偏差，通过这种方式，减少了某些样本的重要性，增加了互补问题的重要性</p><h3 id="架构和学习策略"><a href="#架构和学习策略" class="headerlink" title="架构和学习策略"></a>架构和学习策略</h3><p>另一个重要的工作是设计VQA模型来克服数据集的偏差，<a href="https://arxiv.org/abs/1712.00377">Agrawal et al</a>提出了一种手工设计的架构GVQA，将VQA的任务分解为两步，第一步定位和识别问题所需的视觉区域，第二步是根据question only的分支来确定答案可能的空间，这种方法需要分别训练多个子模型，而作者提出的方法是端到端的，它们的复杂设计不能直接应用于不同的体系结构，而作者方法是与模型无关的。虽然依赖于一个仅问问题的分支，但在训练结束时删除了它</p><p>和本文最为相近的工作是<a href="https://arxiv.org/abs/2007.06198">Ramakrishnan et al</a>，这项工作中提出了一种克服VQA模型中语言先验的学习策略。他们首先引进了question-only分支，用来自VQA模型的问题编码作为输入，并产生一个question-only损失，他们使用这种损失的梯度否定(gradient negation)来阻止问题编码器捕获可能被VQA模型利用的偏差。他们还提出了基于VQA模型和纯问题分支输出分布之间的熵差异的损失，这两个损失只反向传播到问题编码器。相比之下，作者的学习策略以完整的VQA模型参数为目标，以更有效地减少不必要的偏差的影响，使用问题分支动态适应分类损失的值，以减少VQA模型的学习偏差</p><p>直观对比见下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-2.png"></p><h2 id="RUBi"><a href="#RUBi" class="headerlink" title="RUBi"></a>RUBi</h2><p>作者将VQA视为一个分类问题，给定的数据集D由三部分组成，图像v，问题q和答案a，作者需要优化的是函数f中的参数，这个函数f可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-3.png"></p><h3 id="经典学习策略和陷阱"><a href="#经典学习策略和陷阱" class="headerlink" title="经典学习策略和陷阱"></a>经典学习策略和陷阱</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-4.png"></p><p>VQA模型的经典学习策略如图所示，在大小为n的数据集上最小化标准交叉熵</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-5.png"></p><p>它们倾向于依赖一种模态的统计规律来提供准确的预测，而不必考虑另一种模态，举一个极端的例子，对问题模态有强烈偏见的模型总是对香蕉是什么颜色的问题输出黄色。它们不学习使用图像信息，因为在数据集中香蕉不是黄色的例子太少了</p><h3 id="RUBi学习策略"><a href="#RUBi学习策略" class="headerlink" title="RUBi学习策略"></a>RUBi学习策略</h3><p>—— 用question-only分支来捕捉偏见</p><p>测量单模态偏差的一个方法就是训练一个单模态模型，RUBi的关键思是将一个question-only的模型作为VQA模型的一个分支，这将改变主模型的预测</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-6.png"></p><p>通过这样做，只考虑问题的分支捕获了问题偏差，从而允许VQA模型关注仅使用问题模态无法正确回答的示例</p><p>在训练期间，分支结构充当代理，阻止任何形式的VQA模型由学习偏差得到式</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-7.png"></p><p>结束训练后，直接删除分支，用基本VQA模型来做预测</p><p>—— 通过标记预测来防止偏见</p><p>在基础VQA模型的预测传递到损失函数之前，将它们与长度为$|A|$的掩码合并，掩码包含每个答案的0到1之间的标量值，该掩码是通过将神经网络$nn_q$的输出通过一个$sigmoid$函数得到的，这个掩码的目的是通过修改VQA模型的预测来动态地改变损失，为了得到新的预测，只要计算原先预测和掩码之间的元素级乘</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-8.png"></p><p>为了更好地理解这个方法对学习的影响，作者进行了以下两个步骤：</p><p>首先减少了大部分偏见样本的重要性，做法是question-only分支输出一个掩码来增加正确答案的分数，同时减少其他答案的分数，因此，对于这些偏见样本，损失要低得多，换句话说，也就是通过VQA的后向传播梯度变得更小，因此减少了这些偏见样本的重要性</p><p>过程如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-9.png"></p><p>mask影响了VQA的预测结果，使得黄色香蕉的得分从0.8上升到了0.94，从而使得loss从0.22下降为0.06</p><p>其次，作者提升了回答错误的样本的重要性，比如遇到绿色香蕉时能够将loss抬高</p><p>—— 联合学习过程</p><p>利用由两个损失计算出的梯度，作者联合优化了基本VQA模型以及question-only分支的参数，最终loss由两部分组成</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-10.png"></p><p>$L_{QM}$是联合预测结果的交叉熵损失，$L_{QO}$是question-only预测分支的交叉熵损失</p><h3 id="Baseline架构"><a href="#Baseline架构" class="headerlink" title="Baseline架构"></a>Baseline架构</h3><p>作者的模型结构灵感来自<a href="https://arxiv.org/abs/1902.09487">MUREL</a>，图像特征提取采用Faster RCNN，问题特征提取采用GRU，特征融合方法采用的是Bilinear BLOCK fusion，分类则是简单的MLP</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>在VQA-CP v2上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-11.png"></p><p>在VQA-CP v2上对不同架构的优化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-12.png"></p><p>因为消除了bias，所以在VQAv2上反而acc是下降的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-13.png"></p><p>RUBi策略同时也改善了attention</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/RUBi-14.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> NIPS </tag>
            
            <tag> 2019 </tag>
            
            <tag> debias </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seada-VQA [对抗数据扩充样本]</title>
      <link href="2020/08/19/seadaVQA/"/>
      <url>2020/08/19/seadaVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2007.09592">Paper Download Address</a></p><p><a href="https://github.com/zaynmi/seada-vqa">Code Download Address</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>最近的研究表明VQA的性能取决于训练数据的数量，已有的算法总是能从更多的训练数据中受益，这意味着不需要手工标注便能进行数据扩充，从而提升VQA的性能</p><p>现有的数据增强方法通过数据扭曲(data warping)或过采样(oversampling)来扩大训练数据集的大小，数据扭曲转换数据并保留其标注，方法包括几何和颜色变换、随机擦除、对抗性训练和风格迁移，过采样生成合成实例并将其添加到训练集中，数据增强可以有效地缓解DNN的过拟合问题</p><p>然而在VQA问题上少有对数据增强的研究，因为数据增强的同时需要保持[答案|问题|图像]三元组的正确性，几何变换和随机擦除都难以维持答案的正确性，在文本方面，提出语言转换的通用规则也是很有挑战性的</p><p>先前的工作都是基于已知的图像和给出的答案来产生合理的问题，即视觉问题生成，但是这种方法会生成一些奇怪的句子或者存在语法错误，而且生成的数据是从相同分布的原始数据中提取的，并不能减轻过拟合</p><p>作者将视觉数据和文本数据作为扩充数据生成语义等价的对抗数据，视觉对抗样本是基于梯度的非目标的attacker生成的，文本对抗样本能够欺骗VQA模型(预测错误答案)同时保持问题等效性，对抗性实例的存在不仅表明了卷积网络的泛化能力有限，而且对这些模型的实际部署也构成了安全威胁</p><p>作者对BUTD在VQAv2上进行对抗性训练，采用纯样本(clean examples)和即时生成(on-the-fly)的对抗样本，实验结果表明，作者提出的对抗训练框架不仅比其他数据增强技术更好地提高了模型在纯样本上的性能，同时提高了模型对对抗攻击的鲁棒性，作者是VQA领域第一个同时对图片和文本做数据增强的</p><p>文章的贡献概括如下:</p><ol><li>作者提出生成视觉和文本的对抗式样本来扩充VQA数据集，生成的数据保留了语义，探索了学习到的决策边界，可以帮助提高模型的泛化能力</li><li>提出了一个对抗训练方案，使VQA模型能够从对抗样本的正则化中受益</li><li>用作者的方法训练的模型在纯验证集上达到了65.16%的准确率，比普通训练高出1.84%，此外，经过对抗训练的模型在对抗样本上提升了21.55%</li></ol><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>VQA目前研究方法包括注意力，合成方法和双线性池化，相当一部分的VQA最新的算法都是在BUTD注意力机制上建立的，因此作者也选择了BUTD作为baseline，研究侧重点在数据增强上</p><p>在分类问题上对于文本增强只有少量工作，在VQA上已有的数据增强的研究都是单模态的，且严重依赖复杂的模块来实现轻微的性能提升</p><p>近年有工作在图像中增加噪声生成对抗样本来评估DNN的鲁棒性，在NLP领域，最先进的文本DNN attacker采用不同于视觉领域的方法来生成文本的对抗样本，作者的灵感主要来源于SCPNs和SEA。研究表明，即使在ImageNet上，通过精心设计的训练方案，对抗性训练也可以提高模型的性能。一些在VQA上进行对抗攻击的工作仅仅对图片进行了攻击，但并没有讨论杜康样本对VQA模型的作用，总而言之，对抗样本如何促进VQA仍然是一个待解决的问题</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>模型的框架如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-1.png"></p><p>首先产生文本的变体并保存，随后生成即时的视觉对抗样本，获得语义相等的三元组，然后用他们进行对抗训练</p><h3 id="VQA-model"><a href="#VQA-model" class="headerlink" title="VQA model"></a>VQA model</h3><p>VQA问题可以表述为根据参数概率测度预测给定图像v和问题q的答案a的问题</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-2.png"></p><p>$\theta$是所有要学习的参数，$A$是所有的答案，作者采用BUTD作为模型的骨干</p><h3 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h3><p>由于存在影响答案的风险，作者避免直接地操作原始输入，比如裁剪图像或者改变词序，受对抗性攻击和防御的启发，作者提出生成对抗性样本作为额外的训练数据</p><h4 id="Visual-Adversarial-Examples-Generation"><a href="#Visual-Adversarial-Examples-Generation" class="headerlink" title="Visual Adversarial Examples Generation"></a>Visual Adversarial Examples Generation</h4><p>对抗性攻击起源于计算机视觉界，本质上是对图像增加扰动使得输出错误的答案，作者采用了一个高效的基于梯度的attacker IFGSM来生成视觉对抗样本，首先介绍一下FGSM，因为IFGSM是其的一个扩展，其过程表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-3.png"></p><p>$v_{adv}$就是$v$的一个对抗样本，$\theta$是模型参数，$L(\theta,v,q,a_{true})$表示VQA训练的代价函数，攻击将梯度反向传播到输入的视觉特征进行计算$\nabla_vL(\theta,v,q,a_{true})$，然后在$sign(\nabla_vL(\theta,v,q,a_{true}))$方向上小步调整输入使得loss最大化</p><p>IFGSM就是多次执行上述过程</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-4.png"></p><p>$Clip_{v,c}(A)$表示对$A$的元素级裁剪，$A_{i,j}$被裁剪到范围$[v_{i,j}-e,v_{i,j}+e]$，$\alpha$是每一次的步长，作者将这个过程记为$VAdvGen(v,q)$</p><h4 id="Semantic-Equivalent-Questions-Generation"><a href="#Semantic-Equivalent-Questions-Generation" class="headerlink" title="Semantic Equivalent Questions Generation"></a>Semantic Equivalent Questions Generation</h4><p>由于文本是离散的，所以不能直接采用图像DNN的攻击方法来生成一个问题的对抗样本$q_{adv}$，文本中的微小变化，如字符或单词的变化，很容易破坏语法和语义，造成攻击失败，遵循不改变输入数据语义的原则，作者使用序列到序列的意译模型(paraphrasing model)生成语义上等价的对抗式问题</p><p>作者提出了一个完全基于神经网络的转述模型，它是对基本的encoder-decoder Neural Machine Translation(NMT)框架的扩展，encoder(RNN)将原句的意思压缩成一个向量序列，decoder(条件RNN模型)逐词生成目标句子，模型的损失函数采用softmax</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-5.png"></p><p>生成结果如图所示，括号内是一致性得分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-6.png"></p><p>生成的语句可以轻易地使BUTD犯错，作者观察到$q_{adv}$不仅从正确的预测到错误的预测，而且在某些情况下将错误的预测更正为正确的预测，这表明模型决策是弱对抗的，模型在进行预测时利用了假相关性</p><h3 id="Adversarial-Training-with-Augmented-Examples"><a href="#Adversarial-Training-with-Augmented-Examples" class="headerlink" title="Adversarial Training with Augmented Examples"></a>Adversarial Training with Augmented Examples</h3><p>作者将对抗样本作为额外的训练样本，并用对抗样本和纯净样本的混合集来训练网络，问题的扩充与模型无关，在训练前生成，而视觉对抗性样本在训练的每一步都不断生成，根据问题输入的不同，有两种视觉上的对抗样本</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-7.png"></p><p>于是可以产生四个训练对$(v_{qc},q)$, $(v_{qadv},q)$,$(v_{qc},q_{adv})$以及 $(v_{qadv},q_{adv})$，所有的对语义都是相等的，也就是说拥有相同的GT答案</p><p>所以loss被计算为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-8.png"></p><p>整个对抗训练过程为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-9.png"></p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-10.png"></p><p>在不同training set大小下的作用</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/seadaVQA-11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2020 </tag>
            
            <tag> ECCV </tag>
            
            <tag> 数据增强 </tag>
            
            <tag> 对抗学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid Feats VQA [回归网格特征]</title>
      <link href="2020/08/18/Grid/"/>
      <url>2020/08/18/Grid/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2001.03615">Paper Download Address</a></p><p><a href="https://github.com/facebookresearch/grid-feats-vqa">Code Download Address</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>自深度学习和注意力机制之后，对于跨模态视觉和语言研究来说可能最有影响力的就是bottom-up注意力，区别于用top-down文本输入来关注视觉输入的特定部分，bottom-up注意力采用预训练的目标检测器来识别<strong>只跟视觉输入本身有关</strong>的突出区域，图像被表示为bbox和区域级的特征，bottom-up特征在之后的研究中被广泛采用</p><p>然而是什么造就了区域特征的优良表现？人们会自然地认为主要原因是对单个对象更好的定位，另一个可能的原因是采用多个区域可以很容易地同时捕获图像中的粗级信息和细粒度细节，然而这些潜在的优势是否真的证明了区域特征优于网格特征？</p><p>作者发现，在VQA中，从预先训练好的检测器的同一层中提取的网格特征可以与基于区域的对应特征相匹敌，此外，通过在训练过程中进行简单的修改，同样的网格特征可以变得更加有效，并且始终能够达到与区域特征相当甚至更好的VQA精度，作者用消融实验证明了，导致bottom-up特征高准确率的原因有(1)在Visual Genome数据集中收集的大规模对象和属性注释用于预训练;(2)用于计算特征的输入图像的高空间分辨率</p><p>采用网格特征的好处就是推理速度加快了，因为可以调过所有现有VQA任务中与区域相关的步骤</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Grid-1.png"></p><p>提取区域特征是非常耗时的，所以现在大多数SOTA模型都是直接采用预训练的视觉特征，这种做法不仅在模型设计上强加了不必要的限制，而且还限制了现有视觉和语言系统的潜在应用</p><p>在网格特性的支持下，作者开始训练从像素到答案的端到端的VQA模型，使用区域特征进行端到端的训练是极具挑战性的，因为微调区域位置可能需要额外的GT标注，计算成本昂贵，而且标注很难获得，相比之下网格特征可以很容易地做到为最终目标进行优化，而不需要额外的GT</p><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Visual-features-for-vision-and-language-tasks"><a href="#Visual-features-for-vision-and-language-tasks" class="headerlink" title="Visual features for vision and language tasks"></a>Visual features for vision and language tasks</h3><p>特征在视觉和语言任务的推进中发挥了关键作用，当下VQA模型的准确性依赖于所使用的底层视觉特性，近期大多数SOTA模型研究的重心都是基于区域特征的模态融合方法，而作者的工作是重新审视了网格的特征，并表明它们可以同等有效，且可以显著的加速</p><h3 id="Pre-training-for-VQA"><a href="#Pre-training-for-VQA" class="headerlink" title="Pre-training for VQA"></a>Pre-training for VQA</h3><p>大多数VQA方法都是采用了两个预训练模型：在ImageNet和VG上训练过的视觉模型，以及来表示语言特征的词嵌入，由于这些单独训练的特征对联合视觉和语言理解可能不是最佳的，最近的一个热门话题是开发联合预训练的模型，一个常见的方法就是将区域和词看成他们各自领域的token，然后预训练一个类似BERT的模型来预测masked token，作为对这个方向的补充，作则专门研究了视觉标记的格式(visual token)，可以和这些方法结合，实现互利</p><h3 id="Regions-vs-grids"><a href="#Regions-vs-grids" class="headerlink" title="Regions vs. grids"></a>Regions vs. grids</h3><p>基于R-CNN的检测模型的优势证明了基于区域的细化阶段有利于目标检测，此外，one-stage检测器不需要显式的区域级计算来完成检测任务，说明网格特征在目标检测上也具有竞争力</p><p>为了最小化和BUTD paper的差距，作者采用了Faster R-CNN来对特征做预训练，但是去除了区域相关的步骤，而采用网格卷积特征</p><p>同时，虽然区域特征在VQA的基准测试中显示有效，但是对于回答视觉问题时诊断模型的推理能力的基准测试，基于网格的简单方法表现出较强的性能</p><h2 id="From-Regions-to-Grids"><a href="#From-Regions-to-Grids" class="headerlink" title="From Regions to Grids"></a>From Regions to Grids</h2><h3 id="Bottom-Up-Attention-with-Regions"><a href="#Bottom-Up-Attention-with-Regions" class="headerlink" title="Bottom Up Attention with Regions"></a>Bottom Up Attention with Regions</h3><p>bottom-up attention方法采用Faster R-CNN，检测模型在Visual Genome上训练，该训练集上有数千物体类别和数百带有bbox注释的属性</p><p>为了获得像VQA任务的bottom-up注意力特征，需要两个区域相关的步骤:</p><ol><li><p>区域选择，因为Faster R-CNN是一个two-stage的检测器，所以在管道中进行两次区域选择，第一次是通过RPN，其对候选的”锚”做形变和选择作为感兴趣的区域(RoI)，另一次选择作为后处理完成，以每个类的方式聚合top N的box，在两个过程中，都采用了非最大值抑制(NMS)，保留分类分数最高的区域，并去除局部邻域内的其他重复项</p></li><li><p>区域特征计算，给定第一个步骤中的区域(近千)，用RoIPool操作来提取初始的区域级特征，然后其它网络层分别计算图片的区域表示，最后，通过两次选择的区域特征被堆叠在一起作为bottom-up的特征来表示图像</p></li></ol><p>由于VG数据集的复杂性(例如数以千计的类)和特定的Faster R-CNN检测器使用，这两个步骤都是计算密集型的。而直接使用网格特性可以跳过或加速这些步骤，显著地加速</p><h3 id="Grid-Features-from-the-Same-Layer"><a href="#Grid-Features-from-the-Same-Layer" class="headerlink" title="Grid Features from the Same Layer"></a>Grid Features from the Same Layer</h3><p>将区域特征转换为网格的最简单的方法是看看是否可以以共享的、完全卷积的方式计算相同网络层的输出，为此，作者仔细研究了原始bottom-up注意力所使用的特定Faster R-CNN框架</p><p>Faster R-CNN是C4模型的变体，增加了一个用于属性分类的分支，它将ResNet的权重划分为两个单独的集合：给定输入图像，它首先使用ResNet的较低块(直到C4)计算特征图，特征图在所有区域之间共享，然后，对$14 \times 14$个RoIPool-ed特征分别应用C5块进行逐区特征计算，然后，C5的输出被avgpool转换为每个区域的最终向量，作为bottom-up的特征，由于所有的最终区域特征都来自C5，很容易将检测器转换回并采用相同的C5层作为输出网格的特征</p><p>直接使用转换C5的输出效果已经非常好了，这样做的任何性能下降可能是因为Faster R-CNN对基于区域的对象检测进行了高度优化，而对网格可能没有进行太多优化。下文中作者尝试对模型做一些微小的调整来改进网格特征</p><h3 id="1x1-RoIPool-for-Improved-Grid-Features"><a href="#1x1-RoIPool-for-Improved-Grid-Features" class="headerlink" title="1x1 RoIPool for Improved Grid Features"></a>1x1 RoIPool for Improved Grid Features</h3><p>文章的想法是采用1x1的RoIPool，用一个简单的向量来表示每个区域，而非三维的张量，乍一看，这似乎与直觉相反，因为这两个额外的空间维度(高度和宽度)有助于在2D中描述对象的不同部分——实际上，作者发现这种修改对VG上的对象检测性能有负面影响，但重要的是，使用1x1 RoIPool区域也意味着网格feature map上的每个向量必须单独覆盖一个空间区域的所有信息，这可能会产生更强的网格特征</p><p>然而，在原始模型上直接采用1x1 RoIPool是有问题的，可能因为C5由几个ImageNet预训练卷积层组成，适合于特定空间尺寸的输入，为了解决这个问题，作者采用整个ResNet(到C5)作为共享特征计算的骨干，对于区域级计算，在顶部放置两个1024维全连接(FC)层，默认情况下接受向量作为输入</p><p>在使用C5汇聚的特征训练检测器时，为了减少低分辨率的影响，将stride-2层替换为stride-1层，其余的层以2的倍数扩张。对于网格特征提取，移除这个扩张并将其转换回正常的ResNet</p><p>图(右)总结了作者对改进的网格所做的更改，与原始模型(左)相比，仅在训练过程中对区域相关组件进行了必要的修改。 由于在特征提取过程中所有此类计算均被删除，因此作者的网格特征提取器在推理过程中保持不变</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Grid-2.png"></p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>不同数量的特征数的影响</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Grid-3.png"></p><p>注意力可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/Grid-4.png"></p><p>其它探索实验详见论文</p><p>总的来说，与特征的”格式”(区域与网格)相比，特征所代表的语义内容对有效性更为关键，所以bottom-up的本质其实是更好的特征，从区域到网格，最重要的是可以做到端到端的训练，并且速度显著提升(运行速度快48倍)</p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVLP [预处理]</title>
      <link href="2020/08/14/CVLP/"/>
      <url>2020/08/14/CVLP/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2007.13135">Paper Download Address</a></p><p><a href="https://github.com/ArcherYunDong/CVLP-">Code Download Address</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>语言预训练彻底改变了自然语言理解(NLU)，与此同时，在视觉分支上提出了视觉语言预训练(VLP)，VLP所依赖的网络结构与以往的方法相似，但通过大规模的预训练获得语义信息，使模型具有更好的性能和泛化能力</p><p>两种著名的VLP方法LXMERT和ViLBERT均是将标记的视觉区域的特征回归或分类作为自监督学习的代理任务(pretext task)，作者在其中发现了一些问题：1) 噪声标注: L2特征回归和分类在视觉基因组中受到噪声标注的影响；2)领域偏置: 由于视觉特征是由视觉基因组上预先训练好的物体检测器生成的，特征回归和标记的区域的分类会使预先训练好的视觉语言模型继承来自视觉的偏置基因组，这使得在其它下游任务上取得较差的泛化能力</p><p>为了解决噪声标注和领域差距的问题，文中提出了对比视觉语言预训练(CVLP)，借鉴了度量学习中流行的对比学习框架来解决领域偏差和有噪声的标签问题，CVLP用对比学习代替了区域回归和分类，对比学习的目的是区分正样本和负样本，不需要任何注释，因此可以解决有噪声的标注和领域偏置问题</p><p>由于Tranformer的巨大内存成本，为对比学习而扩大batch size是非常困难的，对比学习的一个突出问题是负样本的大小对性能有很大的限制，而负样本的大小又受到batch size大小的限制，基于记忆库的思想，作者建立了一个动态记忆队列，缓存前一个区域的上下文特征，并作为对比学习中的负样本，相应的缓存特征在训练过程中逐渐漂移(drift)，从而使之前缓存的负样本在内存队列中失效，同时，从缓慢移动的查询网络中提取特征并存储到内存队列中，当队列中充满特征时，最早的视觉上下文特征将从存储库中删除，一个单纯的对比学习是无效的，因为网络将很容易学会区分正样本和负样本，为了解决这一问题，作者采用随机分层密钥网络来增加特征的多样性</p><p>本文的贡献总结如下：</p><ol><li>提出了一种新的视觉语言预训练对比学习框架，解决了之前的视觉语言预训练方法(如LXMERT和ViLBERT)遇到的领域偏置和噪声标注问题</li><li>在CVLP上进行了广泛的消融研究，以验证提出的方法，CVLP预训练相比strong baseline (LXMERT) 取得显著的改善，特别是当预训练和精细训练阶段之间的区域差距变得更大时。CVLP可以在所有三个数据集(VQA, NLVR2，和GQA)上超过LXMERT的性能</li></ol><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Self-supervised-Learning-in-Vision-Language-and-Multi-modality"><a href="#Self-supervised-Learning-in-Vision-Language-and-Multi-modality" class="headerlink" title="Self-supervised Learning in Vision, Language and Multi-modality"></a>Self-supervised Learning in Vision, Language and Multi-modality</h3><p>与需要大量数据标注的监督式训练相比，自监督式学习通过在一个代理任务中构造一个损失来自动学习有用的特征，而不需要人工标注，在计算机视觉中，上下文编码器通过image in-painting来学习特征，<a href="https://arxiv.org/abs/1603.09246">Jiasaw</a>通过预测排列特征的位置来学习特征，<a href="https://arxiv.org/abs/1901.09005">Kolesnikov et al</a>对之前提出的自监督学习方法进行了大规模的研究，结果表明，自监督任务的性能随着骨干(backbone)的变化而变化</p><p>NLU采用下一词预测(GPT)，下一句预测或标记词预测(BERT)，进行大规模预训练，通常采用Transformer架构进行训练，显著提高了在GLUE基准上的NLU的准确率，LXMERT和ViLBERT表明，标记的词和视觉区域也可以产生良好的视觉-语言表征</p><h3 id="Contrastive-Learning"><a href="#Contrastive-Learning" class="headerlink" title="Contrastive Learning"></a>Contrastive Learning</h3><p>对比学习是自监督学习的一个分支，它利用对比损失来学习对下游任务有用的表示，对比丢失鼓励编码的实例特性与正键(positive keys)类似，而与负键保持距离，不同的对比学习方法采用不同的策略产生正键和负键，这是影响学习表征质量的重要因素，<a href="https://arxiv.org/abs/1805.01978">Wu et al</a>从存储整个训练数据集实例特性的大型内存存储中选择键，还有一些研究使用当前的小批处理示例生成密钥，Moco提出一种动量编码器来动态生成键并将它们存储在一个固定大小的队列中</p><h3 id="Multi-modality-Reasoning"><a href="#Multi-modality-Reasoning" class="headerlink" title="Multi-modality Reasoning"></a>Multi-modality Reasoning</h3><p>目前的视觉语言预训练的骨干是建立在多模态推理结构上的，图像字幕和VQA是激发多模态融合架构设计的两个流行任务，基于关注的结构已广泛应用于多模态融合，<a href="https://arxiv.org/abs/1502.03044">Xu et al</a>首先提出了软关注和硬关注，表明注意力模型具有良好的性能和可解释性，<a href="https://arxiv.org/abs/1511.02274">Yang et al</a>通过叠加注意模型，提出了一种多层注意模型，<a href="https://forever97.github.io/2020/07/15/1707-07998/">BUTD特征</a>展示了使用对象级特性的好处，最近越来越多研究建模对象和单词之间的关系作为表征学习，比如DCN，BAN，DFAF，MCAN，QBN，CA-RN以及STSGR</p><h2 id="Contrastive-Visual-Linguistic-Pretraining-CVLP"><a href="#Contrastive-Visual-Linguistic-Pretraining-CVLP" class="headerlink" title="Contrastive Visual-Linguistic Pretraining (CVLP)"></a>Contrastive Visual-Linguistic Pretraining (CVLP)</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-1.png"></p><p>CVLP的结构包括Query Network (QueryNet)和Key Network (KeyNet)，它们都包含一个语言Transformer编码器，一个视觉Transformer编码器和一个多模融合Transformer编码器，初始化时，QueryNet和KeyNet具有相同的参数，QueryNet使用可视化和文本输入的masking策略来生成跨模态嵌入，而KeyNet将mask仅应用于文本输入，生成上下文化的可视特性，KeyNet将输出推入一个动态内存队列中，连续生成负样本来计算交叉模态对比损失，利用跨模mask语言建模损失、匹配损失和对比损失的组合对整个CVLP模型进行训练</p><h3 id="Multi-modality-Fusion"><a href="#Multi-modality-Fusion" class="headerlink" title="Multi-modality Fusion"></a>Multi-modality Fusion</h3><p>给定来自视觉语言数据集的图像-句子对，作者首先使用WordPieces技术和映射一个token $W_j$到它相应的嵌入$h_{emb}(W_j) \in R^{d_w}$，其中$d_w=768$，视觉位置bbox B和视觉特征F，通过Faster R-CNN得到，$B,F=RCNN(I)$，然后计算CVLP的视觉输入和文本输入</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-2.png"></p><p>$g_F$和$g_{P-ROI}$是两个全连接层，负责对$F_i$和$B_i$做映射，$h_{P-word}$是一个位置编码函数，CVLP同时在QueryNet和KeyNet上做mask，选择$15%$的输入文本token做替换，一部分token被替换为特殊的[MASK] token，另一部分用随机的token替换，对于视觉区域，作者使用不同的mask策略:所选区域的特征可以被设为零，也可以被其他图像的区域特征所替代，与QueryNet不同，KeyNet只对文本输入使用mask，同时保持所有可视区域特性不变。KeyNet和QueryNet被初始化为具有相同的层和参数，它们都包含9层语言Transformer编码器，5层视觉Transformer编码器和5层的多模融合Transformer编码器</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-3.png"></p><p>其中，$r_i$在视觉分支中代表一个自我注意层，$l_i$在语言分支中代表一个自我注意层，$co_i$在多模态融合分支中代表一个共同注意层</p><p>三种编码器分别由视觉自注意模块、语言自注意模块和视觉-语言共注意模块实现，视觉自注意利用注意模型中的关键、查询和值特征进行区域特征之间的信息融合，将关键，查询和价值的视觉特征记为$K_v$，$Q_v$，$V_v$，相应的语言特征为$K_w$，$Q_w$，$V_w$，模内信息融合可以表示为：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-4.png"></p><p>其中，Transformer层的注意模块可表示为:</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-5.png"></p><p>然后用模间融合模块来融合语言和视觉特征的信息，模间融合过程是双向的，包括从语言到视觉的信息融合和从视觉到语言的信息融合</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-6.png"></p><p>通过模内/模间特征融合，可以得到一个多模上下文特征嵌入，上下文特征在一个紧凑的特征向量中编码多模态交互，基于上下文特征在CVLP中用于语言分支的mask loss和视觉分支的对比loss</p><h3 id="Mask-Loss-for-Language-Branch"><a href="#Mask-Loss-for-Language-Branch" class="headerlink" title="Mask Loss for Language Branch"></a>Mask Loss for Language Branch</h3><p>在预训练阶段，CVLP相比于LXMERT执行了许多不同的pretext task，CVLP不包含监督任务，因此不依赖于人工标注，对于语言分支，作者将mask语言建模和图像-语言匹配预测作为两个代理任务</p><p>mask loss是由BERT首先提出的，后续的ViLBERT方法除了语言mask loss外，还增加了视觉特征mask loss</p><p>这个损失mask上下文表示，并利用上下文信息预测了mask特征，通过优化mask loss，Transformer隐式地学习了对上下文信息的编码，这有助于对下游任务进行泛化，在CVLP中，作者只对文本输入使用mask loss。此外，还增加了一个匹配损失，它涉及到一个二值Yes/No分类来预测句子是否与视觉特征匹配， mask loss可以用下面的形式来表示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-7.png"></p><p>$\theta$表示语言Transformer编码器的参数，$w_m$和$\overline{w/m}$是要预测的mask token和没有被mask的上下文token</p><p>匹配损失定义为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-8.png"></p><p>$W_{CLS}$表示[CLS] token，在图片-文本匹配的代理任务中对视觉-语言信息进行编码</p><h3 id="Contrastive-Loss-for-Visual-Branch"><a href="#Contrastive-Loss-for-Visual-Branch" class="headerlink" title="Contrastive Loss for Visual Branch"></a>Contrastive Loss for Visual Branch</h3><p>对比学习通过从一组负特征中区分视觉上相似的特征对来进行自我监督的表征学习，通过将Faster R-CNN提取的视觉区域特征输入到QueryNet和KeyNet中可以获得正向query-key对，其他batch的所有区域特征都被用作负键，然后通过更新网络权值进行对比学习，使以下损失最小化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-9.png"></p><p>$\tau$表示the temperature of Softmax(?)，$v_i^{key+}$是$v_i^{query}$的所有正键(positive key)，$v_j^{memory-queue}$作为计算$L_{contrast}$的负样本</p><p>传统的对比学习方法受到反例数量的限制，实际过程中， 获得大量的负样本也是非常耗时的，受动量对比(MoCo)的启发，作者构建了一个动态的视觉记忆队列来存储KeyNet生成的特性，视觉记忆队列先为空，KeyNet生成的特性逐渐放入队列中，随着训练的进行，可以获得一个大的视觉队列作为负样本，对比学习的效果在很大程度上取决于视觉队列的特征多样性。一旦队列满了，就删除最早的特性。视觉记忆队列表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-10.png"></p><p>$\overline{v_{b,n}^i}$表示第i次迭代第b张照片的第n个区域的视觉特征，视觉记忆队列的一个缺点是训练过程中的特征漂移。随着神经网络的快速更新，所提取的特征可能很快就会过时，使得存储在视觉队列中的负样本失效，为了解决这个问题，作者将KeyNet的权重定义为QueryNet的移动平均线(moving average)，QueryNet是通过随机梯度下降训练的，网络的更新记为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-11.png"></p><p>m是动量值(momentum value)，$\theta_k$和$\theta_q$是来自KeyNet和QueryNet中的参数值，这种对比学习方式在训练过程中视觉记忆队列大，特征漂移小，可以取得较好的学习效果</p><h3 id="Randomly-Layer-Dropping-Key-Network"><a href="#Randomly-Layer-Dropping-Key-Network" class="headerlink" title="Randomly Layer-Dropping Key Network"></a>Randomly Layer-Dropping Key Network</h3><p>对比学习训练无监督表示学习的一个重要因素是负样本的多样性，对比学习很容易过拟合，从而使表示学习过程失效，作者观察到，随着训练过程的进行，对比学习损失变得非常小，这表明已经发生过拟合，作者通过随机Layer-dropping关键网络，来增加存储在视觉记忆队列中的特征的多样性，droplayer策略包含KeyNet中self-attention和co-attention层的随机dropout，在对比学习的训练过程中，可以增加特征的多样性，防止过拟合，randomly layer-dropping Key Network可以表示如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-12.png"></p><p>SPL表示是否在某层进行随机drop，由上式可知，在预训练过程中，即使是KeyNet中的层也可能以0.5的抽样概率被丢弃</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>预训练模型在VQA Task上的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-13.png"></p><p>在多项任务上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-14.png"></p><p>attention可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CVLP-15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2020 </tag>
            
            <tag> 对比学习 </tag>
            
            <tag> VLP </tag>
            
            <tag> 预训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小样本学习</title>
      <link href="2020/08/12/smallSampleLearning/"/>
      <url>2020/08/12/smallSampleLearning/</url>
      
        <content type="html"><![CDATA[<p>记录一些小样本学习相关知识 (from 物体分类与检测中的小样本学习)</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>小样本学习意义</p><ol><li>特定任务场景下标注代价高昂，小样本学习旨在探索以低成本的标注形式完成原本高质量大规模标注的数据集才能完成的任务</li><li>数据具有长尾分布(long-tail distribution)的特点，数据集中一小部分类别经常出现，大量物体类别对应样本比较稀少，能否利用位于数据分布尾部的先验知识来辅助物体识别算法的训练，而不是简单地依赖这些很难获取到类别的少量样本进行监督学习训练，是很有研究意义和实用价值的</li></ol><p>小样本(Small Sample Learning)的定义</p><ol><li>测试类别的训练样本完全缺失</li><li>部分或者全部测试类别只有少量的训练样本</li><li>部分或者全部测试类别训练样本标注信息粗糙，不完整</li></ol><p><strong>物体分类</strong>中的小样本学习：分为零样本学习，单样本/少样本学习和半监督学习</p><p>—— 零样本学习 (Zero-Shot Learning)</p><p>指训练集和测试集类别完全不同</p><p>零样本学习需要引入<strong>额外的辅助信息</strong>，辅助信息包含属性特征，物体的文本描述，以及在大型文本语料库上学习到的对应物体类别名称的词嵌入</p><p>—— 单样本/少样本学习 (One/Few-Shot Learning)</p><p>用<strong>单张或者几张</strong>训练图片来学习针对测试类别的分类器，<strong>不需要辅助信息</strong>的引入，测试集和支撑集(support set)的类别是相同的</p><p>—— 半监督学习 (Semi Supervised Learning)</p><p>半监督学习比少样本学习任务有更多的训练样本，同时，可以利用<strong>大量无标注</strong>的图片进行训练，即需要用少量有标注的数据和大量无标注的数据实现分类目标</p><p><strong>物体检测</strong>中的小样本学习分为弱监督检测，半监督检测以及混合监督检测</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/smallSampleLearning-1.png"></p><p>—— 弱监督检测 (Weakly Supervised Detection)</p><p>只进行类别标注</p><p>—— 半监督检测 (Semi Supervised Detection)</p><p>全部类别标注，部分位置标注</p><p>只有类别标注的记为弱标注数据，有全部标注的记为强标注数据</p><p>—— 混合监督检测 (Mixed Supervised Detection)</p><p>同时利用弱标注数据和强标注数据，和半监督检测的区别是弱标注数据和强标注数据的类别没有重叠</p><p>小样本学习的研究思路</p><p>—— 数据扩充</p><p>零样本学习：用产生式模型从测试类别的辅助信息中直接产生测试类别的训练样本</p><p>半监督分类：1. 用产生式模型从少量标注样本中学习模拟类别的数据分布，依照数据分布产生大量样本进行训练；2. 借助课程学习(Curriculum Learning)/自步学习(Self-Paced Learning)思想，用少量标注图片得到初始模型，利用初始模型给无标注图片打上伪标签，从简单图片到困难图片，将这些图片依次加入到算法流程中，和标注图片一起进行模型训练</p><p>—— 元学习 (Meta-Task Learning)</p><p>不直接去学习特定类别的算法模型，先学习类别无关(category-independent)的任务，同时要求这种类别无关的任务对最终的小样本目标识别是有帮助的</p><p>零样本：学习一个类别无关的”视觉-语义”投影</p><p>单样本/少样本：直接用于模型参数更新的任务，比如学习快速更新的初始化参数，直接学习某一层网络对应的参数</p><p>混合监督检测任务：学习分类器-检测器差异，学习一般性的物体性知识(objectness knowledge)等</p><h2 id="小样本学习"><a href="#小样本学习" class="headerlink" title="小样本学习"></a>小样本学习</h2><p>这部分内容主要是介绍零样本学习和混合监督检测</p><h3 id="零样本学习"><a href="#零样本学习" class="headerlink" title="零样本学习"></a>零样本学习</h3><p>辅助信息的处理方式有</p><ol><li><p>将模糊的类别特征转化为精确的属性表达(量化的领域知识表达)，比如动物的食物来源(肉食/素食/杂食)</p></li><li><p>TF-IDF(Term Frequency-Inverse Document Frequency)处理为固定维度的特征表达，TF-IDF用于评估一个词对语料库的重要程度(和出现次数成正比，和出现频率成反比)，特征的维度是语料库中的词数，维度的具体数值是词在本段中的重要程度，那么类别相关的词，重要程度就会高，这种词往往代表了类别的特点</p></li><li><p>词嵌入(word-embedding)，把每个类别对应的名字(word)投射到多维空间，保证是单射(injective)，同时有结构保持特点(structure-preserving)，词嵌入的计算方式有skip-gram，CBOW(continue bag-of-words)，以及GloVe(Global Vectors)，前两种采用局部邻域信息，GloVe是计算单词的全局频率信息，词向量要求：1.语义相似的单词词向量也相似；2.具有语义类比性质，Beijing - China = Paris - France</p></li></ol><p>零样本学习方法</p><p>数据扩充：分为直接产生图片和直接产生图片特征两种</p><p>元学习：根据元任务的不同，零样本学习分为以下三类</p><p>(1) 元任务设置为属性分类器</p><p>首先在训练类别上训练一个类别无关的属性分类器，测试阶段测试图片对应的属性通过属性分类器直接获得，然后搜寻测试类别集合中拥有最近似属性的类别，实现分类</p><p>(2) 元任务设置为通用的嵌入空间</p><p>用通用的嵌入空间(embedding space)来联结每个类别对应的图片特征表达和辅助信息表达，首先在训练类别上学习视觉-语义空间，在测试阶段将测试图片的特征和各个测试类别的辅助信息同时映射到嵌入空间，通过比较嵌入空间图片的特征和各个测试类别辅助信息的距离远近，通过简单的最近邻搜索即可得到测试图片对应的类别预测</p><p>(3) 元任务设置为类别关系</p><p>首先学习测试类别和训练类别的关系，将测试类别看成是多个训练类别的线性组合，将训练类别上得到的分类器直接迁移到测试类别上</p><p>使用调和平均数的gZSL评价方法更贴近零样本学习的现实应用场景</p><h3 id="混合监督检测"><a href="#混合监督检测" class="headerlink" title="混合监督检测"></a>混合监督检测</h3><p>为解决标注代价高的问题，研究人员提出了弱监督(Weakly Supervised Detection)方法，只使用类别标签，推理物体的精确位置，但是效果不好，所以有了混合监督检测，做法是用一些类别的全标注数据，去提升新类别的弱监督检测能力</p><p>混合监督检测的基本思路是从全标注类别上学习某种对于检测有用的知识(比如物体性知识)，如果这种知识本身是类别无关的，则可以直接用到弱标注的类别上，如果是类别相关的，则需要继续进行类别关系学习这种元任务</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小样本学习 </tag>
            
            <tag> 元学习 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VQA as Meta Learning Task [元学习]</title>
      <link href="2020/08/11/metaLearningVQA/"/>
      <url>2020/08/11/metaLearningVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1711.08105">Paper Download Address</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>VQA是一个典型的监督学习任务，一个经过训练的VQA系统只能从一个与训练集非常相似的分布中产生正确的答案，扩展模型知识或扩展它的领域覆盖只能通过重新训练模型来达到，这造成了大量的计算花费，所以这种方法根本无法实现VQA的最终承诺，即回答关于一般图像的一般问题</p><p>为了解决这些问题，作者提出了元学习(meta-learning)的方法，使模型学会学习(learn to learn)，在测试的时候，模型会从支持集(support set)中学习一些样本以回答给定问题</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-1.png"></p><p>支持集不是固定的，而且需要注意，支持集可能很大，而且它的大多数元素可能与当前问题无关，它在测试时被提供给模型，并且可以通过附加的示例进行扩展，以扩展模型的能力，所谓的模型”学会学习”就是在测试时动态地识别和利用潜在的大型支持集中的相关示例，因此，向模型提供更多的信息不需要再重新训练，而利用这种支持集的能力极大地提高了系统的实用性和延展性，一个实际的VQA系统最终需要适应新的领域，并随着可用数据的增加而不断改进。这是一个长期的目标，而这项工作只是朝这个方向迈出了一小步</p><p>文章的主要贡献是将SOTA的VQA模型应用到了元学习的场景下，得到的模型是一个深度神经网络，它使用一系列动态参数——也被称为快速权值——根据提供的支持集在测试时确定，动态参数允许自适应地修改由网络执行的计算，并根据支持集调整其行为，作者进行了详细的研究，以评估这些技术在不同的训练体制和支持集大小下的有效性，这些实验是基于VQA v2基准测试的，为此作者提出了适当的数据分割来研究元学习设置</p><p>通过这种方法产生的系统拥有一种新的能力，即产生全新的答案(不曾在训练集中出现过的答案)，同时这个系统改进了对稀有答案的处理，由于VQA的数据集显示出严重的类不平衡，少数的答案比大多数其他的答案更频繁，模型很容易回到频繁的”安全”答案，相比之下，所提出的模型本质上不太可能成为数据集bias的受害者，而且对罕见的答案有更高的召回率，所提出的模型在总的准确率上并没有超过现有的方法，这是可以预料到的，因为它没有过拟合数据集的bias，但是它仍然展示了令人满意的总体表现</p><p>文章的贡献有:</p><ol><li><p>将VQA视为元学习，在测试时提供一个支持集</p></li><li><p>描述了一个采用元学习的神经网络架构和训练过程，模型基于SOTA的VQA系统，从最近的元学习文献中获得灵感</p></li><li><p>提供了在不同的训练体制和支持集大小和跨越不同的设计选择的模型实验评估</p></li><li><p>结果证明了该模型的独特能力，产生新的答案，即在训练中从未见过的答案，通过学习支持实例，提高了对罕见答案的回忆，并比现有模型有更好的样本效率</p></li></ol><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>VQA部分作者介绍VQA和引入外部知识库的VQA，略</p><h3 id="Meta-learning-and-few-shot-learning"><a href="#Meta-learning-and-few-shot-learning" class="headerlink" title="Meta learning and few shot learning"></a>Meta learning and few shot learning</h3><p>元学习旨在让模型”学会学习”，它适用于学习类似梯度下降的算法来更快地训练或微调神经网络，以及学习可以在测试时直接输入训练示例的模型。文中提出的方法属于后一种，VQA被视为一个分类任务，在测试时，提供一些例子来说明可能的答案——可能每个答案都有少量的答案，由于有大量的类，大多数现有的方法并不直接适用于文中的设置</p><p>文中的模型在神经网络中引入了一组记忆单元，使用动态权值参数化的网络层，其中一个记忆单元存储loss的梯度，最后的输出阶段，通过答案类别的相似性来计算评分</p><h3 id="Continuum-learning"><a href="#Continuum-learning" class="headerlink" title="Continuum learning"></a>Continuum learning</h3><p>元学习的VQA模型的重要意义是能够随着可用数据的增加而改进，这涉及到增量学习和连续学习的领域，这些工作的重点是通过新的训练数据、输出类和/或任务对网络进行微调，相比之下，文中的模型不会随着时间的推移而自我修正，也不会经历消极的领域转移或灾难性遗忘，而这正是连续学习的核心问题，文中提出的框架的一个重要动机是，它可以应用于支持与问题/答案示例不同性质的数据，这将允许利用一般的，非vqa特定的数据，例如从知识库或网络搜索</p><h2 id="VQA-in-a-Meta-Learning-Setting"><a href="#VQA-in-a-Meta-Learning-Setting" class="headerlink" title="VQA in a Meta Learning Setting"></a>VQA in a Meta Learning Setting</h2><p>VQA的传统方法是在监督环境下进行的，训练一个模型来映射一个输入问题Q和图像I来对候选答案进行评分，作者通过引入支持集对该形式进行了扩展，支持集中可以包含训练集中没有的答案</p><p>为了利用支持集中包含的信息，模型必须学会在测试时动态地使用这些示例，而不需要对整个模型进行重训练</p><h2 id="Proposed-Model"><a href="#Proposed-Model" class="headerlink" title="Proposed Model"></a>Proposed Model</h2><p>模型如图所示，从BUTD基础模型扩展而来</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-2.png"></p><p>作者将模型结构划分为两个部分：嵌入部分(对图片和问题进行编码)和分类部分(预测答案)，文章的贡献主要集中在第二部分，嵌入部分遵循BUTD的实现，即问题嵌入采用GloVe和GRU，图像嵌入使用CNN，并结合了BUTD注意力和问题导向注意力，嵌入的融合采用Hadamard积，记为h，传统方法中对h进行分类通常采用一个非线性层和一个线性的softmax或sigmoid，作者在这里用元学习替代</p><h3 id="Nonlinear-Transformation"><a href="#Nonlinear-Transformation" class="headerlink" title="Nonlinear Transformation"></a>Nonlinear Transformation</h3><p>非线性变换的目的主要是将联合嵌入h投射到适合分类的表示上，这种转换可以在具有任意类型非线性层的神经网络中实现，这里作者使用了一个门控双曲切层</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-3.png"></p><p>$\sigma$是一个logistic激活函数，$W$和$W’$是可学习权值矩阵，$b$和$b’$是可学习偏移量，$\circ$表示Hadamard积(元素点乘)，定义$\theta$为向量化的权重和偏移量的矩阵连接，$\theta=[W_:;W_:’;b;b’]$，这个向量包含了非线性变换所使用的所有权值和偏移，传统模型在训练阶段通过反向传播和梯度下降来学习$\theta$，在测试阶段保持静态，作者提出应该在测试时根据输入h和可用的支持集自适应地调整权重，用传统方法学习静态参数$\theta^s$，在测试阶段获得动态参数$\theta^d$，然后将两者结合$\theta=\theta^s+w\theta^d$，$w$为可学习权重，因此，动态权值可以看作是根据输入h对静态权值的调整</p><p>在关联存储器M中保存一组候选动态权值，存储的是一个key/value对的一个大集合(和支持集一样大)，$M={(\overline{h}_i,\overline{\theta}<em>i^d)}</em>{i \in 1\dots|S|}$，测试的时候，就可以进行动态参数的关键值匹配检索</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-4.png"></p><p>$d_{cos}(\cdot,\cdot)$是余弦相似度函数</p><h3 id="Mapping-to-Candidate-Answers"><a href="#Mapping-to-Candidate-Answers" class="headerlink" title="Mapping to Candidate Answers"></a>Mapping to Candidate Answers</h3><p>函数$g_\Phi(h)$将非线性层的输出映射到一个候选答案集的分数向量，这通常是通过简单的仿射或线性变换来实现的，$g_\Phi(h)$本质上输入h和代表可能的答案的原型$\Phi={\phi^a_i}_{i,a}$之间的相似性度量，在传统的模型中每个原型对应权值矩阵的一行，而在作者提出的模型中，可以用多个原型来表示答案a，即表示为${\phi_i^a}_{i=1}^{N^a}$，直观上，当a是正确答案时，原型代表了典型的期望特征向量，因此，h’与a对应原型之间的相似度就可以作为a的得分，如果有多个原型可用，那得分就是取平均值:</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-5.png"></p><p>$d(\cdot,\cdot)$是相似性测量，$\sigma$是sigmoid(logistic)激活函数，将相似度投射到$[0,1]$，$b’’$是可学习的偏移项，传统模型的相似性函数都是采用的点积，本文采用了点积，和L-p范数分别作为相似性度量的函数</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-6.png"></p><p>文中模型用了两种原型(prototype)，静态$\Phi^s$和动态$\Phi^d$，静态在反向传播和梯度下井时候学习，动态的在测试时候通过支持集决定，最终的prototype为$\Phi=\Phi^s \cup \Phi^d$，当只用静态的原型$\Phi^d$，以及用点积$d_{dot}(\cdot,\cdot)$作为相似度测量时，文中模型和原BUTD模型相同</p><p>最后，损失函数采用交叉熵</p><h3 id="Processing-of-Support-Set"><a href="#Processing-of-Support-Set" class="headerlink" title="Processing of Support Set"></a>Processing of Support Set</h3><p>在函数$f_\theta$和$g_\Phi$中用到的动态参数是取决于支持集的，模型在网络中以前向和后向传播处理整个支持集：support set的处理会在测试过程中，先于预测答案发生。而在训练过程中，它会在每个epoch之前重复进行，随着训练的进行而不断改变的网络静态参数。我们将支持集记为$S$，它的每一个元素，它的特征向量$h$还有loss的梯度，都和静态的权值$\theta$相关，然后将$h$和梯度$\nabla \theta$添加在记忆M中，记忆M就会保留最后处理的那个元素</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-7.png"></p><p>为了确定动态原型的集合$\Phi^d$，作者收集了所有支持集实例的特征向量$h’=f_\theta(h)$，然后计算它们在具有相同正确答案的实例上的平均值，对于答案a来说其动态原型为$\phi^a=\frac{1}{N^a}\sum_{i:\hat{s}^a_i=1}^{N^a}$</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>实验需要验证三个方面：</p><ol><li><p>模型及其不同组件如何有效地使用支持集</p></li><li><p>支持集对VQA来说有多有用</p></li><li><p>是否能够从数据集中学习到不同层面的东西</p></li></ol><p>消融实验</p><p>在作者提出VQA-Numbers(VQA2.0的一个split)上实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-8.png"></p><p>对support set进行评估，动态原型+动态权值带来比较大的提升，仅有动态权值效果不好</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/metaLearningVQA-9.png"></p><h2 id="Conclusions-and-Future-Work"><a href="#Conclusions-and-Future-Work" class="headerlink" title="Conclusions and Future Work"></a>Conclusions and Future Work</h2><ol><li><p>模型在实际应用时需要处理动态权值的内存，目前动态权值随支持集线性增长，聚类可能可以减少其规模，同时哈希方法也许可以加快内容检索的效率</p></li><li><p>支持集可以替换为web搜索或者知识库</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> 元学习 </tag>
            
            <tag> ECCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPAIT [小样本学习]</title>
      <link href="2020/08/11/FPAIT/"/>
      <url>2020/08/11/FPAIT/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dl.acm.org/doi/10.1145/3240508.3240527">Paper Download Address</a></p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>构建一个具有人类智慧的AI系统是一个非常大的挑战，这样的AI系统需要具有的其中一个重要的能力是从少量的样本中快速学习到新的内容，特别是多模态场景。最近有很多关于图片或者语言的小样本学习(few-shot)的尝试，但是很少在多模态问题上做小样本学习，这需要同时利用好图片和语义知识。在多模态场景下的小样本学习更具现实意义，比如，亚马逊每周会推出数千件新产品，这些产品在描述和新产品图片中都包含了不常见的词语，共同了解图片/文字及其关系，比只关注图片或文字更能更好地向客户推荐这些新产品</p><p>在本文中，作者从小样本图像字幕和VQA两个方面来研究小样本多模态学习，图像字幕和VQA的示例如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-1.png"></p><p>对于这两个任务，现有的算法大多集中在监督学习上，因此需要大量的人工标注的图像文本对来进行训练，由于一些单词在少数场景中是不常见的，甚至不曾出现，这些监督算法不能很好地处理这些新单词。现在有一些关于图像字幕和VQA的新出现对象的研究，它们通常利用包含新单词的大型外部文本数据库来学习文本表示。这样，他们的文本模型可以理解新单词，即使这些单词不在训练图像-文本对中</p><p>相比之下，小样本学习更加困难，因为新的目标对象或单词不能以任何形式出现在训练数据中，这样一来，他们的文本模型就难以学习到新单词的更好的表示，从而导致性能下降，因此现有的算法不适合小样本的图像字幕或者VQA学习</p><p>作者提出了图像文字模型的快速参数适应方法(FPAIT)，以解决小样本问题，FPAIT的主要思想是知道图片文字联合学习器如何去学习，传统算法的核心思想是学习一个模型来拟合数据，FPAIT则指导模型如何在新的任务中只用少量样本更好更快地泛化，具体来说，FPAIT通过几个例子，对联合的图像-文本学习器进行大量不同的视觉语言任务训练(如图所示)，FPAIT是为了获得良好的图像-文本联合学习器的初始参数，使其通过几个更新步骤就能最大限度地提高新任务的性能</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-2.png"></p><p>由于该初始化是从多个不同的任务中训练出来的，因此该模型的内部表示应该适合于各种任务，即具有良好的泛化性，因此，FPAIT在新的任务上只需要很少的微调步骤就可以取得很好的效果</p><p>现有的算法通常使用最先进的cnn对图像特征进行编码，这些CNN模型需要大量的训练数据才能保证良好的性能，但是，在本文的设置中，一个任务可能只有5个训练样例，因此，这样小的训练数据会引入大的bias，这对CNN模型是有害的，为了克服训练数据小的影响，FPAIT引入了对图像特征的动态线性变换，这些线性变换被整合到CNN模型中来缩放和移动中间特征，这样bias能够得到减缓，此外，这些线性变换的参数是由经过编码的文本特征生成的，这样文本数据就可以有效地影响图像特征，实验表明，所提出的FPAIT新架构优于典型的图像和文本嵌入方法</p><p>本文的贡献有</p><ol><li><p>提出FPAIT来处理小样本图案品字幕和VQA，经过FPAIT训练的模型可以在少量样本的情况下快速对新任务做出自适应</p></li><li><p>提出了一种先进的神经网络来完成图像文本对小样本学习的任务，该网络从文本数据中生成动态参数，并利用这些参数有效地影响图像编码</p></li><li><p>FPAIT在图像字幕和VQA任务中取得了很好的效果</p></li></ol><h2 id="RELATEDWORK"><a href="#RELATEDWORK" class="headerlink" title="RELATEDWORK"></a>RELATEDWORK</h2><p>图像字幕相关的内容略过</p><h3 id="Visual-Question-Answering"><a href="#Visual-Question-Answering" class="headerlink" title="Visual Question Answering"></a>Visual Question Answering</h3><p>VQA模型的关键是如何结合图像和文本内容，传统的对问题和图像得到联合嵌入的方法需要大量的监督学习，因此不适合小样本的研究</p><p>为了解决VQA中新出现对象的问题，采用的方法一般是引入外部知识库，而作者提出了一个更困难的设置，即新概念不能出现在任何预训练数据中，<a href="https://arxiv.org/abs/1711.08105v1">Teney et al</a>提出了基于相似的元学习方法来完成小样本VQA学习，他们只在小型的只包含七类问题的VQA-Number数据集上评估算法，他们在大规模数据集上缺乏有效的证据</p><h3 id="Few-shot-learning"><a href="#Few-shot-learning" class="headerlink" title="Few-shot learning"></a>Few-shot learning</h3><p>现有的优化算法需要大量标记数据来更新深度cnn。因此，当仅有少量的训练实例可用时，它们的表现很差，少量示例学习(few-examples learning)允许使用未标记数据，而小样本学习(few-shot learning)则不能。在本文中，关注的是小样本学习设置</p><p>这里有几种值得注意的小样本学习方法，<a href="https://arxiv.org/abs/1703.00837">Munkhdalai et al</a>研究了针对小样本分类模型的复杂权值更新方案，<a href="https://arxiv.org/abs/1703.03400v3">Finn et al</a>约束元学习器使用普通的梯度下降更新基础学习器，作者主要follow第二篇，而与之不同的是，作者采用图片文本对作为输入而非单纯的图片。此外，为了克服多模态场景中小样本训练的副作用，作者利用文本特征生成动态参数来自动对图像特征进行归一化</p><h2 id="METHODOLOGY"><a href="#METHODOLOGY" class="headerlink" title="METHODOLOGY"></a>METHODOLOGY</h2><p>FPAIT的思路源于元学习和条件归一化，元学习通常关注于小样本的图像分类，而FPAIT将其扩展到图像和文本的联合建模，并且FPAIT通过条件归一化来克服模型中的少量样本导致的bias</p><h3 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h3><p>将VQA问题中的图片记为$I$，问题记为$Q$，生成自然语言答案的函数记为$f$，设有$C$种不同种类的答案，函数f可以是一个神经网络，它将Q和I映射到C个候选答案的置信度分数，$p = f(Q, I)$，$p \in R^c$表示置信度分数，大多数现有的算法通常以$y=argmax_ip_i$作为最终的预测</p><p>大多数图像字幕或VQA方法通过最大化正确答案或空词的可能性来学习f的参数的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-3.png"></p><p>其中$i$为训练数据的下标，$P$为条件概率，为了对性能进行评价，$f_{\theta}$对每个测试数据进行反馈，得到预测的结果或描述，通过一些评价指标来计算评价性能</p><h3 id="Fast-Parameter-Adaptation"><a href="#Fast-Parameter-Adaptation" class="headerlink" title="Fast Parameter Adaptation"></a>Fast Parameter Adaptation</h3><p>区别于传统的步骤 (上文那个式子)，作者采用的是元学习的步骤，要求学习模型能够在来自p(T)的不同任务样本上取得良好的性能，而不仅是传统设置的单个任务，如果few-shot是K-shot N-way的话，那么一共就需要K×N个样本，为了解决这个元学习问题，FPAIT学习了一个良好的初始化值$f_{\theta}$，以便能够快速适应从p(T)中采样的不同任务，经过训练的联合文本图像学习器$f_{theta}$应该根据这K个训练样本快速调整其参数，然后对T中的新样本进行良好的推广，当$f_{\theta}$适应了特性的T时，作者在这个T中采样新例子对f进行评估</p><p>将参数设为$\theta$，适应后的参数设为$\theta’$，假设使用基本随机梯度下降的一次梯度更新来进行参数自适应，计算参数的式子为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-4.png"></p><p>这里使用一个梯度步骤来简化符号，而参数适应算法Opt还可以使用SGD或Adam的多个梯度步骤</p><p>元学习的过程如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-5.png"></p><p>目标函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-6.png"></p><h3 id="FPAIT-Architecture-and-Algorithm"><a href="#FPAIT-Architecture-and-Algorithm" class="headerlink" title="FPAIT Architecture and Algorithm"></a>FPAIT Architecture and Algorithm</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-7.png"></p><p>编码图片的CNN包含四个卷积块，每个卷积块包含一个$3\times 3$的卷积层和一个BN层以及ReLU激活，特征通道分别为64，96，128和256，在前三个卷积块之后，有三个池化层，步长为2，在最后一个卷积块之后有一个全局池化层，最后得到的是一个256维的向量</p><p>问题则被编码为512维的特征向量</p><p>传统的特征融合方式如图(a)所示，这种模型需要大量的数据来训练，由于训练样例少而引入的模型偏差大，会影响性能，此外，在多模态场景中，模型不仅要学习图像/文本信息，还要学习它们之间的关系，此时模型偏差问题变得更加严重，为了缓解小样本多模态场景中的模型偏置问题，作者采用了一个带有动态参数的变换函数</p><p>对于这个变换函数，可以由多种选择，比如卷积层或全连接层，作者在文章中采用了Channel-wise Linear<br>Transformation(CLT)，设文本编码器为g，将文本Q作为输入产生文本特征g(Q)，对于CNN中第c层的特征，CLT的参数$\gamma_c$和$\beta_c$为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-8.png"></p><p>$g_\gamma$和$g_\beta$为全连接层，$F_c$表示CNN第c层的输出，$\gamma_c$和$\beta_c$为两个向量，维数和$F_c$的通道数相同，如图(b)所示，在每个bn层后接CLT</p><p>答案预测则是使用了三层的MLP，前两层输出维度为512，最后一层输出每个答案的概率</p><p>损失函数为$f(I,Q)$和GT之间的交叉熵损失</p><p>这里采用了一个非常简单的CNN，没有用复杂的CNN，比如resnet-101，这是因为复杂的CNN容易过拟合</p><h2 id="EXPERIMENTAL-EVALUATION"><a href="#EXPERIMENTAL-EVALUATION" class="headerlink" title="EXPERIMENTAL EVALUATION"></a>EXPERIMENTAL EVALUATION</h2><p>在Toronto COCO-QA上的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-9.png"></p><p>定量分析</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/FPAIT-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> ACMMM </tag>
            
            <tag> 小样本学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReGAT [多类型图结构]</title>
      <link href="2020/08/07/ReGAT/"/>
      <url>2020/08/07/ReGAT/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1903.12314">Paper Download Address</a></p><p><a href="https://github.com/linjieli222/VQA_ReGAT">Code Download Address</a></p><hr><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>现有的达到SOTA的VQA系统大部分致力于学习图片和问题的多态联合表示，框架通常为：CNN识别图片区域+RNN编码问题+图片每个区域和问题做联合表示+分类器，这个框架被证明在VQA上是比较有效的</p><p>但是图片和自然语言之间仍存在语义鸿沟，比如给定一张斑马的照片，模型可能可以识别黑白像素，但是不知道哪个黑白像素是来自哪只斑马，那么这就使得诸如”最右边的斑马是小斑马吗”以及”所有的斑马都在吃草嘛”这类问题很难被回答，VQA系统不仅需要在图片和语言中识别目标(zebras)和周围的环境(grass)，还要理解动作的语义(eating)和位置(at the far right)</p><p>这一类的信息需要模型超越单纯的目标检测，学习图像中视觉场景更整体的信息，一个方向是学习目标之间的位置关系(motorcycle-nextto-car)，另一个方向是学习目标之间的依赖关系(girl-eating-cake)</p><p>基于这个观点，作者提出了Relation-aware Graph Attention Network (ReGAT)，用一种新的关系编码器来捕获目标之间的关系。这些视觉特征代表了图像中更细粒度的视觉信息，提供了更为整体的场景解释，对回答复杂语义的问题有所帮助。出于对图像场景和问题类型的高差异的考虑，关系编码器学习了显性 (如空间/位置、语义/可操作) 关系和隐性关系，其中图像以图结构表示，通过图注意机制捕获对象之间的关系</p><p>此外，图注意是基于问题来学习的，在关系编码阶段可以通过问题注入语义信息，这样，关系编码器学习到的特征不仅捕捉了图像中对象交互的视觉内容，而且结合了问题中的语义线索，动态关注每个问题的特定关系类型和实例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-1.png"></p><p>模型的整体框架如图，首先用Faster R-CNN来生成目标候选区域集，用一个问题编码器得到问题嵌入，接着每个区域的bbox和卷积特征被注入到关系编码器中，从图像中学习能感知关系、问题自适应、区域级别的表示，最后这些能感知关系的视觉特征和问题嵌入被输入到多模式融合模块中生成联合表示，该联合表示用于答案预测模块以生成答案</p><p>不同于以往的VQA系统，这篇文章的模型提出了一个新的维度：使用问题自适应的对象间关系来丰富图像表示，以提高VQA的性能</p><p>文章的贡献如下：</p><ol><li><p>提出了一个基于图的关系编码器，通过图注意网络学习视觉对象之间的显性和隐性关系</p></li><li><p>学习到的关系是问题自适应的，可以动态捕获与每个问题最相关的视觉对象关系</p></li><li><p>ReGAT model能够在VQA 2.0中提高SOTA VQA模型，并且作者提出的模型在VQA-CP v2中达到了SOTA</p></li></ol><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Visual-Question-Answering"><a href="#Visual-Question-Answering" class="headerlink" title="Visual Question Answering"></a>Visual Question Answering</h3><p>目前VQA系统的主流框架包括图片编码器，问题编码器，多模态融合和答案预测器，近期的一些研究在图像方面探索了各种图像注意机制来定位与问题相关的区域，而在问题表达方面，有研究提出在编码阶段融合视觉和文本信息，协同问题引导图像注意力和图像引导问题注意力，还有研究探索了更高阶的融合方法，更好地结合文本信息和视觉信息(比如用双线性池化方法替代简单的元素点积，矩阵拼接，相乘等)</p><p>为了使模型更具有解释性，一些文献探索了图像更高层的语义信息，比如属性，标签和视觉常识，这些方法大多采用VQA-independent模型从图像中提取语义知识，<a href="https://arxiv.org/abs/1805.09701">R-VQA</a>中提出了relationship-vqa数据集，直接挖掘基于vqa的关系事实，以向模型提供额外的语义信息，也有一些研究了如何利用记忆来辅助推理步骤，特别是对于困难的问题</p><p>然而，记忆或高级语义信息所带来的语义知识通常都被转换为文本表示，而不是直接作为视觉表示，视觉表示包含着关于图像的更丰富、更有指示性的信息。作者将对象关系直接编码到图像表示中，关系编码步骤是通用的，可以结合到任何VQA模型中</p><h3 id="Visual-Relationship"><a href="#Visual-Relationship" class="headerlink" title="Visual Relationship"></a>Visual Relationship</h3><p>视觉关系在深度学习流行起来之前就被广泛研究过，早期工作将目标关系作为目标检测的后处理步骤，对于检测到的目标进行重打分，之前的一些研究也探讨了空间关系对改善图像分割的作用</p><p>视觉关系在很多计算机视觉任务上起到了关键的作用，它辅助了图像字幕的认知任务，改善了图像搜索和目标定位。近期视觉关系的研究更多地关注非空间关系，或是说语义关系，一些神经网络结构已经被设计用于视觉关系预测任务</p><h3 id="Relational-Reasoning"><a href="#Relational-Reasoning" class="headerlink" title="Relational Reasoning"></a>Relational Reasoning</h3><p>作者将前文提到的视觉关系定义为显性关系，这种关系对图像字幕任务非常有帮助，可以根据这些关系构建图结构，用图卷积网络来学习目标表示</p><p>另一个研究方向是隐性关系，即没有明确的语义或空间关系被用来构造图，所有的关系都隐式地由注意模块或通过输入图像的全连通图这种高阶方法捕获，比如通过使用简单的MLP对图像中所有可能的对象对进行推理，或是双线性融合方式</p><p>此外，还有一些研究提出了图像的问题导向图表示，<a href="https://forever97.github.io/2020/08/05/1806-07243/">Conditioned Graph Structures</a>提出了一种图学习模型，采用了基于关系对的注意力和空间图卷积，<a href="https://arxiv.org/abs/1609.05600">Graph-Structured Representations</a>探索了结构化的问题表示方式，比如解析树，利用GRU对对象和语之间的上下文化交互进行建模，<a href="https://arxiv.org/abs/1812.04794">Neighbourhood Watch</a>引入了一个类间/类内边定义的稀疏图，通过语言引导的图注意机制隐式学习其中的关系</p><p>然而，所有这些工作无一例外关注在隐性关系上，这比显性关系更难解释</p><p>ReGAT同时考虑了显性和隐性的关系来丰富图像的信息，对于显性关系，使用Graph Attention Network(GAT)而非简单的GCN，GAT的优势在于可以为领域节点分配不同的重要度，对于隐式关系，模型学习了一个图，该图通过过滤掉与问题无关的关系来适应每个问题，而不是平等地对待所有的关系，作者进行了消融实验来验证了每个模块的重要性</p><h2 id="Relation-aware-Graph-Attention-Network"><a href="#Relation-aware-Graph-Attention-Network" class="headerlink" title="Relation-aware Graph Attention Network"></a>Relation-aware Graph Attention Network</h2><p>VQA任务可以被定义为给定一个图片对应的问题，目标是预测GT的一个最佳匹配，VQA文献中常见的做法是，将其视为一个分类问题：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-2.png"></p><p>前文的模型结构图中已经详细地给出了模型的结构，模型包含了一个图片编码器，问题编码器和一个关系编码器，图片编码器中使用了Faster R-CNN来识别目标集，每个目标包含一个2048维的特征和一个表示目标位置的4维bbox，问题编码器中使用GRU和自注意力来产生1024维的问题嵌入，下文将详细介绍关系编码器</p><h3 id="Graph-Construction"><a href="#Graph-Construction" class="headerlink" title="Graph Construction"></a>Graph Construction</h3><h4 id="Fully-connected-Relation-Graph"><a href="#Fully-connected-Relation-Graph" class="headerlink" title="Fully-connected Relation Graph"></a>Fully-connected Relation Graph</h4><p>通过将图像中的每个对象$v_i$视为一个顶点，可以构造一个全连通的无向图，每条边代表了两个对象之间的隐式关系，可以通过图注意力分配给每条边的可学习权值来体现，所有权值都是隐式学习的，不需要任何的先验知识，作者将建立这个图结构上的关系编码器称为隐式关系编码器 (implicit relation encoder)</p><h4 id="Pruned-Graph-with-Prior-Knowledge"><a href="#Pruned-Graph-with-Prior-Knowledge" class="headerlink" title="Pruned Graph with Prior Knowledge"></a>Pruned Graph with Prior Knowledge</h4><p>如果顶点之间存在显式关系，则可以通过修剪不存在相应显式关系的边，将全连通图转换为显式关系图，对于每对对象$i$和$j$，如果$<i-p-j>$是一条有效的关系，那么就创建一条边，边标签为$p$，此外，对于每个点创建一个自环，标上$identical$，通过这种方式，图将变得稀疏，每条边都编码了内部关系的先验知识，作者将建立在此图上的关系编码器命名为显式关系编码器 (explicit relation encoder)</p><p>这些特征的显式本质要求预训练的分类器以离散标签的形式提取关系，在这张裁剪过的图上可以学习到不同种类的显式关系，作者探索了空间结构图和语义图</p><h5 id="Spatial-Graph"><a href="#Spatial-Graph" class="headerlink" title="Spatial Graph"></a>Spatial Graph</h5><p>设$spa_{i,j}=<object_i-predicate-object_j>$表示目标i和j的空间关系，作者将$spa_{i,j}$分为11个不同的种类，包含[没有关系]类别，表示两个目标过远，由空间关系形成的边是对称的，但是$p_{i,j}$和$p_{j,i}$是不同的</p><h5 id="Semantic-Graph"><a href="#Semantic-Graph" class="headerlink" title="Semantic Graph"></a>Semantic Graph</h5><p>为了构造语义图，需要提取对象之间的语义关系，这可以通过在一个可视的关系数据集上训练一个语义关系分类器来表示为一个分类任务，给定两个对象区域$i$和$j$，目标是确定哪个谓词$p$来表示这两个区域之间的语义关系，语义关系的边是不对称的，比如$<man-holding-bat>$没有对应的反向边</p><p>分类模型的输入包含三个部分，主语区域$v_i$，宾语区域$v_j$和区域级特征向量$v_{i,j}$同时包含$i$和$j$，这三种特征都是从预训练的目标检测模型中得到的，然后通过嵌入层进行变换，将特征嵌入拼接并馈入分类层产生14个类的$softmax$分数，然后用训练好的分类器来预测给定图像中任意一对目标区域之间的关系</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-3.png"></p><h3 id="Relation-Encoder"><a href="#Relation-Encoder" class="headerlink" title="Relation Encoder"></a>Relation Encoder</h3><h4 id="Question-adaptive-Graph-Attention"><a href="#Question-adaptive-Graph-Attention" class="headerlink" title="Question-adaptive Graph Attention"></a>Question-adaptive Graph Attention</h4><p>关系编码器用于动态编码目标之间的关系，在VQA任务中不同类型的问题可能会对应不同的关系，因此，在设计关系编码器时，作者使用问题自适应注意机制，从将问题中的语义信息注入到关系图中，动态地赋予与每个问题最相关的关系较高的权值</p><p>首先将问题特征和视觉嵌入连接</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-4.png"></p><p>然后在顶点上做自注意，生成隐式关系特征，采用的注意力机制如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-5.png"></p><p>对于不同类型的关系图，注意力系数$a_{ij}$，投影矩阵$W$以及邻域$N_i$的定义各不相同，$\sigma(\cdot)$是一个非线性函数</p><p>为了稳定自注意的过程，作者扩展了图注意力机制，采用了多头注意力(multi-head attention)，执行了M个独立的注意力机制，并将输出的特征连接</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-6.png"></p><h4 id="Implicit-Relation"><a href="#Implicit-Relation" class="headerlink" title="Implicit Relation"></a>Implicit Relation</h4><p>学习隐式关系的图是全连接的，所以$N_i$包含了图中所有的目标，包括$i$自己，在<a href="https://arxiv.org/abs/1711.11575">Relation Networks</a>的启发下，作者设计了一种注意力权重同时考虑了图像区域特征权重$a^v$和bbox的权重$a^b$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-7.png"></p><p>其中，$a^v$代表了图像区域之间的相似性，通过离散点积计算</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-8.png"></p><p>其中$U,V \in R^{d_h \times (d_v+d_q)}$是投影矩阵</p><p>$a^b$则代表了空间位置关系</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-9.png"></p><p>$f_b(\cdot,\cdot)$首先计算了4维的相对空间关系</p><p>$(log(\frac{|x_i-x_j|}{w_i}),log(\frac{|y_i-y_j|}{h_i}),log(\frac{w_j}{w_i}),log(\frac{h_j}{h_i}))$</p><p>然后通过计算不同波长的余弦和正弦函数将其嵌入到$d_h$维度的特征</p><p>$w\in R^{d_h}$将$d_h$维特征转换为标量，在$0$处进行裁剪，隐式关系的限制是通过$w$和0-裁剪操作来学习的</p><h4 id="Explicit-Relation"><a href="#Explicit-Relation" class="headerlink" title="Explicit Relation"></a>Explicit Relation</h4><p>因为语义图中的边包含标签信息并且具有方向性，所以作者设计了一个对方向和标签敏感的注意力机制</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-10.png"></p><p>$W_{(\cdot)}$和$V_{(\cdot)}$是矩阵，$b_{(\cdot)},c_{(\cdot)}$是偏移量，$dir(i,j)$根据边的方向选择对应的矩阵，$lab(i,j)$表示每条边的标签，当对所有区域${v_i’}_{i=1}^k$用图注意力机制编码后，区域级特征${v_i^*}_{i=1}^k$就被赋予了先验语义关系</p><p>与图卷积网络不同，该图注意机制有效地为相同邻域的节点分配不同的重要度，结合问题自适应机制，习得的注意权值可以反映哪些关系与特定问题相关，关系编码器可以以相同的方式在空间图上工作，只需要学习不同的参数集，细节省略不表</p><h3 id="Multimodal-Fusion-and-Answer-Prediction"><a href="#Multimodal-Fusion-and-Answer-Prediction" class="headerlink" title="Multimodal Fusion and Answer Prediction"></a>Multimodal Fusion and Answer Prediction</h3><p>获得关系感知的视觉特征之后，采用多态融合策略将每个视觉特征和问题信息融合，文中提出的关系编码器保持了视觉特征的维数，可以与任何现有的多模态融合方法结合来学习联合表示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-11.png"></p><p>f是多态融合方法，$\theta$是可学习参数</p><p>答案预测器采用了两层的MLP，损失函数为二元交叉熵，在训练阶段，对不同关系的编码器进行独立训练，在推理阶段，将三个图注意网络 (semantic, spatial, implicit) 与预测答案分布的加权和相结合，$\alpha$和$\beta$是均衡超参数 ($0 \le\alpha+\beta\le 1, 0 &lt; \alpha,\beta &lt; 1$)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-12.png"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-13.png"></p><p>在VQA2.0上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-14.png"></p><p>可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-15.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ReGAT-16.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> attention </tag>
            
            <tag> 2019 </tag>
            
            <tag> ICCV </tag>
            
            <tag> Graph Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BAN [双线性注意力机制]</title>
      <link href="2020/08/06/BAN/"/>
      <url>2020/08/06/BAN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1805.07932">Paper Download Address</a></p><p>VQA任务涉及到许多视觉-语言交叉的问题，因此attention在VQA中能够起到比较好的效果，co-attention可以同时推断视觉注意力和语言注意力，但同时忽略了语言和视觉区域之间的交互作用</p><p>作者将co-attention扩展为关注问题和图像的每一对多通道的bilinear attention(双线性注意力)，如果给定的问题涉及到由多个单词表示的多个视觉概念，则使用每个单词的视觉注意力分布进行推理比使用单个压缩的注意力分布进行推理更能挖掘出相关信息</p><p>作者在低秩双线性池化的基础上提出了双线性注意网络，BAN利用了两组输入通道之间的双线性交互，而低秩双线性池提取了每对通道的联合表示，此外作者还提出了一个多模态残差网络MRN来更有效地利用多重双线性注意图</p><p>BAN中用residual summations替代了concatenation，以更高效的参数和性能学习了eight-glimpse BAN，图中展示了一个two-glimpse BAN</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-1.png"></p><p>文章主要贡献如下：</p><ol><li><p>在低秩双线性池化技术的基础上，提出了学习和利用双线性注意分布的双线性注意网络</p></li><li><p>提出了一种多模态残差网络(MRN)的变种，以有效地利用由模型产生的多双线性注意图，并成功地利用了多达8个注意力地图</p></li><li><p>在VQA2.0上实现了SOTA，评估了双线性注意图在Flickr30k Entities上性能，推理速度提高了25.37%</p></li></ol><h2 id="Low-rank-bilinear-pooling"><a href="#Low-rank-bilinear-pooling" class="headerlink" title="Low-rank bilinear pooling"></a>Low-rank bilinear pooling</h2><p>低秩双线性池化算法使用单通道输入(question vector)组合其他多通道输入(image features)作为单通道中间表示(attended feature)</p><h4 id="Low-rank-bilinear-model"><a href="#Low-rank-bilinear-model" class="headerlink" title="Low-rank bilinear model"></a>Low-rank bilinear model</h4><p>先前有研究提出了一个低秩双线性模型来降低双线性权矩阵$W_i$的秩，从而给出正则性，$W_i$被替换为两个更小矩阵的乘法$U_iV_i^T$，这里$U_i \in R^{N \times d}$，$V_i \in R^{M \times d}$, 这种替换使得$W_i$的秩$d \le min(M,N)$，标量输出$f_i$为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-2.png"></p><p>式子中的$1$是一个只包含1的向量，$\circ$ 表示Hadamard积 (element-wise multiplication)</p><h4 id="Low-rank-bilinear-pooling-1"><a href="#Low-rank-bilinear-pooling-1" class="headerlink" title="Low-rank bilinear pooling"></a>Low-rank bilinear pooling</h4><p>对于向量输出f，引入了池化矩阵P</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-3.png"></p><p>$P \in R^{d \times c}$，$U \in R^{N \times d}$，$V \in R^{M \times d}$  </p><p>通过引入$P$作为向量输出$f \in R^c$允许U和V是二维张量，显著减少了参数的数量</p><h4 id="Unitary-attention-networks"><a href="#Unitary-attention-networks" class="headerlink" title="Unitary attention networks"></a>Unitary attention networks</h4><p>注意力机制通过有选择地利用给定的信息来减少输入通道，假设有一个多通道输入Y，包含$|{y_i}|$个行向量，用注意力权重$\alpha$从Y中得到单通道$\hat{y}=\sum_i\alpha_iy_i$，注意力权重$\alpha$通过softmax计算得到</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-4.png"></p><p>$\alpha \in R^{G \times\phi}$，$P \in R^{d\times G}$，$U \in R^{N \times d}$，$x \in R^N$，$1 \in R^{\phi}$，$V \in R^{M \times d}$，$Y \in R^{M \times \phi}$，当$G&gt;1$的时候表示采用了多glimpses(attention heads)，那么就有$\hat{y}=||_{g=1}^G\sum_i\alpha_{g,iYi}$，然后$x$和$\hat{y}$用低秩双线性池化来实现联合表示，最后进行分类</p><h2 id="Bilinear-attention-networks"><a href="#Bilinear-attention-networks" class="headerlink" title="Bilinear attention networks"></a>Bilinear attention networks</h2><p>作者推广了两个多通道输入的双线性模型，$X \in R^{N \times \rho}$以及$Y \in R^{M \times \phi}$，其中$\rho = |{x_i}|$以及$\phi =|{y_j}|$</p><p>为了同时减少两个输入通道，作者引入双线性注意映射</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-5.png"></p><p>其中$U’ \in R^{N \times K}$，$V’ \in R^{M \times K}$，$(X^TU’)_k \in R^{\rho}$，$(Y^TV’)_k \in R^{\phi}$，$f_k’$表示第k个元素的中间表示，矩阵的下标k表示列的索引，$f_k’$也可以写作</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-6.png"></p><p>然后双线性联合表示$f=P^Tf’$，为方便起见，将双线性注意网络定义为由双线性注意映射参数化的两个多通道输入的函数<br>$BAN(X,Y;A)$</p><h4 id="Bilinear-attention-map"><a href="#Bilinear-attention-map" class="headerlink" title="Bilinear attention map"></a>Bilinear attention map</h4><p>前文提到的注意图为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-7.png"></p><p>$softmax$前的每个$A_{ij}$都是通过低秩双线性池化得到的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-8.png"></p><p>多双线性注意图可以扩展为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-9.png"></p><p>其中$U$和$V$的参数是共享的，但$p_g$不共享，其中$g$表示glimpses的索引</p><h4 id="Residual-learning-of-attention"><a href="#Residual-learning-of-attention" class="headerlink" title="Residual learning of attention"></a>Residual learning of attention</h4><p>作者使用MRN的变体从多重双线性注意图中得到联合表示，第i+1次的输出可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-10.png"></p><p>$f_0=X$，$1 \in R^\rho$</p><p>对最后一次输出的通道维度求和，就能得到分类器的输入</p><h4 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h4><p>$BAN$的复杂度等于一个多通道的输入大小$O(KM\phi)$</p><h2 id="Related-works"><a href="#Related-works" class="headerlink" title="Related works"></a>Related works</h2><h3 id="Multimodal-factorized-bilinear-pooling"><a href="#Multimodal-factorized-bilinear-pooling" class="headerlink" title="Multimodal factorized bilinear pooling"></a>Multimodal factorized bilinear pooling</h3><p><a href="https://arxiv.org/abs/1708.03619">Yu et al</a>做低秩双线性池化时移除了投影矩阵$P$，这个操作对$BAN$没有用</p><h3 id="Co-attention-networks"><a href="#Co-attention-networks" class="headerlink" title="Co-attention networks"></a>Co-attention networks</h3><p><a href="https://arxiv.org/abs/1511.05234">Xu and Saenko</a>提出了空间记忆网络模型，计算问题中每个token和每个图像patch之间的相关性，与本文不同的是，它是对相关矩阵的每一个行向量的最大值进行softmax</p><p>现有的co-attention都是对每个模态使用单独的注意分布，忽略了模态之间的相互作用</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>VQA2.0 Validation Score</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-11.png"></p><p>在VQA2.0上使用的参数量</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-12.png"></p><p>调参</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-13.png"></p><p>two-glimpse BAN两次attention map可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-14.png"></p><p>Flickr30k Entities</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-15.png"></p><p>在VQA2.0 Test上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BAN-16.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> NIPS </tag>
            
            <tag> 2018 </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAAA [层叠注意力机制]</title>
      <link href="2020/08/05/SAAA/"/>
      <url>2020/08/05/SAAA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1704.03162.pdf">Paper Download Address</a></p><p>文章提出了一个相对简单的结构，经过精心的训练能达到SOTA，整体结构如图：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-1.png"></p><p>用LSTM对问题进行编码，用ResNet获取图片的特征，然后用soft attention计算multiple glimpses图像特征，最后进行分类</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Image-embedding"><a href="#Image-embedding" class="headerlink" title="Image embedding"></a>Image embedding</h3><p>用预训练的CNN来计算图片表示，作者使用的是ResNet，取最后一个池化层，得到的特征大小是14×14×2048维的，然后再对深度维度进行l2范数约束</p><h3 id="Question-embedding"><a href="#Question-embedding" class="headerlink" title="Question embedding"></a>Question embedding</h3><p>将问题标记并嵌入到长度为p的向量中，然后用LSTM处理</p><h3 id="Stacked-attention"><a href="#Stacked-attention" class="headerlink" title="Stacked attention"></a>Stacked attention</h3><p>和<a href="https://forever97.github.io/2020/08/04/1511-02274/">SAN</a>十分相似，计算图像特征空间维度上的多重注意力分布</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-2.png"></p><p>每个图像特征的glimpse $x_c$是图像特征在所有空间位置的加权平均，注意力权值$a_{c,l}$对每个glimpse分别归一化，F是一个两层的卷积，共享第一层参数，仅依靠不同的初始化来产生不同的注意力分布</p><h3 id="Classifier"><a href="#Classifier" class="headerlink" title="Classifier"></a>Classifier</h3><p>最后将图像注意力和LSTM结果连接，输入到分类器(两层全连接层)，损失函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-3.png"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-4.png"></p><p>VQA1.0上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-5.png"></p><p>VQA2.0上的表现</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-6.png"></p><p>可视化展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAAA-7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> attention </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conditioned Graph Structures [图结构]</title>
      <link href="2020/08/05/graphStructure/"/>
      <url>2020/08/05/graphStructure/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1806.07243">Paper Download Address</a></p><p>文章中主要提出了一个新的，可解释的，基于图形的VQA模型，最近的VQA方法关注于创建新的注意力结构，复杂性不断增加，但未能对场景中物体之间的语义连接建模</p><p>作者将scene structure作为先验知识引入，将bbox对象设为图中的节点，基于问题的图边则通过注意力模块来学习，这不仅确定了图像中与问题相关的最相关的物体，而且还确定了最重要的交互作用(例如相对位置、相似性)，而无需对图形的结构进行任何手工描述</p><p>作者认为，学习一个图结构不仅为VQA任务提供了强大的预测能力，而且通过检查最重要的图节点和边，还可以对模型的行为进行解释</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><h3 id="Graph-Convolutional-Neural-Networks"><a href="#Graph-Convolutional-Neural-Networks" class="headerlink" title="Graph Convolutional Neural Networks"></a>Graph Convolutional Neural Networks</h3><p>Graph CNNs(GCNs)是一个相对较新的概念，用CNN来图结构化数据，GCN分为两类：频率GCN利用图形信号处理的概念，在欧几里得域上定义图形傅里叶变换，允许在频谱域内以乘法的形式进行卷积，频率GCN有所有训练样本的图结构相同的要求；空间GCN更为工程化，需要定义节点排序和patch操作符，文章的目标是学习基于查询上下文的动态图，因此，扩展了edge的概念，使之适应于上下文</p><h3 id="Visual-Question-Answering"><a href="#Visual-Question-Answering" class="headerlink" title="Visual Question Answering"></a>Visual Question Answering</h3><p><a href="https://arxiv.org/abs/1609.05600">Graph-Structured Representations for Visual Question Answering</a>中特别提出了一种基于图的方法，将问题的图表示和抽象图像与图神经网络相结合，并达到了SOTA，这种方法展现了图结构在VQA任务中的潜力，然而，这种方法不容易推广到场景图表示不是先验的自然图像上</p><p><a href="https://forever97.github.io/2020/07/15/1707-07998/">BUTD</a>第一次用object proposals作为图像特征，这是VQA Task中的一个重大改进，这样的图像表征已经被利用来通过隐式和显式图结构对对象之间的交互建模，<a href="https://forever97.github.io/2020/07/28/1802-05766/">Learning to Count</a>提出了一种基于对象相似性的迭代方法来提高模型的计数能力和可解释性，<a href="https://arxiv.org/abs/1802.05766v1">另一篇Count相关的文章</a>通过proposed features和attention的外积来计算图结构，这两篇文章其实都在做消除重复对象的工作</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>整体框架如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-1.png"></p><p>作者提出了一个深度神经网络，它以一种新颖的方式结合了空间、图像和文本特征</p><p>首先用word embeddings和RNN来得到问题特征，目标检测得到bbox和图片特征向量，然后图学习模块会学习一个问题相关的图像目标的邻接矩阵，这使得图卷积不仅能关注到对讲，同时能关注到与问题最相关的对象关系，最后，对图卷积特征进行最大池化，和question embedding做元素级乘法来预测答案</p><h3 id="Computing-model-inputs"><a href="#Computing-model-inputs" class="headerlink" title="Computing model inputs"></a>Computing model inputs</h3><p>模型的第一个阶段是计算问题和图片的embedding，先将图片转化为大小为k的视觉特征集，目标检测在模型中是特别重要的步骤，因为bbox构成了图中的点，每个bbox的embedding为卷积特征图的平均值，对于每个问题，用预训练的词嵌入将问题转化为可变长度的嵌入序列，然后用GRU将嵌入序列转化为q的embedding</p><h3 id="Graph-learner"><a href="#Graph-learner" class="headerlink" title="Graph learner"></a>Graph learner</h3><p>图学习模块基于问题为图像生成一个图结构，图结构通过定义节点邻域来驱动空间图卷积，这种结构可以自然地学习到一元和成对的注意力，因为邻接矩阵包含自我循环</p><p>定义图结构$g={V,\varepsilon,A}$，$\varepsilon$是需要学习的图边，$A \in R^{N \times N}$是邻接矩阵，$v \in V$为每个检测到的图像对象(bbox和特征向量)，模型的目标是学习邻接矩阵$A$，使得每条边都是基于问题的，需要对特征向量之间的相似性以及它们与给定问题的相关性进行建模</p><p>首先将embedding q嵌入到N个视觉特征中，记其为$[v_n][q]$，然后计算他们的联合嵌入</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-2.png"></p><p>$F$是一个非线性函数</p><p>然后将所有的embedding拼接在一起得到矩阵$E$，计算邻接矩阵$A=EE^T$</p><p>这样的定义对图的稀疏性不施加任何约束，因此可以产生一个全连通的邻接矩阵，接下来需要学习一个图像最相关位置的稀疏图结构</p><p>为了学习每个节点的稀疏领域，采取的排序策略为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-3.png"></p><p>topm返回的是输入向量的m个最大值的索引，也就是i节点领域中连接最强的节点</p><h3 id="Spatial-graph-convolutions"><a href="#Spatial-graph-convolutions" class="headerlink" title="Spatial graph convolutions"></a>Spatial graph convolutions</h3><p>现在有了一个基于问题的图结构，然后用图卷积的方式来学习新的对象表示，图结构中的顶点v(bbox+特征)最大的特征是在图像中的位置，所以建模他们之间的关系本质上是空间的，同时，许多VQA问题要求模型能够意识到图像中特征的方向和相对位置，这是之前许多方法忽略的问题</p><p>因此，作者采用了空间图卷积，直接在graph域中操作，高度依赖于空间关系，用伪坐标函数$u(i,j)$定义对于每个顶点$i$，一个以$i$为中心的坐标系，$u(i,j)$为该系统中顶点$j$的坐标，在系统中$u(i,j)$返回一个极坐标向量$(\rho,\theta)$，表示顶点$i$和$j$相关联的边界框的中心的相对空间位置</p><p>作者同时考虑了笛卡尔坐标和极坐标作为高斯核的输入，并观察到极坐标的效果明显更好，作者认为极坐标的不同角度和距离提供了两个解耦的因素来表示空间关系</p><p>GCN的关键步骤是定义一个描述每个相邻节点影响的patch算子，该算子对不规则的邻域结构具有鲁棒性，<a href="https://arxiv.org/abs/1611.08402">Monti et al</a>提出使用一组可学习均值和协方差的K个高斯核来实现，其中均值在伪坐标下可解释为方向和距离，作者得到每个k的核权值$w_k(u)$，节点i在核k处的patch算子被定义为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-4.png"></p><p>$N(i)$表示$i$的邻节点，对于给定的顶点i，patch算子的输出可以看作是相邻特征的加权和，高斯核集描述了每个邻域对卷积运算输出的影响</p><p>作者调整了patch操作符，使其包含一个额外的加权因子，以生成图结构的边</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-5.png"></p><p>其中$\alpha_{ij} = s(a_i)_j$，$s()_j$是第j个缩放函数(这里定义为被选中的矩阵邻接元素的softmax)，这种更一般的形式意味着除了空间方向外，顶点之间传递的消息强度还可以根据信息进行加权，这使得网络可以学会基于问题成对地关注视觉特征</p><p>最后用对应的k个核连接的结果作为每个节点的输出</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-6.png"></p><p>$G_k \in R^{\frac{d_h}{K}\times d_v}$为可学习矩阵，卷积图表示$H \in R^{N\times d_h}$，$d_h$是输出卷积的选择维数</p><h3 id="Prediction-layers"><a href="#Prediction-layers" class="headerlink" title="Prediction layers"></a>Prediction layers</h3><p>模型的卷积图表示H是通过L个空间图的卷积层来计算的，然后通过跨节点维最大池化计算图的全局向量表示$h_{max}$，这么操作是为了得到一个置换不变输出</p><p>这样的图向量表示是一个图的高度非线性压缩，然后用这种优化后的表示来回答问题，作者用元素级点积结合问题embedding和$h_{max}$，最后用两层以ReLU作为激活函数的MLP作为分类器</p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><p>将VQA任务转换为一个多分类问题，其中每个类对应训练集中最常见的答案之一</p><p>如果每个问题与n个提供的有效答案相关，那么计算每个类的软目标得分为$t=\frac{number-of-votes}{n}$</p><p>如果一个答案不在top answers中(即考虑的类)，那么它在目标向量中没有相应的元素，那么计算多标记软损失，即目标向量中每个元素的二元交叉熵损失之和</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-7.png"></p><p>y是二值向量 (也就是模型的输出)</p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>领域点和高斯核数量的影响</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-8.png"></p><p>在VQA2-Test上和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-9.png"></p><p>可视化展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-10.png"></p><p>错误示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/graphStructure-11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> NIPS </tag>
            
            <tag> 2018 </tag>
            
            <tag> Graph Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAN [层叠注意力机制]</title>
      <link href="2020/08/04/SAN/"/>
      <url>2020/08/04/SAN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1511.02274">Paper Download Address</a></p><p>从VQA的数据集中可以看出，VQA回答一个问题通常需要多步推理，比如想要根据下图问答问题”what are sitting in<br>the basket on a bicycle”，那么首先的找到目标basket和bicycle以及问题中的概念sitting in，然后逐渐排除不相关的对象，最后找出最具有代表性的区域来回答问题(dog)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-1.png"></p><p>这篇文章提出了允许VQA进行多步推理的层叠注意力网络(SAN)，SAN的整体架构如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-2.png"></p><p>系统主要包含三个组件，图片特征提取，问题特征提取以及层叠注意力模型，SAN首先利用问题向量对第一层视觉注意层的图像向量进行查询，然后将问题向量与检索到的图像向量组合成一个精细化的查询向量，再对第二层视觉注意层的图像向量进行查询，随着注意力层次的提高，注意力更清晰地集中在跟答案更相关的区域，最后用问题特征和最高层的图像特征来预测答案</p><p>文章的主要贡献有：</p><ol><li>提出了层叠注意力机制(SAN)</li><li>证明了多层SAN在性能上显著优于之前的SOTA方法</li><li>可视化了SAN每一个注意层的输出</li></ol><h2 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h2><h3 id="Image-Model"><a href="#Image-Model" class="headerlink" title="Image Model"></a>Image Model</h3><p>图片模块用CNN来获得图片特征，与之前的研究不同的是，不采用网络最后一个内积层，而是选择了最后一个池化层，这样能保留原始图像的空间特征</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-3.png"></p><p>先将图像resize成$448 \times 448$的，然后通过VGG得到$14 \times 14 \times 512$的特征层，所以特征层的每一个像素，都代表了原图中一个$32 \times 32$的区域，最后用单层感知器将每个特征向量转换为与问题向量维数相同的新向量</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-4.png"></p><h3 id="Question-Model"><a href="#Question-Model" class="headerlink" title="Question Model"></a>Question Model</h3><p>问题模块可以用LSTM或CNN来实现</p><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-5.png"></p><p>LSTM用$c_t$来储存序列的状态，每一步输入$x_t$，更新$c_t$并输出隐藏状态$h_t$，更新过程采用门控机制，$f_t$是遗忘门，控制多少信息从过去的状态$c_{t-1}$保留，输出们$o_t$控制有多少信息的存储器被馈入输出作为隐藏状态</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-6.png"></p><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>CNN提取问题特征的整体过程如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-7.png"></p><p>先对问题做一个嵌入以得到问题的向量表示；然后使用卷积操作，这里的卷积器有三种，分别是unigram，bigram，trigram。第t次的卷积输出和最终得到的feature map则可表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-8.png"></p><p>对feature进行最大池化，并将三种不同尺寸的池化结果相连接</p><p>$h=[\bar{h_1},\bar{h_2},\bar{h_3}]$</p><p>h就是最终的结果</p><h3 id="Stacked-Attention-Networks"><a href="#Stacked-Attention-Networks" class="headerlink" title="Stacked Attention Networks"></a>Stacked Attention Networks</h3><p>使用全局图像特征向量来预测答案可能会由于引入与潜在答案无关的区域的噪声而导致结果不理想。相反，通过多重关注层的逐步推理，SAN能够逐渐过滤掉噪音，并确定与答案高度相关的区域</p><p>首先通过单层神经网络输入图像和问题特征，然后通过softmax函数生成图像各区域的注意力分布</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-9.png"></p><p>其中$v_I \in R^{d \times m}$，d是图像特征的维度，m是图像的区域数，$v_Q \in R^d$是d维的向量，$W_{I,A},W_{Q,A} \in R^{k \times d}$， $W_P \in R^{1 \times k}$，$p_I \in R^m$</p><p>基于注意力分布，计算每个区域的图像向量的加权和，然后将其与问题向量融合</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-10.png"></p><p>和简单地将问题向量和全局图像向量结合在一起的模型相比，注意力模型构建了一个信息量更大的u，因为在与问题更相关的视觉区域拥有更高的权重，但对于复杂问题，单一的关注层不足以定位正确区域进行答案预测，因此需要使用多个注意层对上述查询-注意过程进行迭代，每一层都提取更多的细粒度视觉注意信息用于答案预测</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-11.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-12.png"></p><p>重复k次之后计算最终的答案</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-13.png"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>和SOTA的比较，SAN的数字表示用了几个注意力层</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-14.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-15.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-16.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-17.png"></p><p>双层注意力可视化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-18.png"></p><p>错误示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SAN-19.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> attention </tag>
            
            <tag> 2016 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC-VQA [循环一致性]</title>
      <link href="2020/07/30/CCVQA/"/>
      <url>2020/07/30/CCVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1902.05660v1">Paper Download Address</a></p><p>已有的工作研究了VQA模型对图像中有意义的语义变化的鲁棒性和敏感性，改变答案分布和对图像攻击，但是没有对问题语法变化的研究，问题形式变化对VQA model的能力(VQA系统是否真的理解了问题)以及应用程序(用户会用不同的语言形式来提问)角度来说都是非常重要的，但是目前SOTA模型对问题语言的变化是十分脆弱的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-1.png"></p><p>作者提出了一个循环一致性(cycle consistency)的框架，训练模型在回答问题的基础上还要生成形式不同但是语义相同的问题变体，要求生成的问题预测的答案与原始问题的ground truth答案相匹配</p><p>这个训练框架有两个优点，一是提高了模型在测试集问题形式变化时的泛化的能力，二是模型可学习的bias减少了，因为一个要同时完成问题生成和问题回答任务的模型不太容易利用语言先验以及走捷径</p><p>为了能够定量评估VQA模型在输入问题中的语言变异的鲁棒性和一致性，作者收集了一个大规模数据集VQA-Rephrasings，并在该数据集上测试了SOTA模型，实现表明VQA模型对问题语言表示变化的脆弱性，这说明现有的VQA模型并不能充分理解语言，用CC-VQA方法训练能在这方面有所提升</p><p>文章的贡献如下：</p><ul><li><p>提出基于循环一致性的训练方法，使得VQA模型更加鲁棒</p></li><li><p>提出VQA-Rephrasings数据集</p></li><li><p>用CC-VQA训练方法训练SOTA模型，在VQA-Rephrasings上有所提升</p></li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="Visual-Question-Generation"><a href="#Visual-Question-Generation" class="headerlink" title="(Visual) Question Generation"></a>(Visual) Question Generation</h3><p>基于图像生成问题的方法在<a href="https://imatge.upc.edu/web/sites/default/files/pub/xMora.pdf">Towards automatic generation of question answer pairs from images</a>中被引入，<a href="https://arxiv.org/abs/1603.06059v1">Generating natural questions about an image</a>中提出了一个超大的VQG数据集来评估模型的问题生成能力，<a href="https://arxiv.org/abs/1710.03370">IVQA</a>提出了一种基于变分LSTM的模型，经过强化学习的训练，为图像生成特定答案的问题，<a href="https://arxiv.org/abs/1709.07192v1">Dual Task</a>通过将问题生成和问答问题作为双重任务来生成针对特定问题种类的答案</p><p>文中的方法并不局限于生成特定类型的问题，VQG组件的目标是自动生成问题重表述，从而使VQA模型对语言变化更具鲁棒性</p><h3 id="Cycle-Consistent-Learning"><a href="#Cycle-Consistent-Learning" class="headerlink" title="Cycle-Consistent Learning"></a>Cycle-Consistent Learning</h3><p>用循环一致性的方法规则化模型的训练目标跟踪，机器翻译和文本问答中都有采用，循环一致性在涉及单一模态(纯文本或纯图像)的领域中得到了广泛的应用，但在像VQA这样的多模态任务环境中还没有进行过研究</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>循环一致性方法如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-2.png"></p><p>先用VQA model对(V,Q)产生A’，然后用VQG对(A’,V)产生Q’，生成Q’的过程如图(b)所示，随后再用VQA对(V,Q’)得到A’’</p><p>假设生成的问题是原问题的有效改写，那么一个健壮的VQA模型应该用与原问题相同的答案来回答这个改写问题，具体实现时，有很多问题阻碍了VQA系统中循环一致性的实施，以下会讨论这些问题和处理这些问题的关键组件</p><h3 id="Question-Generation-Module"><a href="#Question-Generation-Module" class="headerlink" title="Question Generation Module"></a>Question Generation Module</h3><p>在处理单模态的循环一致性模型中，需要在具有大致相似信息内容的相同模态的不同domain间学习转换，但是像VQG这样的多模态转换中，学习从低信息模态(如回答)到高信息模态(问题)的转换需要额外的监督，作者以注意力的形式对VQG提供额外的监督，引导VQG的注意力到VQA回答问题的图像区域，这使得模型能够从”Yes”这样的答案中产生与最初的问题更相似的问题</p><p>问题生成模块由两个线性编码器组成，将VQA模型得到的图像特征和答案空间上的分布变换到更低维的特征向量。将这些特征向量与附加的噪声相加，然后通过一个LSTM，该LSTM经过训练来重构原始问题，并通过teacher forcing最小化负对数似然来优化</p><p>文章的做法不传递表示得到的答案的onehot vector，或者将得到的答案嵌入到问题生成中，而是对答案的分布进行预测，这使得问题生成模块能够学习将模型的置信度映射到生成的问题答案上</p><p>Q-consistency指通过VQG产生的问题Q’和原始VQA问题的Q的一致性损失$L_G(Q,Q’)$，A-consistency指生成问题产生的答案A’’和GT答案A的一致性损失$L_{cycle}(A,A’’)$</p><p>总的Loss可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-3.png"></p><p>$L_F(A,A’)$和$L_{cycle}(A,A’’)$是交叉熵损失，$L_G(Q,Q’)$是sequence generation loss，两个$\lambda$是可调的超参数</p><h3 id="Gating-Mechanism"><a href="#Gating-Mechanism" class="headerlink" title="Gating Mechanism"></a>Gating Mechanism</h3><p>作者提出的循环一致训练方案的一个假设是，所生成的问题在语义和句法上总是正确的，然而实际上这不会总是对的，不加过滤地用答案生成的问题会导致失败，和VQA模块一样，VQG模块也不完善，因此，问题生成器生成的问题并不是都与图像、答案和原问题相一致</p><p>为了克服这个问题，作者提出了一个门控机制，它在将VQG模型生成的不合适的问题传递给VQA模型之前自动过滤这些问题，以达到A-consistency，只保留那些VQA模型F能够正确回答的问题，或者与原始问题编码的余弦相似度大于临界值的问题</p><h3 id="Late-Activation"><a href="#Late-Activation" class="headerlink" title="Late Activation"></a>Late Activation</h3><p>设计循环一致模型的一个关键部分是防止模式崩溃，在像VQA这样复杂的环境中，学习循环一致的模型需要一个精心选择的训练方案，由于循环一致的模型有几个相互连接的学习不同转换的子网络，因此确保每个子网络协调工作非常重要，如果VQA模型F和VQG模型G是联合训练的，并且在训练的早期阶段执行一致性，那么这两个模型都可能通过产生不希望的输出来”欺骗”</p><p>作者通过在训练的后期激活循环一致性来克服这个问题，以确保VQA和VQG模型都得到了足够的培训，以产生合理的输出，具体地说，在一定的迭代次数之后才使循环一致性相关的loss有效</p><p>问题生成模块、门控机制和延迟激活的设计选择对于有效训练模型至关重要，为了增强VQA模型对所有生成的变化的鲁棒性，所以回答原始问题的VQA模型与生成的重新表述之间的权重是共享的，VQA中循环一致性的公式也可以被认为是一种在线数据扩充技术，其中模型是针对同一个问题的几个生成的表述进行训练的，因此在推理过程中对这些变化更加稳健，这种稳健性也赋予了VQA模型更好地预测自身失败的能力</p><h2 id="VQA-Rephrasings-Dataset"><a href="#VQA-Rephrasings-Dataset" class="headerlink" title="VQA-Rephrasings Dataset"></a>VQA-Rephrasings Dataset</h2><p>VQA-Rephrasings是能够评估VQA系统对于问题语法变化的鲁棒性的数据集，采用VQA2.0的一个split作为基础，作者采用人工标注的方式对每个问题收集了三个rephrasings</p><p>人工标注分为两个阶段：</p><p>在第一阶段，研究人员将原始问题和相应的真实答案灌输给人们，并要求他们对问题进行rephrasing，保证新问题的回答与原始答案保持一致。为了确保第一阶段的rephrasings在语法上正确并在语义上与原始问题一致，需要在下一阶段过滤收集到的响应</p><p>第二个阶段给定标注人员原始问题和rephrasing，要求对rephrasing标注无效mask当其：(a)和原始问题的答案不一样；(b)出现语法错误</p><p>对于一个VQA模型来说，要在同一问题的不同表述之间保持一致，所有表述的答案应该是相同的，作者用共识分数$CS(k)$来衡量这一点。首先对大小为k的子集进行抽样，共识分数$CS(k)$定义为所有答案都正确的子集数与大小为k的子集总数的比值</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-4.png"></p><p>而问题的答案是否正确通过S(Q)来衡量，<a href="https://arxiv.org/abs/1606.07356">相关文献</a></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-5.png"></p><p>$^nC_k$是大小为$k$的抽样子集的数量，要使一组问题$Q$在$k$处达到非零的共识分，模型必须在一组问题$Q$中至少正确回答k个问题，当$k=|Q|$，模型需要回答对所有形式的问题，显然k越大，模型对问题的语言变化更稳健</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>SOTA模型加上CC模块在VQA-Rephrasings上的测试</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-6.png"></p><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-7.png"></p><p>可视化对比：</p><p>第一行：Pythia</p><p>第二行：Pythia + CC</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CCVQA-8.png"></p><p>VQA-Rephrasings的数据example，更多baseline+cc的可视化比较，VQG module生成的问题example可查阅paper附录</p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFAF [动态模内模间注意流]</title>
      <link href="2020/07/29/DFAF/"/>
      <url>2020/07/29/DFAF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1812.05252">Paper Download Address</a></p><p>VQA模型性能的提升得益于三个方面，一是更好的视觉和语言特征表示，二是注意力机制，三是更好的多模态融合方法</p><p>目前的VQA模型大多在学习视觉和语言特征之间的跨模态关系(inter-modality relations)，<a href="https://arxiv.org/abs/1511.06062">Bilinear feature fusion</a>主要通过特征的外积来获取语言和视觉模式之间的高阶关系，Co-attention和bilinear attentionbased<br>approaches通过学习词区域对(word-region pairs)之间的跨模态关系来完成VQA任务</p><p>此外也有学习模态内部关系(intra-modality relations)的方法，<a href="https://arxiv.org/abs/1711.11575">Hu et al</a>提出探索模内对象-对象关系，以提高目标检测精度，<a href="https://arxiv.org/abs/1809.07041">Yao et al</a>学习模内对象-对象关系，以提高图像字幕性能，<a href="https://arxiv.org/abs/1810.04805">BERT</a>采用自注意机制对模内词关系进行建模，得到了SOTA的word embedding，</p><p>在解决VQA问题的框架中从未同时研究过模内关系和跨模关系，作者认为被大多数VQA系统忽略的模内关系是跨模关系的补充，每个图像区域不仅要从问题中的关联词/短语中获取信息，还要从相关图像区域中获取信息来推断问题的答案，这种情况要求一个统一的框架来为模间和模内信息流建模</p><p>作者提出了一个新的框架Dynamic Fusion with Intra- and Inter-modality Attention Flow(DFAF)，目的是高效完成多模态特征融合，准确回答视觉问题，DFAF集成了跨模态的self-attention和co-attention在图像和语言之间实现信息的有效流动</p><p>DFAF框架首先生成中间注意流(intermodality attention flow, InterMAF)，在图像和语言之间传递信息，InterMAF会生成视觉和语言的co-attention矩阵，每个视觉区域会根据该矩阵选择问题特征，反之亦然(vice versa)，InterMAF根据来自另一模态的注意力加权信息流，融合和更新每个图像区域和每个单词的特征</p><p>然后是动态模内注意流(dynamic intra-modality attention flow，DyIntraMAF)，用于在每个模态内传递信息流，以提取复杂的模态内关系，视觉区域和语言在同一模态下生成self-attention，并从其它实例聚合注意力权重，虽然信息仅在相同的模态中传播，但使用了其他模态的信息来调节模态内的注意权重和流量，通过这种操作模态内的注意力动态依赖于其它模态。实验证明，DyIntraMAF比仅使用内部信息来实现内部模态信息流要好，该操作是框架的核心</p><p>文章的贡献主要包含以下三点：</p><ol><li><p>提出DFAF框架，首次将模间和动态模内信息流集成到一个统一的框架中，以解决VQA任务</p></li><li><p>框架的核心模块：DyIntraMAF，动态生成各模内的有效注意流，并动态地依赖于其他模内的信息</p></li><li><p>进行大量的实验和消融实验来检验DFAF框架的有效性，并用框架实现了一个SOTA的VQA模型</p></li></ol><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>特征提取</p><ul><li><p>ResNet逐渐取代VGG作为图像特征提取工具</p></li><li><p>从Faster R-CNN衍生的BUTD model取得了很好的效果</p></li></ul><p>双线性融合</p><ul><li><p>早期跨模态融合采用简单的矩阵连接和矩阵元素相乘</p></li><li><p>双线性融合可以捕获两种模式之间的高层交互</p></li><li><p><a href="https://arxiv.org/abs/1606.01847v3">MCB</a>、<a href="https://arxiv.org/abs/1610.04325">MLB</a>和<a href="https://arxiv.org/abs/1705.06676">MUTAN</a>等近似融合方法突破了双线性池计算量大的局限性，参数更少，效果更好</p></li></ul><p>Self-attention</p><p>将特征转换为查询特征、关键特征和价值特征，通过查询和关键特征的内积计算不同特征之间的注意矩阵，然后计算原始特征的注意加权和</p><p>Co-attention</p><p>对于每个单词，可以根据co-attention将图像区域特征聚合到单词，<a href="https://arxiv.org/abs/1804.00775">DCN</a>得益于co-attention，在不使用BUTD特征的情况下达到SOTA</p><p>其它VQA工作</p><ul><li><p><a href="https://arxiv.org/abs/1511.05756">Dynamic Parameter Prediction</a>和<a href="https://arxiv.org/abs/1808.02632">Question-guided Hybrid Convolution</a>用动态预测的参数进行特征融合</p></li><li><p><a href="https://arxiv.org/abs/1612.01887">Adaptive attention</a>在图像提取时可以跳过注意力(skip attention)</p></li><li><p><a href="https://arxiv.org/abs/1702.00887">Structured attention</a>采用了注意力图上的MRF模型来更好地模拟注意力的空间分布</p></li><li><p><a href="https://aaai.org/ojs/index.php/AAAI/article/view/4871">Locally weighted deformable neighbours</a>预测偏移量和模型权重</p></li></ul><h2 id="DFAF框架"><a href="#DFAF框架" class="headerlink" title="DFAF框架"></a>DFAF框架</h2><p>整体框架如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-1.png"></p><p>首先利用co-attention对两种模态之间的视觉和语言特征进行加权，然后InterMAF模块对图像区域和单词的模态之间的特征进行聚合，学习图像区域和问题之间的交互，然后用DyIntraMAF学习word-to-word和region-to-region的关系，InterMAF和DyIntraMAF模块交替重叠，迭代地传递信息流，最后用一个简单的分类器得到答案</p><p>基本的视觉和语言特征提取采用RCNN和GRU</p><h3 id="Intermodality-Attention-Flow"><a href="#Intermodality-Attention-Flow" class="headerlink" title="Intermodality Attention Flow"></a>Intermodality Attention Flow</h3><p>InterMAF首先学习捕捉每一对图像区域和语言特征之间的重要性，然后根据学习到的重要度权值和聚集特征在两种模式之间传递信息流，更新每个单词特征和图像区域特征，这样的信息流过程能够识别视觉区域和单词之间的跨模态关系</p><p>首先将每个视觉区域和单词特征转化为查询特征、关键特征和值特征，分别记为代表视觉区域的$R_K$,$R_Q$和$R_V$ $\in R^{\mu \times dim}$，以及代表单词特征的$E_K$,$E_Q$和$E_V$ $\in R^{14 \times dim}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-2.png"></p><p>$Linear$是全连接层，$dim$是两种模态转化后特征的共同维度</p><p>通过计算每对视觉区域特征与关键词特征之间的内积$R_QE^T_K$获得原始的注意力权重，用于将信息从单词特征聚合到每个视觉特征，反之亦然</p><p>用维数的平方根和softmax对原始权重进行归一化得到两组权重$InterMAF_{R \leftarrow E}$和$InterMAF_{R \to E}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-3.png"></p><p>内积的值与隐藏特征空间的维数成正比，因此需要用隐藏维数的平方根进行归一化</p><p>两个InterMAF矩阵捕获了每个图像区域和词对之间的重要性，以$InterMAF_{R \leftarrow E}$为例，每一行代表一个视觉区域和所有词嵌入之间的注意力权重，所有词嵌入到该图像区域特征的信息可以聚合为词值特征$E_V$的加权总和</p><p>用于更新视觉区域特征和单词特征的信息流表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-4.png"></p><p>InterMAF矩阵用于确定信息流的权重</p><p>将更新后的特征和原始的特征连接在一起，通过一个全连接层转化为输出特征</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-5.png"></p><p>InterMAF模块的输出特性将被输入DyIntraMAF模块用于学习模内信息流，进一步更新视觉区域和单词特征，捕获区域-区域和单词-单词关系</p><h3 id="Dynamic-Intramodality-Attention-Flow"><a href="#Dynamic-Intramodality-Attention-Flow" class="headerlink" title="Dynamic Intramodality Attention Flow"></a>Dynamic Intramodality Attention Flow</h3><p>作者认为模态内关系是跨模关系的补充，比如问题”谁在滑板上”，需要将滑板上方区域与滑板区域联系起来</p><p>因此作者用动态注意机制建模这种模内关系</p><p>DyIntraMAF模块框架如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-6.png"></p><p>用于捕获区域之间和单词之间重要性的朴素IntraMAF矩阵和InterMAF矩阵十分相似</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-7.png"></p><p>朴素的IntraMAF只使用模内信息来估计区域和区域之间以及文字和文字之间的重要性，但是有些关键关系只能通过另一个模态的信息来确定，就比如说，即使对于相同的输入图像，不同的视觉区域对之间的关系也应该根据不同的问题进行不同的加权，因此作者提出了DyIntraMAF，用来自其他模态的信息来评估重要度</p><p>为了从其它模态中总结条件信息，将视觉区域特征沿着对象索引维度，单词特征沿着单词索引维度做平均池化，然后将两个模态平均池化后的特征转化为维度特征向量来匹配问题的关键特征$R_Q$,$R_K$,$E_Q$,$E_K$，然后通过sigmoid函数之后生成其它模态的通道门控(channel-wise conditioning gates)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-8.png"></p><p>两种模态的查询和关键特征由另一种模态的条件门控制</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-9.png"></p><p>$\odot$是矩阵元素乘，问题和关键特征的通道将会根据其它模态的门控决定被激活或停用，通道选通向量是基于跨模态信息创建的</p><p>这个动态的DyIntraMAF矩阵就跟朴素的IntranetMAF矩阵算法一样，只是经过了门控</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-10.png"></p><p>最后用DyIntraMAF矩阵处理后输出结果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-11.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-12.png"></p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在DAFA框架上做的消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-13.png"></p><p>和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-14.png"></p><p>DyIntraMAF权重矩阵的可视化，针对问题的不同可以得到不同的注意权重，而IntraMAF是恒定不变的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DFAF-15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> attention </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Count模块源码解读</title>
      <link href="2020/07/29/count/"/>
      <url>2020/07/29/count/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Cyanogenoid/vqa-counting/blob/master/vqa-v2/counting.py">Code Download Address</a></p><p><a href="https://forever97.github.io/2020/07/28/1802-05766/">Paper Record</a></p><p>计数的基本方法是确定边的数量，通过子图完全图边和点的关系来计算点数，最后得到答案</p><h2 id="top-n-bounding-box"><a href="#top-n-bounding-box" class="headerlink" title="top n bounding box"></a>top n bounding box</h2><p>首先处理出处理出top n的注意力权重和对应的bounding box</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_most_important</span>(<span class="params">self, n, boxes, attention</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Only keep top-n object proposals, scored by attention weight &quot;&quot;&quot;</span></span><br><span class="line">    attention, idx = attention.topk(n, dim=<span class="number">1</span>, <span class="built_in">sorted</span>=<span class="literal">False</span>)</span><br><span class="line">    idx = idx.unsqueeze(dim=<span class="number">1</span>).expand(boxes.size(<span class="number">0</span>), boxes.size(<span class="number">1</span>), idx.size(<span class="number">1</span>))</span><br><span class="line">    boxes = boxes.gather(<span class="number">2</span>, idx)</span><br><span class="line">    <span class="keyword">return</span> boxes, attention</span><br></pre></td></tr></table></figure><p>boxes的shape为(n, 4, m)，attention的shape为(n, m)，其中n为batch size，m为一张图中bbox的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.topk(<span class="built_in">input</span>, k, dim=<span class="literal">None</span>, largest=<span class="literal">True</span>, <span class="built_in">sorted</span>=<span class="literal">True</span>, out=<span class="literal">None</span>) → (Tensor, LongTensor)</span><br></pre></td></tr></table></figure><p>k表示top k，dim为指定维度，如果未指定则默认最后一维，largest表示返回最大还是最小(True/False)，sorted表示返回的top k是否需要排序，out可选输出张量(Tensor, LongTensor)</p><p>返回值是一个元组(values,indices)</p><p>源码中指定的dim=1是bbox维度，即选取attention权值最大的k个bbox</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.unsqueeze(<span class="built_in">input</span>, dim) → Tensor</span><br></pre></td></tr></table></figure><p>unsqueeze用于维度扩充，dim为插入的维度下标</p><p>expand是将torch的各个维度扩展到更大的尺寸，在unsqueeze之后，idx变为(n,1,m)，然后扩展为(n,4,m)，和bbox的tensor尺寸相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.gather(<span class="built_in">input</span>, dim, index, out=<span class="literal">None</span>, sparse_grad=<span class="literal">False</span>) → Tensor</span><br></pre></td></tr></table></figure><p>gather函数在dim维度按照index对input进行索引把对应的数据提取出来的，这里是提取出top k的attention权值对应的bbox</p><h2 id="Calculate-A-amp-amp-D"><a href="#Calculate-A-amp-amp-D" class="headerlink" title="Calculate A &amp;&amp; D"></a>Calculate A &amp;&amp; D</h2><p>然后计算注意矩阵和距离矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relevancy = self.outer_product(attention)</span><br><span class="line">distance = <span class="number">1</span> - self.iou(boxes, boxes)</span><br></pre></td></tr></table></figure><p>看下矩阵外积(outer_produce)的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    size = <span class="built_in">tuple</span>(x.size()) + (x.size()[-<span class="number">1</span>],)</span><br><span class="line">    a = x.unsqueeze(dim=-<span class="number">1</span>).expand(*size)</span><br><span class="line">    b = x.unsqueeze(dim=-<span class="number">2</span>).expand(*size)</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_product</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="comment"># Y_ij = x_i * x_j</span></span><br><span class="line">    a, b = self.outer(x)</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br></pre></td></tr></table></figure><p>(x.size()[-1],)表示将x.size()的最后一维取出并将其表示为元组，元组相加是拼接而非按位相加，得到size为(n,m,m)，所以outer的作用就是将x变成两个(n,m,m)的tensor，将权值放在对应的倒数第一维和倒数第二维，outer_product将x转化后得到的a和b相乘得到外积</p><p>看一下Intersection over Union(IoU)的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">    <span class="comment"># this is just the usual way to IoU from bounding boxes</span></span><br><span class="line">    inter = self.intersection(a, b)</span><br><span class="line">    area_a = self.area(a).unsqueeze(<span class="number">2</span>).expand_as(inter)</span><br><span class="line">    area_b = self.area(b).unsqueeze(<span class="number">1</span>).expand_as(inter)</span><br><span class="line">    <span class="keyword">return</span> inter / (area_a + area_b - inter + <span class="number">1e-12</span>)</span><br></pre></td></tr></table></figure><p>先看一下 intersection</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">    size = (a.size(<span class="number">0</span>), <span class="number">2</span>, a.size(<span class="number">2</span>), b.size(<span class="number">2</span>))</span><br><span class="line">    min_point = torch.<span class="built_in">max</span>(</span><br><span class="line">        a[:, :<span class="number">2</span>, :].unsqueeze(dim=<span class="number">3</span>).expand(*size),</span><br><span class="line">        b[:, :<span class="number">2</span>, :].unsqueeze(dim=<span class="number">2</span>).expand(*size),</span><br><span class="line">    )</span><br><span class="line">    max_point = torch.<span class="built_in">min</span>(</span><br><span class="line">        a[:, <span class="number">2</span>:, :].unsqueeze(dim=<span class="number">3</span>).expand(*size),</span><br><span class="line">        b[:, <span class="number">2</span>:, :].unsqueeze(dim=<span class="number">2</span>).expand(*size),</span><br><span class="line">    )</span><br><span class="line">    inter = (max_point - min_point).clamp(<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">    area = inter[:, <span class="number">0</span>, :, :] * inter[:, <span class="number">1</span>, :, :]</span><br><span class="line">    <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure><p>a[:, :2, :]表示将dim=1的前两个切片(左上角坐标)取出，对应的a[:, 2:, :]则为右下角坐标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">max</span>(<span class="built_in">input</span>, other, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>torch.max可以将取两个tensor对应位置的最大值，返回是一个tensor，两个tensor不一样大时可以广播计算，不过这里源码直接将其拉伸成一样大的了</p><p>将左上角取最大值就得到了相交区域的上界，同理，右下角取最小值得到了相交区域的下界</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.clamp(<span class="built_in">input</span>, <span class="built_in">min</span>, <span class="built_in">max</span>, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>clamp给tensor的元素限定上下界(min,max)，如果两个bbox没有交集，则可能计算出来的是负数，所以需要设定下界0，将两个inter对应的长宽相乘得到每两个bbox的相交面积area，得到面积交矩阵</p><p>然后看一下area</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self, box</span>):</span></span><br><span class="line">    x = (box[:, <span class="number">2</span>, :] - box[:, <span class="number">0</span>, :]).clamp(<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">    y = (box[:, <span class="number">3</span>, :] - box[:, <span class="number">1</span>, :]).clamp(<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure><p>显然计算的是bbox的面积，同时用了clamp做了极小限制防止出现负数</p><p>在iou中将得到的area通过unsqueeze在矩阵上横向扩展和纵向扩展，相加再减去面积交矩阵即可得到面积并矩阵，IoU = 面积交/面积并，计算即可</p><p>然后用得到的注意力矩阵A和距离矩阵D去计算$\bar{A}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/count-1.png"></p><h2 id="intra-object-dedup"><a href="#intra-object-dedup" class="headerlink" title="intra-object dedup"></a>intra-object dedup</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score = self.f[<span class="number">0</span>](relevancy) * self.f[<span class="number">1</span>](distance)</span><br></pre></td></tr></table></figure><p>将A和D通过两个不同的激活函数，然后点乘来消除intra-object</p><p>来看一下激活函数的实现</p><p>在__init__里有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.f = nn.ModuleList([PiecewiseLin(<span class="number">16</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)])</span><br></pre></td></tr></table></figure><p>查看作者写的分段线性函数PiecewiseLin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PiecewiseLin</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line">        self.weight = nn.Parameter(torch.ones(n + <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># the first weight here is always 0 with a 0 gradient</span></span><br><span class="line">        self.weight.data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># all weights are positive -&gt; function is monotonically increasing</span></span><br><span class="line">        w = self.weight.<span class="built_in">abs</span>()</span><br><span class="line">        <span class="comment"># make weights sum to one -&gt; f(1) = 1</span></span><br><span class="line">        w = w / w.<span class="built_in">sum</span>()</span><br><span class="line">        w = w.view([self.n + <span class="number">1</span>] + [<span class="number">1</span>] * x.dim())</span><br><span class="line">        <span class="comment"># keep cumulative sum for O(1) time complexity</span></span><br><span class="line">        csum = w.cumsum(dim=<span class="number">0</span>)</span><br><span class="line">        csum = csum.expand((self.n + <span class="number">1</span>,) + <span class="built_in">tuple</span>(x.size()))</span><br><span class="line">        w = w.expand_as(csum)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># figure out which part of the function the input lies on</span></span><br><span class="line">        y = self.n * x.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        idx = Variable(y.long().data)</span><br><span class="line">        f = y.frac()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># contribution of the linear parts left of the input</span></span><br><span class="line">        x = csum.gather(<span class="number">0</span>, idx.clamp(<span class="built_in">max</span>=self.n))</span><br><span class="line">        <span class="comment"># contribution within the linear segment the input falls into</span></span><br><span class="line">        x = x + f * w.gather(<span class="number">0</span>, (idx + <span class="number">1</span>).clamp(<span class="built_in">max</span>=self.n))</span><br><span class="line">        <span class="keyword">return</span> x.squeeze(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>cumsum是累加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.cumsum(<span class="built_in">input</span>, dim, out=<span class="literal">None</span>, dtype=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回的tensor y满足$y_i=x_1+x_2+\dots+x_i$</p><p>通过w=w/w.sum()和self.weight.data[0] = 0保证$f_k(0)=0，f_k(1)=1$</p><h2 id="inter-object-dedup"><a href="#inter-object-dedup" class="headerlink" title="inter-object dedup"></a>inter-object dedup</h2><p>然后消除inter-object，方法是等比例缩小边的权重</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/count-2.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dedup_score = self.f[<span class="number">3</span>](relevancy) * self.f[<span class="number">4</span>](distance)</span><br><span class="line">dedup_per_entry, dedup_per_row = self.deduplicate(dedup_score, attention)</span><br><span class="line">score = score / dedup_per_entry</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/count-3.png"></p><p>dedup_score就是计算了式中的X，$X = f_4(A)\odot f_5(D)$</p><p>看一下deduplicate函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deduplicate</span>(<span class="params">self, dedup_score, att</span>):</span></span><br><span class="line">    <span class="comment"># using outer-diffs</span></span><br><span class="line">    att_diff = self.outer_diff(att)</span><br><span class="line">    score_diff = self.outer_diff(dedup_score)</span><br><span class="line">    sim = self.f[<span class="number">2</span>](<span class="number">1</span> - score_diff).prod(dim=<span class="number">1</span>) * self.f[<span class="number">2</span>](<span class="number">1</span> - att_diff)</span><br><span class="line">    <span class="comment"># similarity for each row</span></span><br><span class="line">    row_sims = sim.<span class="built_in">sum</span>(dim=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># similarity for each entry</span></span><br><span class="line">    all_sims = self.outer_product(row_sims)</span><br><span class="line">    <span class="keyword">return</span> all_sims, row_sims</span><br></pre></td></tr></table></figure><p>其中用了一个outer_diff函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_diff</span>(<span class="params">self, x</span>):</span></span><br><span class="line">    <span class="comment"># like outer products, except taking the absolute difference instead</span></span><br><span class="line">    <span class="comment"># Y_ij = | x_i - x_j |</span></span><br><span class="line">    a, b = self.outer(x)</span><br><span class="line">    <span class="keyword">return</span> (a - b).<span class="built_in">abs</span>()</span><br></pre></td></tr></table></figure><p>和outer_product的功能类似，用这个函数求了attention的两两权重差和dedup_score的两两差，按照式子计算了proposal两两之间的相似度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.prod(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>, dtype=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>prod是对指定维度dim求元素积，对应公式中的$\prod$</p><p>$row_sims$计算了proposal i和其它proposal相似的次数</p><p>对于$edge_{ij}$来说值需要除以${row_sims}_i$和${row_sims}_j$，所以这里处理了$row_sims$的$outer_product$，即$all_sims$</p><p>然后对score进行了缩放，即得到了$\bar{A}\odot ss^T$</p><h2 id="aggregate-the-score"><a href="#aggregate-the-score" class="headerlink" title="aggregate the score"></a>aggregate the score</h2><p>答案统计用的是$|V|=\sqrt{|E|}$，因此还需要将在intra-object dedup中消去的自环加回来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">correction = self.f[<span class="number">0</span>](attention * attention) / dedup_per_row</span><br><span class="line">score = score.<span class="built_in">sum</span>(dim=<span class="number">2</span>).<span class="built_in">sum</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) + correction.<span class="built_in">sum</span>(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">score = (score + <span class="number">1e-20</span>).sqrt()</span><br><span class="line">one_hot = self.to_one_hot(score)</span><br></pre></td></tr></table></figure><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/count-4.png"></p><p>算自环直接attention点积然后除倍率，矩阵点积对于边权值是线性变化，所以乘s而不是乘$s\odot s$，原式中diag是将数值填入对角矩阵的对角线，因为代码中是直接计数所以不需要这步操作</p><p>直接求和得到了|E|，开方即可得到|V|，也就是正确的计数</p><p>并将答案转化为特殊的one-hot编码$o=[o_0,o_1,\dots,o_n]^T$</p><p>$o_i=max(0,1-|c-i|)$</p><p>若答案为整数，则one-hot编码结果为对应答案位置为1，其余位置为0，否则o对应两个one-hot编码的线性插值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_one_hot</span>(<span class="params">self, scores</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Turn a bunch of non-negative scalar values into a one-hot encoding.</span></span><br><span class="line"><span class="string">    E.g. with self.objects = 3, 0 -&gt; [1 0 0 0], 2.75 -&gt; [0 0 0.25 0.75].</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># sanity check, I don&#x27;t think this ever does anything (it certainly shouldn&#x27;t)</span></span><br><span class="line">    scores = scores.clamp(<span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=self.objects)</span><br><span class="line">    <span class="comment"># compute only on the support</span></span><br><span class="line">    i = scores.long().data</span><br><span class="line">    f = scores.frac()</span><br><span class="line">    <span class="comment"># target_l is the one-hot if the score is rounded down</span></span><br><span class="line">    <span class="comment"># target_r is the one-hot if the score is rounded up</span></span><br><span class="line">    target_l = scores.data.new(i.size(<span class="number">0</span>), self.objects + <span class="number">1</span>).fill_(<span class="number">0</span>)</span><br><span class="line">    target_r = scores.data.new(i.size(<span class="number">0</span>), self.objects + <span class="number">1</span>).fill_(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    target_l.scatter_(dim=<span class="number">1</span>, index=i.clamp(<span class="built_in">max</span>=self.objects), value=<span class="number">1</span>)</span><br><span class="line">    target_r.scatter_(dim=<span class="number">1</span>, index=(i + <span class="number">1</span>).clamp(<span class="built_in">max</span>=self.objects), value=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># interpolate between these with the fractional part of the score</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - f) * Variable(target_l) + f * Variable(target_r)</span><br></pre></td></tr></table></figure><p>最后考虑尽可能用A和D矩阵中为1和0的数字来计算答案，计算两个置信系数，然后返回最终的计数特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one_hot = self.to_one_hot(score)</span><br><span class="line">att_conf = (self.f[<span class="number">5</span>](attention) - <span class="number">0.5</span>).<span class="built_in">abs</span>()</span><br><span class="line">dist_conf = (self.f[<span class="number">6</span>](distance) - <span class="number">0.5</span>).<span class="built_in">abs</span>()</span><br><span class="line">conf = self.f[<span class="number">7</span>](att_conf.mean(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) + dist_conf.mean(dim=<span class="number">2</span>).mean(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>))</span><br><span class="line"><span class="keyword">return</span> one_hot * conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> count </tag>
            
            <tag> code </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning To Count [VQA计数]</title>
      <link href="2020/07/28/learningToCount/"/>
      <url>2020/07/28/learningToCount/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1802.05766">Paper Download Address</a></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-0.png"></p><p>想要统计图中有几只猫通常需要这样几个步骤：理解实例的视觉表现，在图中找到实例以及计数</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-1.png"></p><p>这在VQA中是一个常见的Task，然而目前的VQA系统在数据集bias之外的情况很难回答计数问题，主要原因是广泛使用的软注意力机制以及VQA中的计数并不像标准计数对计数目标有GT标定</p><p>模型需要能够对大量对象进行计数，并且在理想情况下，在非计数问题上的性能不受到损害，因此非常具有挑战性</p><p>为了简化这个task，作者采用object proposals，即将目标检测得到的bounding box和对应的对象特征作为输入而非从pixel层面学习。在复杂的场景中，通常会遇到重复计算重叠对象的问题，这是一个存在于许多自然图像中的问题，它会导致在真实场景中不准确的计数</p><p>文章的主要贡献是提出了一个可微的神经网络组件来完成计数，该组件与注意机制一起使用，避免了软注意的基本限制，同时产生强大的计数功能，实验表明，使用计数组件的相对简单的基线模型优于所有以前的模型，而不会降低其他类别的性能</p><h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><p>greedy non-maximum suppression(NMS)通常用于消除重复的bounding box，使用它作为模型的一部分会出现的主要问题是它的梯度是分段常数，作者提出的模型不需要对保留哪些边框做出离散的决定，它输出计数特性，而不是更小的边框集，该组件可以很容易地集成到标准的VQA模型中去</p><p>对于VQA v2数据集，只有少数工作在计数问题上取得进展，<a href="https://arxiv.org/abs/1707.07998">Anderson et al.</a>主要通过在视觉处理管道中使用了对象建议(object proposals)提高了精度，他们的对象建议网络是用单数和复数形式的类进行训练的，比如tree和trees不同，它只允许原始计数信息出现在ROI池化之后的对象特性中。而文中的模型使用object proposals上的attention map中出现的信息来创建计数特征，这样做的好处是，注意机制能够区分出任何东西，而不仅仅是属于具有复数形式的预定类别的对象</p><p><a href="https://arxiv.org/abs/1712.08697">Trott et al.</a>采用强化学习的Loss在训练集VQA v2和Visual Genome上训练了一个连续计数方法，他们的准确率得到了小幅的提高，但是不确定他们的方法能否集成了一半的VQA模型中，因为其loss函数不适用于非计数问题，他们在自己的数据集上进行评估，结果很难与VQA中现有的结果进行比较</p><p><a href="https://arxiv.org/abs/1706.01427">Santoro et al.</a>和<a href="https://arxiv.org/abs/1709.07871v2">Perez et al.</a>在不采用bounding box和计数对象位置监督的情况下能够在synthetic CLEVR数据集中计数</p><p><a href="https://arxiv.org/abs/1703.08710">Cohen et al.</a>利用卷积接受域的重叠来提高计数性能，<a href="https://arxiv.org/abs/1604.03505">Chattopadhyay et al.</a>将图像分割成较小的不重叠的块，每个块单独计数，最后合并在一起</p><p>在这两种情况下，卷积接收域(convolutional receptive fields)或块可以看作是一组定位结构固定的bounding box</p><h2 id="PROBLEMS-WITH-SOFT-ATTENTION"><a href="#PROBLEMS-WITH-SOFT-ATTENTION" class="headerlink" title="PROBLEMS WITH SOFT ATTENTION"></a>PROBLEMS WITH SOFT ATTENTION</h2><p>这一章节的核心观点是利用注意力机制得到的特征向量不足以支撑计数，需要采用attention maps</p><p>VQA模型一直受益于用前层卷积网络实现的图像中的软注意力(soft attention)，它学习输出feature map中每个空间位置的feature vector的权值，首先对权值进行归一化，然后对空间位置进行加权和，得到一个单独的feature vector，然而，软空间注意严重限制了模型的计数能力</p><p>考虑两个统计猫的数量的Task：一个是将猫的图像放在一个干净的背景之下，另一个由第一幅图像的两个并排副本组成，这里描述的对象既适用于spatial feature maps，也适用于object proposals作为输入</p><p>利用目标检测网络，在第一幅图像中可以检测到一只猫，在第二幅图像中检测到两只猫，三种检测结果都产生相同的特征向量，然后，注意力机制给同一只猫的三个实例分配相同的权重</p><p>attention机制常用的归一化方法softmax将权值和归一化为1，问题就出现在了这里，第一幅图中的猫得到了1的权值，第二幅图中的两只猫分别得到了0.5的权值，经过加权和后，第二幅图像中的两只猫被平均为一只猫，加权和后得到的特征向量在两幅图像之间是完全相同的，使用注意机制得到特征向量导致丢失了attention map中可能的计数信息，所有将权重和归一化为1的方法都会遇到这样的问题</p><p>Multiple glimpses以及several steps of attention都无法解决这个问题，每个glimpse或step都不能单独将一个对象分离出来，因为给一个特征向量的注意权值不依赖于其他被关注的特征向量</p><p>Hard attention和structured attention是这个问题的可能解法，尽管到目前为止没有发现后者的计数能力有显著提高</p><p><a href="https://arxiv.org/abs/1605.09410v3">Ren &amp; Zemel</a>限制注意力一次只在一个bounding box内work来避免这个问题，这和作者提出的用object proposal来计数有异曲同工之妙</p><p>如果不将权重归一化，则输出特征的尺度取决于检测到的对象的数量，在有10只猫的图像中，输出的特征向量按比例增加到10。深度神经网络对尺寸是非常敏感的(scale-sensitive)，权重的初始化和激活的规模非常重要，特征尺度的增加会使得分类器不得不学习与计数相关的联合特征，这对计数问题来说并不合理。<a href="https://arxiv.org/abs/1708.02711">Teney et al.</a>实验证明了sigmoid归一化不仅会略微降低非数字问题的准确性，而且对计数也没有帮助</p><h2 id="COUNTING-COMPONENT"><a href="#COUNTING-COMPONENT" class="headerlink" title="COUNTING COMPONENT"></a>COUNTING COMPONENT</h2><p>处理重叠object proposals的核心思想是将这些object proposals转换成基于它们如何重叠的图表，然后以特定的方式去除和缩放边缘，从而恢复对底层对象数量的估计</p><p>总体策略是，主要针对完全重叠或完全不同的完美注意力映射和边框这种不现实的极端情况来设计组件</p><p>作者提出的组件在能够提升计数的同时仍然允许模型使用软注意力</p><h3 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h3><p>给定object proposals的feature，注意力机制根据问题对每个proposal设定权重，计数组件以最大的n个注意力权重$a=[a_1,\dots,a_n]^T$和对应的bounding box $b=[b_1,\dots,b_n]^T$作为输入</p><h3 id="DEDUPLICATION"><a href="#DEDUPLICATION" class="headerlink" title="DEDUPLICATION"></a>DEDUPLICATION</h3><p>首先将注意力权重向量a转换为更容易利用边界框的图形表示，因此计算注意权值的外积(叉乘)，得到注意矩阵</p><p>$A=aa^T$</p><p>A可以看做一个加权有向图的邻接矩阵，第i个点表示与$a_i$相关的object proposal，连接i和j的边权重为$a_i*a_j$，若$a_i$值只有0/1，那么外积就等价于逻辑与，所以只包含满足$a_i = 1$的顶点的子图是一个有自环的有向完全图</p><p>作者想要做的是在这张图上消除边，带自环的有向完全图的边和点的关系是$|E|=|V|^2$，$|E|$可以通过对邻接矩阵中的项求和来计算，$|V|$就是计数的答案</p><p>$\sqrt{|E|}=\sum_ia_i$</p><p>当所有proposal都完全不同时，组件可以输出与默认情况下简单地对原始注意权重求和相同的结果</p><p>为了实现目标，需要消除两种类型的边：对象内的边和对象间的边</p><h4 id="INTRA-OBJECT-EDGES"><a href="#INTRA-OBJECT-EDGES" class="headerlink" title="INTRA-OBJECT EDGES"></a>INTRA-OBJECT EDGES</h4><p>首先消除单个对象内部重复proposals之间的边</p><p>作者采用通常的IoU方法来比较两个bounding box，距离矩阵D定义为</p><p>$D_{ij}=1-IoU(b_i,b_j)$</p><p>D也可以被看成一个邻接矩阵，除了重叠的bounding box之外两两之间都有边，通过注意矩阵和距离矩阵的矩阵元素相乘来删除对象内部的边缘</p><p>$\bar{A}=f_1(A)\odot f_2(D)$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-2.png"></p><p>注意到$\bar{A}$不再有自环，为了使得$|E|=|V|^2$，需要再之后的处理中将自环加回去</p><h4 id="INTER-OBJECT-EDGES"><a href="#INTER-OBJECT-EDGES" class="headerlink" title="INTER-OBJECT EDGES"></a>INTER-OBJECT EDGES</h4><p>然后消除对象间因重复proposal导致的边</p><p>核心思想是计算与每个独立对象相关的proposal的数量，然后按该数字按比例缩小其关联边的权值</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-3.png"></p><p>如果一个对象有两个proposal，那么这些proposal的相连的边应按0.5的比例缩放，本质上这是对每个底层对象计算proposals的平均值，因为只使用边权的总和来计算最后的计数答案，由于不知道有多少个proposal是属于这个对象的，所以需要估算，作者采用相同对象的proposal是相似的这个GT来实现这一点</p><p>注意到$\bar{A}$没有自环，且在属于同一个对象的两个proposal之间没有没有边，因此两个非零行在$\bar{A}$中相等当且仅当两个proposal相同。因此在比较行的时候需要一个相似度函数，当全相同时返回1，存在至少一个位置不同时返回0，对于proposal相似度函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-4.png"></p><p>其中，$X = f_4(A)\odot f_5(D)$，X的求法和$\bar{A}$相似，只是激活函数不同</p><p>然后就可以检查两个proposal有多相似了，计算任意行与其他行相同的次数，并计算每个顶点i的比例因子$s_i$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-5.png"></p><p>因为比例因子需要作用于每个顶点，因此用外积将s扩展为矩阵，用以放缩每个顶点的入边和出边，这时候要把自环也加回来，因为也需要放缩，计数矩阵C可以表示为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-6.png"></p><p>diag()函数的作用是将向量扩展为以向量值作为对角线的对角矩阵</p><h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><p>最后将计数矩阵C转化为计数值c，$|E|=\sum_{i,j}C_{ij}$，$c=|V|=\sqrt{|E|}$</p><p>作者通过实验证明，当极端情况假设成立时，c始终是一个整数，等于正确的计数</p><p>为了避免在对象数量较大时出现伸缩性问题，作者将单一特性转换为几个类，每个类对应一个可能的数量，因为只使用具有最大n个权值的对象proposal，所以预测的计数c最多可以是n，作者将输出定义为$O=[O_0,O_1,\dots,O_n]^T$，其中$O_i=max(0,1-|c-i|)$</p><p>本文只使用可扩散操作来删除重复的object proposals，获得表示计数预测的特征向量，这使得这个模组比较容易地集成到任何采用软注意力的VQA模型中，利用注意力图来完成计数</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>在Toy Task上的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-7.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-8.png"></p><p>和SOTA的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-9.png"></p><p>仅在VQA的训练集上训练，在验证集上测试的结果</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-10.png"></p><p>可视化展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-11.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/learningToCount-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> count </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Where To Look [注意力机制]</title>
      <link href="2020/07/27/whereToLook/"/>
      <url>2020/07/27/whereToLook/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1511.07394">Paper Download Address</a></p><p>这篇文章主要致力于解决VQA和其它一些视觉推理问题中的一个核心任务：knowing where to look</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-1.png"></p><p>如图所示，若红绿灯能够成功被定位，则可以轻易回答问题”What color is the walk light”，如何能够定位到雨伞，则有利于回答”Is it raining”，模型需要学习到被期待的答案的类型，以及做出回答需要基于图片的哪部分</p><p>where to look的实现是具有挑战性的，有些问答需要利用全图，而有些回答则需要关注特定的区域，文章中忽略需要额外知识辅助回答和需要推理回答的问题(比如图中男女在约会么)</p><p>作者的key idea是学习一个非线性映射，将图片和问题投射到相同的latent space来确定它们之间的关联，然后对相关区域和QA对的匹配度打分，latent space和打分函数由用QA对监督的margin-based loss来共同学习</p><p>文章主要的贡献为：</p><ol><li><p>提出了一个图像区域选择机制，学习识别问题相关的图像区域</p></li><li><p>提出了一个采用margin-based loss的VQA多选题的学习框架，明显优于<a href="https://arxiv.org/abs/1505.00468">baseline</a></p></li></ol><ol start="3"><li>对baseline不使用图片，使用全图，使用加权的图像区域进行对比，对图像区域选择对VQA表现的影响提供了更细致的分析</li></ol><h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><p>作者认为VQA可以被视为一种定向字幕任务，因此他参考了一些图片字幕task的paper，<a href="https://arxiv.org/abs/1411.4952">Fang et al</a>在图像的不同部分检测到单词，并与语言模型结合在一起生成字幕，<a href="https://arxiv.org/abs/1502.03044">Xu et al</a>采用RNN检测突出目标，逐个生成字幕词，而文章中的工作则是将问题文本作为输入来确定图像中的相关区域</p><p>文章中采用VQA数据集，因为多选题比开放问题更好评估，现在(2016)多数VQA数据集用图像标注来生成问题，这限制了所需的视觉和抽象知识的范围</p><p>作者称他们的模型受到<a href="https://arxiv.org/abs/1503.08895">End-to-End Memory Networks</a>的启发，模型中的区域类似于该Paper中的句子，并类似地，学习了图片和问题的embedding到相同子空间，用内积来确定相关性</p><p><a href="https://arxiv.org/abs/1506.00511">Ba et al</a>采用了类似的框架，但是使用的是零样本学习方法，同样也是将语言和视觉特征投影到相同子空间中，采用内积进行相似性计算，但得分用于指导对象分类器的生成，而非图像区域排序</p><p>作者还提到了Bag-Of-Words，LSTM和word2vec，作者表示在实验中采用word2vec，发现挺好用的</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-2.png"></p><p>模型整体的框架如图，输入包含问题，潜在的答案，和一组自动选择的候选区域的图像特征，作者使用word2vec和一个两层的网络对解析后的问题和答案进行编码，每个区域图像特征用在ImageNet上预训练的CNN的前两层来编码，随后两个特征通过内积结合，然后用softmax去产生每个区域的权重，将加权平均值输入一个二层的网络得到区域的分数</p><h3 id="QA-Objective"><a href="#QA-Objective" class="headerlink" title="QA Objective"></a>QA Objective</h3><p>作者希望最大化正确和错误选择之间的差距，作者通过以下loss函数实现这个目标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-3.png"></p><p>以上的目标要求正确答案$y_p$的分数至少比从一组错误答案中选出的最高分错误答案$y_n$的分数高一些</p><p>那么高多少呢，举个例子，6/10的标注着标注了答案p，而2/10个标注着标注了n，那么$y_p$得比$y_n$得分要高0.4</p><h3 id="Region-Selection-Layer"><a href="#Region-Selection-Layer" class="headerlink" title="Region Selection Layer"></a>Region Selection Layer</h3><p>模型的区域选择层有选择地结合输入的文本特征和来自图像相关区域的图像特征，为了确定相关性，该层首先将图片特征和文本特征映射到相同的一个N维空间，然后计算QA特征和每个图片区域特征的内积</p><p>设$G_r$是所有区域特征在$x_r$的列向量中的投影，gl是单个问答对词嵌入的投影，计算相关性权重的前馈传递计算方法如下</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-4.png"></p><p>(4)式是内积之后做sofmax，b是偏移，内积的目的是迫使模型以类向量方式确定区域相关性</p><p>每个特征向量用W进行线性投影，利用$s_r$计算加权平均，得到每个问题和答案对的特征向量$a_l$，再通过relu层和批归一化层进行反馈</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-5.png"></p><p>作者尝试过直接从连接的视觉和语言特征来预测关联分数，但是最终的模型与语言特征无关，内积是尝试过的唯一有效的方法</p><h3 id="Language-Representation"><a href="#Language-Representation" class="headerlink" title="Language Representation"></a>Language Representation</h3><p>作者用300维的word2vec向量来表示单词，通过使用word2vec向量的平均值，为每一QA对构建固定长度的向量，然后学习如何对这些向量进行评分，实验表明这种向量表达方式明显优于更加复杂的基于lstm的模型</p><p>作者首先尝试对每个单词的问题和答案分别平均向量，并将它们连接起来得到一个600维的向量，但是由于word2vec表示不是稀疏的，平均单词可能会混淆表示</p><p>因此作者采用Stanford Parser来优化表示，将问题存储到额外的独立语义箱(bin)中，容器如下：</p><p>Bin 1：通过平均前两个单词的word2vec表示来捕获问题的类型(how many|is there|…)</p><p>Bin 2：编码问题的主语</p><p>Bin 3：包含所有其他名词词的平均值</p><p>Bin 4：包含所有剩余单词的平均值，不包括限定词如”a”、”the”和”few”</p><p>每个bin包含一个300维的表示，它与候选答案中的单词的bin连接在一起，生成一个1500维的问题/答案表示</p><p>下图展示了对解析后的问题封装的示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-6.png"></p><h3 id="Image-Features"><a href="#Image-Features" class="headerlink" title="Image Features"></a>Image Features</h3><p>图像特征直接从预先训练好的网络输入到区域选择层，首先通过IOU为0.2的非最大抑制(NMS)提取排名最高的99个Edge Boxes，由于排名靠前的区域往往是高度重叠的大区域，这种具有侵略性的非最大抑制方法，对选取对某些问题有效的较小区域有十分重要的作用</p><p>最后，还添加了一个全图像区域，以确保模型在必要时至少具有全帧的空间支持，使得每张图像的候选区域总数达到100个</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-7.png"></p><p>模型对比</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-8.png"></p><p>可视化比较</p><p>L：Word only model</p><p>I：Word+Whole Image</p><p>R：Region Selection</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-9.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/whereToLook-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> attention </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2016 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips and Tricks for Visual Question Answering</title>
      <link href="2020/07/23/BUTD1/"/>
      <url>2020/07/23/BUTD1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1708.02711">Paper Download Address</a></p><p>这篇文章提出了一个相对简单的VQA模型，达到了SOTA的效果，文章的核心目的是分享一个成功的VQA模型的细节</p><p>model首先得到问题和图片的联合嵌入(joint embedding)，随后是针对一组候选答案的多标签分类器，这种通用方法是现在很多VQA模型的基础，模型的细节对于获得高质量的结果至关重要</p><p>同时作者在模型上采用了一些关键的技术创新，极大提高了模型的表现，作者在探索模型空间结构和超参数上进行了大量的实验，以确定每个组件的重要性</p><p>主要发现概括如下</p><p>—— 使用sigmoid输出，允许每个问题有多个正确答案，而不是一个常见的单标签softmax</p><p>—— 使用软分数作为GT目标，使得task为候选答案分数的回归，而不是传统的分类</p><p>—— 对所有非线性层使用gated tanh激活函数</p><p>—— 采用bottom-up注意力得到的图片特征，自底向上注意力提供的是特定区域的特征，而非CNN传统的网格特征图</p><p>—— 使用预先训练好的候选答案表示来初始化输出层的权重</p><p>—— 在随机梯度下降的训练过程中对训练数据采用较大的mini-batches，以及智能打乱(smart shuffling)</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>自<a href="https://arxiv.org/abs/1505.00468">VQA奠基性论文</a>发表以来，VQA task就成为了计算机视觉领域研究者关注的焦点，因为该task是对深度视觉理解的评估，这是计算机视觉的首要任务</p><p>VQA任务是极具挑战性的，其需要理解文本问题，解析图像的视觉元素，并对这些模式进行推理，有时还需要借助外部知识或常识</p><p>其它类似的task还有图像字幕和视觉对话</p><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p>数据集包含图片，human-proposed问题和GT答案，VQA-real数据集是在2015年提出VQA task的时候提出的，存在的问题是模型对于QA对的language-based priors和rote-learning成为了提高表现的过于有效的方法，这使得无法对model进行有效评价和边角，因此该数据集有了新的版本VQA v2，这个数据集中，每个问题都有两张对应图像，更重要的是，这两幅图像的选择使得每一幅图像都能得到不同的答案，这种设置显然不鼓励盲目猜测，即仅从问题推断答案，这是文章中实验的主要数据集</p><p>这篇文章中另一个用到的数据集是Visual Genome，这个数据集包含场景图形式(scene graphs)的图片注释，这构成了图像的细粒度(fine-grained)描述，它们提供了一组出现在场景中的视觉元素，物体，人)，以及它们的属性(例如颜色，外观)和它们之间的关系，与VQA v2的问题相比，这个数据集的问题有更多样化的形式和更多样化的答案。这个数据集的答案通常比较长，而VQA v2的答案只有1至3个词，文章中只用这个数据集中和VQA问题答案重叠的问题子集</p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>VQA的主流方法包含三个步骤：</p><p>(1) 将问答视为从候选答案中选择正确答案的分类问题</p><p>因为当前VQA数据集中的问题本质上大多是可视化的，因此正确的答案只涵盖了一小组单词和短语(通常是几百到几千)</p><p>(2) 深度神经网络实现联合嵌入模型</p><p>大多数VQA模型都是基于深度神经网络实现图像和问题的联合嵌入，这两个输入分别用CNN和RNN映射成固定大小的向量表示，然后通过进一步的非线性映射将其投射到相同的语义空间，随后可以按元素顺序相乘的连接方式组合，并作为分类器的输入</p><p>(3) 示例问题/答案作为监督进行端到端(end-to-end)的训练</p><p>由于深度学习在监督学习问题上的成功，整个神经网络都是从问题、图像和它们的GT答案端到端进行训练的</p><p>因为图像和问题的输入空间维数巨大，所以产生的训练信号稀疏，因而需要大量的训练数据。</p><p>作者通过大量的一系列实验表明，在实现过程中一些关键的选择(例如，门选激活、回归输出、智能打乱等)可以显著提高相对简单的模型的性能，文章将展示如何通过一步步的选择来优化一个幼稚的实现</p><h2 id="Proposed-model"><a href="#Proposed-model" class="headerlink" title="Proposed model"></a>Proposed model</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-0.png"></p><h3 id="Question-embedding"><a href="#Question-embedding" class="headerlink" title="Question embedding"></a>Question embedding</h3><p>首先用空格和标点将问题分解成单词，数字也被当做是单词，为了提高计算效率，问题被削减到最多14个单词，多余的单词简单地抛弃(因为实际上只有0.25%的问题长度超过了14)</p><p>每个单词都被转换成一个带有查找表的向量表示，这些向量是用预先训练好的Grove嵌入来初始化的(Global Vectors for Word Representation)，初始值中没有零向量，小于14个单词的问题末尾用零向量填充，处理的词嵌入结果为$14 \times 300$</p><p>然后将其馈入GRU，循环单元的内部状态为512维，我们采用RNN的末态，作为question embedding，在过程中，作者并没有标记开端和结尾，也没有修剪序列和标记数字，作者发现对于相同迭代次数，始终运行循环单元会更有效</p><h3 id="Image-features"><a href="#Image-features" class="headerlink" title="Image features"></a>Image features</h3><p>输入图片通过CNN得到大小为$K \times 2048$的向量，K是图像区域的个数，每个区域都由2048维向量来编码</p><p>这里作者给出了两种方法：一是在ImageNet上预训练的200层的ResNet，得到$14 \times 14$的feature map之后再进行平均池化，得到$7 \times 7$的feature map，二是用基于ResNet和Faster R-CNN的bottom-up attention</p><p>作者对K=36和自适应K进行评估，自适应K允许K随着图像的复杂程度变化，上限为100，VQA v2在自适应K的情况下K的平均值为60</p><p>在VQA模型的训练过程中，CNN都是预先训练并保持固定的，这样可以从输入图像中提取特征作为预处理步骤以提高效率</p><h3 id="Image-attention"><a href="#Image-attention" class="headerlink" title="Image attention"></a>Image attention</h3><p>文章中的模型采用了常见的问题导向注意力机制，作者将这一阶段称为top-down attention，出于和bottom-up attention的对比</p><p>对于 $i=1 \dots K$，特征向量$v_i$和问题词嵌入串联，通过一个非线性层$f_a$和一个线性层，得到权重，和特征进行矩阵点乘</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-1.png"></p><p>超参数$w_a$通过学习得到，所有位置的注意力权重都使用softmax函数进行标准化(2)，然后用归一化值对所有位置的图像特征进行加权和求和(3)，最后得到2048维向量表示注意力图</p><h3 id="Multimodal-fusion"><a href="#Multimodal-fusion" class="headerlink" title="Multimodal fusion"></a>Multimodal fusion</h3><p>特征向量v和词嵌入q通过非线性层，求Hadamard积</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-2.png"></p><p>h作为图片和问题的联合嵌入，馈入分类器</p><h3 id="Output-classifier"><a href="#Output-classifier" class="headerlink" title="Output classifier"></a>Output classifier</h3><p>从训练集中出现8次以上的所有正确答案中预先确定一组候选答案，称之为输出词汇表，共有N=3129个候选答案。作者将VQA视为一个多标签分类任务，实际上，VQA v2数据集中的每一个训练问题都与一个或多个答案相关联，每个答案的软精度为[0,1]</p><p>在训练中，有一些训练问题(约7%)在选择的输出词汇中没有正确答案，这些问题也没有被舍弃，它们通过将输出词汇表的所有候选词汇的预测分数趋近于零来提供一个有用的训练信号</p><p>多标签分类器将联合嵌入h通过一个非线性层$f_o$，然后通过一个线性映射$w_o$来预测N个候选对象的得分</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-3.png"></p><p>$\sigma$是sigmoid函数，$w_o \in R^{N*512}$是一个可学习矩阵</p><p>目标函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-4.png"></p><p>i和j对应M个训练问题和N个候选答案</p><p>上述公式被证明比其他VQA模型中常用的softmax分类器更有效，首先，sigmoid输出允许优化每个问题的多个正确答案，其次使用软分数作为目标提供了比二进制目标稍微丰富的训练信号，因为它们捕获了GT注释中偶尔出现的不确定性</p><h3 id="Pretraining-the-classifier"><a href="#Pretraining-the-classifier" class="headerlink" title="Pretraining the classifier"></a>Pretraining the classifier</h3><p>在训练过程中，每个候选答案的合适表示形式被学习为$w_o$，作者建议使用来自两个源(source)的候选答案的先验信息来初始化$w_o$，当答案不能通过预先训练的嵌入精确匹配时，使用经过拼写检查、去掉连字符或从多词表达式中保留单个词后的最接近匹配，放入矩阵$w_o^text$</p><p>作者还使用了候选答案对应的图片中的视觉信息，用Google Images 来对每个候选答案检索10张图片，这些图片被馈入在ImageNet上预训练的ResNet-101，提取10张图的平均特征，对于每个候选答案的2048维向量按行写入矩阵$w_o^img$</p><p>这些视觉表征与通过单词嵌入获得的语言表征是互补的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-5.png"></p><p>将先验表示$w_o^{text}$和$w_o^{img}$组合</p><p>$f_o^{text}$和$f_o^{img}$是非线性函数，h是(4)式的Hadamard积</p><h3 id="Nonlinear-layers"><a href="#Nonlinear-layers" class="headerlink" title="Nonlinear layers"></a>Nonlinear layers</h3><p>上述网络中采用了多个非线性层，通常的实现方法是一个仿射变换后接一个ReLU函数，作者采用的是门控双曲正切激活函数(gated hyperbolic tangent activation)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-6.png"></p><p>W’是可学习矩阵，b’是可学习偏移量，g作为一个门控，公式的灵感来源于GRU和LSTM，这也可以看作是Highway Network的一个特例</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p>作者采用随机梯度下降来训练网络，选择不需要固定学习速率，并且对参数的初始化不敏感的<a href="https://arxiv.org/abs/1212.5701">AdaDelta algorithm</a></p><p>模型容易过拟合，所以作者通过提前停止来防止过拟合，首先训练不使用VQA v2数据集的官方验证集来进行监控，并确定产生最佳性能的epoch，然后以相同的epoch数重复训练，并使用验证集作为训练数据</p><p>同时使用Visual Genome的QA对作为额外的训练数据，只使用正确答案与根据VQA v2数据集确定的输出词汇表重叠的问题</p><p>在随机梯度下降的训练过程中，作者加强了训练实例的shuffling，以保持VQA v2对在同一mini-batches内的平衡，这些对对应相同的问题有不同的图像和答案</p><p>作者直觉上认为，这样的pair可能导致将网络参数拉向不同方向的梯度，将一个示例和它平衡的对应部分保存在同一个小批中可以使学习更加稳定，并鼓励网络识别成对实例之间的细微差别</p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>除了一些用于多线程加载输入数据的Java代码外，模型完全是使用自定义深度学习库在Matlab中实现的，一个网络通常需要训练12到18个epochs，单Nvidia K40 GPU采用K-36特征大概花费12到18小时，在CPU上需花费两倍时间</p><h2 id="Ablative-experiments"><a href="#Ablative-experiments" class="headerlink" title="Ablative experiments"></a>Ablative experiments</h2><p>所有实验均为single network，在VQA v2和上文提到的部分Visual Genome上训练，结果采用最好的epoch，每个实验进行了三次重复，每次采用不同的随机种子，展示的结果是三次重复实验的平均值，主要的性能指标是标准的VQA准确度，此外，文章还额外做了成对的精度测量(两张不同图片的相同问题，产生两个不同的答案)，这个标准比标准的每道题得分要难得多，因为它要求对两组图像都有正确的答案，不能盲目猜测和依赖语言先验</p><h3 id="Training-data"><a href="#Training-data" class="headerlink" title="Training data"></a>Training data</h3><p>作者比较了在相同的小批量中保持平衡的训练数据变换与标准的、任意的随机变换，前者取得了更高的准确率，这是可以预料的，因为提出的方法的目的是学习区分平衡对</p><p>随后作者评估了抛弃那些在词汇表中没有他们的真实答案的训练问题，早期实验证明了这些例子仍然具有有用的训练信号的，在实验表格中发现，这些训练问题有非常小的好处</p><h3 id="Question-embedding-1"><a href="#Question-embedding-1" class="headerlink" title="Question embedding"></a>Question embedding</h3><p>作者采用的是预训练的300维的GloVe词嵌入，前接单层GRU处理字，作者将这个选择和一系列更简单更高级的方法对比</p><p>从零开始学习词嵌入将会降低0.87%的performance，在训练数据较少的情况下差距更大，这个实验一方面显示了利用非vqa训练数据的好处，另一方面，它表明一个足够大的VQA训练集可能会完全消除这种好处，使用较低维度的GloVe vectors(100或200)，也会降低性能 (那会不会采用400或者更多会有更好的效果还是边际效应严重递减，作者没做对应实验)</p><p>对于embedding问题，作者还做了一个实验，用于验证GloVe是否真的提取了词信息，还是因为向量在词嵌入空间的简单传播本身就是benefit。作者对GloVe vector进行了随机的shuffle，将它们与从输入字典中随机选择的单词联系起来，结果是得到了比从零开始学习的词嵌入更差的效果，得出的结论是GloVe vector确实获取了词信息</p><p>作者还尝试了在单词embeddings之后进行tanh激活，但对结果没有明显的改变，同时用更高级的方式(向后、双向或两层GRU)来替代GRU会导致性能的下降</p><h3 id="Image-features-1"><a href="#Image-features-1" class="headerlink" title="Image features"></a>Image features</h3><p>文章中的最佳模型使用了bottom-up attention的图像特征，通过一个faster R-CNN框架和一个底层的聚焦于特定图像区域的ResNet101获得。该方法对目标检测使用固定的阈值，因此特征数与图像内容自适应。它的最大值为100，并产生K=60的平均值。作者用K=36的固定数量的特征进行实验，性能仅略微下降，考虑到较低的实现和计算成本，这可能是一个合理的选择</p><p>在实验中作者还发现L2的规范化图像特征对于良好的性能至关重要</p><h3 id="Image-attention-1"><a href="#Image-attention-1" class="headerlink" title="Image attention"></a>Image attention</h3><p>参考模型使用单一的K个注意权值集合，使用softmax进行归一化，之前的一些研究报告称，使用多组注意力权重会有更好的表现，作者的实验表明他们都是瞎说的</p><h3 id="Output-vocabulary"><a href="#Output-vocabulary" class="headerlink" title="Output vocabulary"></a>Output vocabulary</h3><p>作者将在训练集中出现超过L次的答案加入词汇表，经过测试L的最佳值大概在8到12之间，对应词数量在2400到3800之间，较高的L仍可以通过较低的参数数量和计算复杂度提供合理的性能</p><h3 id="Output-classifier-1"><a href="#Output-classifier-1" class="headerlink" title="Output classifier"></a>Output classifier</h3><p>作者采用softmax输出和软分数作为GT目标</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-7.png"></p><p>上表显示了软分数明显表现得更好</p><p>随后作者比较了使用sigmoid和使用常见的softmax输出，均采用交叉熵损失，softmax使用数据集中提供的单一GT答案，而sigmoid使用完整的注释数据，由于多个注释者之间的分歧，有时会为一个问题标记多个正确答案，sigmoid表现显著优于softmax</p><p>然后作者对$w_o^{text}$和$w_o^{img}$的预训练进行评估，考虑两种baseline：随机初始化和随机shuffle，作者提出的方法优于这两种baseline</p><p>作者将每个答案的召回率定义为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-8.png"></p><p>M是问题数量，s是GT分数，$\hat{s}$是预测分数</p><p>注意到作者文中提出的方法虽然有总体上的好处，但是对很多答案的召回率会产生负面影响</p><h3 id="General-architecture"><a href="#General-architecture" class="headerlink" title="General architecture"></a>General architecture</h3><p>所有的非线性层都采用了gated tanh，结果优于gated ReLU，且显著优于simple ReLU和tanh，作者还尝试过highway，residual，gating的其它组合，但是没有得到更好的效果，门控层的一个好处是，在不增加隐藏状态维数的情况下，学习参数的数量翻倍</p><p>作者对隐藏层的维度进行试验，得到512是最佳的</p><p>最后图像表示和问题表示的融合采用矩阵元素点乘的方式，实验证明这种方法比矩阵连接方式要好，但是作者没有对其它高级的特征融合方式进行测试</p><h3 id="Minibatch-size"><a href="#Minibatch-size" class="headerlink" title="Minibatch size"></a>Minibatch size</h3><p>mini-batches的大小对模型的表现有很大的影响，{128; 256; 384; 512; 768}比其它更小的minibatch值要更好一些，虽然他们需要显着更多的内存和高端gpu</p><h3 id="Training-set-size"><a href="#Training-set-size" class="headerlink" title="Training set size"></a>Training set size</h3><p>作者在四个模型上实验了训练效果和训练数据量的关系</p><p>四个模型如下：</p><p>(1) 作者的最佳模型</p><p>(2) 用从零开始学习的词嵌入代替GloVe vectors</p><p>(3) 分类器从零开始学习而非预训练两个w矩阵</p><p>(4) 结合(2)和(3)</p><p>不出所料，性能会随着训练数据量的增加而单调地提高，并且呈对数趋势</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-9.png"></p><p>作者发现只要10%的训练数据就能获得不错的性能，对整个数据集进行训练所获得的增益相对于10倍的数据增长显得很小，这种情况在数据遵循Zipf 法则的自然语言问题和其它均有长尾分布的问题中很常见，少数的样本足够学到最常见的情况，但是要覆盖罕见数据，则需要的数据数量则指数级增长</p><p>采用额外的数据来预训练词嵌入和分类器总是有利的，随着训练数据的增多，从零开始的baseline模型之间的差距会逐渐减少</p><p>预先训练的单词嵌入和预先训练的分类器都提供了相同量级的提升，且这两种技术是互补的，通过结合它们可以获得最佳性能</p><h3 id="Ensembling"><a href="#Ensembling" class="headerlink" title="Ensembling"></a>Ensembling</h3><p>为了获得更好的性能，作者采用了将多个网络集成在一起的尝试，集成采用的是最简单的方式，训练同一个模型的多个实例，采用不同的初始化随机种子，这影响了学习参数的初始化和梯度下降的优化，在测试的时候，将所有实例得到的分数汇总，取最高分</p><p>性能随着网络实例数量的增加而单调增加，作者通过30个网络获得了最终的最佳结果。多个实例的训练是独立的，在多个cpu或gpu上具有明显的并行性。作者发现，即使是2-5个实例的小集合也可以在单个网络上显著提高性能</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD1-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> attention </tag>
            
            <tag> CVPR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EST-VQA [双语文本VQA]</title>
      <link href="2020/07/20/ESTVQA/"/>
      <url>2020/07/20/ESTVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Wang_On_the_General_Value_of_Evidence_and_Bilingual_Scene-Text_Visual_CVPR_2020_paper.pdf">Paper Download Address</a></p><p>对数据集中的巧合相关性的学习使得VQA系统难以泛化，巧合相关性在数据集中并不稳定，当测试集中的分布与训练集不同时，基于巧合相关性所学习到的东西就不再work</p><p>泛化VQA存在的一个潜在问题就是无法判断正确答案是否由正确的理由产生，通过推理得到的答案和通过巧合相关性得到的答案表面上是完全一致的</p><p>文章中提出一种度量VQA性能的方法，它通过要求算法证明其推理的合理性来鼓励泛化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-1.png"></p><p>之前也有相关工作研究过推理过程，但是因为提供理由的形式是有限的而饱受困扰，文章中的方法是提供一个简单的指示，说明它的答案是基于图像的哪个区域，若VQA系统提供了正确的答案和正确的图像区域，则说明其推理过程是正确的</p><p>作者在Scene Text VQA上做测试，选择这种测试集的原因是大部分VQA model在Text VQA数据集上表现不佳，但是图片中的文本对图片的理解往往是很有指示意义的，而且文本VQA问题通常不太容易通过利用数据中的巧合相关性来解决</p><p>同时，因为文本VQA图像中出现的文本范围十分广泛，因此基于分类的方法很容易过拟合，需要开发替代方法，并且这些方法可以推广到其它方面</p><p>图中是一些Text VQA中的挑战</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-2.png"></p><p>图(a)不需要任何文本内容就可以作答，图(b)拥有不止一个正确答案，图(c)需要先验知识才能回答，图(d)不能够直接从图片内容中获得答案，需要model拥有额外的技能</p><p>下图是Evidence-Baced VQA和传统VQA(LoRRA)的对比，可以看出来目前的VQA方法严重依赖于通过分析训练集中的答案而构造的预定义答案空间，从而限制了泛化</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-3.png"></p><p>Text-VQA数据集采取的是传统的VQA评估方式，也就是准确率，ST-VQA数据集软分数度量方式，但是这些都是结果导向的评估方式，并未评估推理过程，这种基于分类的VQA系统容易过度拟合到一个固定的答案空间，不容易推广到其它数据集</p><p>为了解决这些问题，文章中提出了一种新的scene-text based VQA数据集，命名为Evidence-based Scene Text Visual Question Answering(EST-VQA)，其中包含了三个task：cross language challenge，localization challenge以及traditional challenge，此外进行了一系列实验确定了这三个挑战的baseline</p><p>文章主要贡献有：</p><ol><li>Dataset：EST-VQA数据集提供了图片，问题和答案，以及对于每个问题的一个bounding box，将导向答案的区域框出来，数据集的目的是支持开发更接近实际应用程序所要求的性能水平的文本VQA方法，同时也鼓励开发泛化的通用VQA方法</li><li>Evaluation Metric：文章中提出了一种Evidence-based评估方法，要求VQA在预测答案的时候提供证据，同时，提出了一种新的VQA模型，在新的度量标准下，单纯的分类模型可能很难有好的效果</li><li>Bilingual：EST-VQA是首个双语场景文本VQA数据集，其中包含了英语和中文的问题和答案，双语数据集可以更好地激励VQA系统泛化，因为对于多种语言的数据集来说，表层的相关性更难被挖掘，所选择的语言在语法上也特别不同，反映了不同的文化人群，这导致了不同的问题统计，进一步鼓励了泛化</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>相比于传统的VQA，文本VQA数据集更多关注于依赖于文本的问题，model需要读取和理解图片中的文本内容</p><p>[1]中提出了Text-VQA和一个baseline model LoRRA，如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-4.png"></p><p>Amanpreet Singh, Vivek Natarajan, Meet Shah, Yu Jiang, Xinlei Chen, Dhruv Batra, Devi Parikh, and Marcus Rohrbach. Towards vqa models that can read. In Proc. IEEE Conf. Comp. Vis. Patt. Recogn., pages 8317–8326, 2019</p><p>类似的数据集还有ST-VQA，OCR-VQA，这些数据集都提供了图片和依赖于图片中文本的QA对，但是文中的数据集与这些数据集有一些重要的不同之处：</p><p>Diversity：现有数据集更多地关注问题回答部分，而在模型的训练和评估中几乎忽略了OCR部分，而EST-VQA关注了这一点</p><p>Evaluation Metric：</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-5.png"></p><p>NL是normalized Levenshtein distance</p><h2 id="EST-VQA"><a href="#EST-VQA" class="headerlink" title="EST-VQA"></a>EST-VQA</h2><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><ol><li><p>图片：图片一共20757张，英文的场景文本图像来自于Total-Text，ICDAR 2013，ICDAR 2015，CTW1500，MLT，COCO Text，中文的场景文本图像来自于LSVT</p></li><li><p>问题和答案：包含15056个英文问题和13006个汉语问题，问题和答案可以跨语言，比如英文提问图片中商店的名字，如果是中文则答案输出中文。问题和答案必须和图片中的文本有关，标注人需要再图片中用bounding box标注出回答相关的区域作为证据。并且不存在yes/no类别以及存在多种回答的问题</p></li></ol><p>中英文问题分布见下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-6.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-7.png"></p><p>问题和答案的数量如下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-8.png"></p><h3 id="Evidence-based-评估方法"><a href="#Evidence-based-评估方法" class="headerlink" title="Evidence-based 评估方法"></a>Evidence-based 评估方法</h3><p>在实验中，作者发现了一个有趣的现象，若真实答案被包含在预生成的答案字典中，则普通的VQA模型可以在不提取图片中文本内容的情况下回答正确问题，这种模型严重依赖于预定义的答案池，无法处理超出词汇列表的情况。因此难以判定模型是理解并推理完成了问题还是overfit了答案空间。作者提出了Evidence-based评估方法(EvE)，要求模型为自己预测的答案提供证据</p><p>EvE评估包含两个步骤，check答案和check证据，文章中采用了normalized Levenshtein similarity score(见上文公式)来check答案，最后用IoU度量来确定证据是否充分</p><p>对Evidence的评估如图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-9.png"></p><p>$B_{gt}$和$B_{det}$是GT以及预测的bounding box</p><p>评估示例如下图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-10.png"></p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>Text-VQA和OCR-VQA遵循和一般VQA数据集相同的评估规则，ST-VQA虽说提出了三个任务，但是每个任务的区别只在于外部信息的大小，这些都不足以全面评价VQA模型的能力</p><p>文章中设计了三个相关的任务，并且采用在线评估</p><h4 id="Cross-Language-Challenge-CLC"><a href="#Cross-Language-Challenge-CLC" class="headerlink" title="Cross Language Challenge (CLC)"></a>Cross Language Challenge (CLC)</h4><p>因为数据集是双语的，因此要求模型能够在两种语言之中提取共同的知识，作者采用单语框架(Chinese-only,English-only)和双语框架来评估，用EvE来度量性能</p><h4 id="Localization-Challenge-LC"><a href="#Localization-Challenge-LC" class="headerlink" title="Localization Challenge (LC)"></a>Localization Challenge (LC)</h4><p>作者提出要求VQA model在预测答案的同时将导向答案的证据用bounding box框起来，而非简单地用现成的OCR系统来获取OCR token。因此这个task主要是要求VQA有理解问题和正确定位答案相关区域的能力，采用GT和predicted bounding box之间的IoU作为度量标准</p><h4 id="Traditional-Challenge-TC"><a href="#Traditional-Challenge-TC" class="headerlink" title="Traditional Challenge (TC)"></a>Traditional Challenge (TC)</h4><p>这部分和传统的VQA task一致，不考虑evidence，将预测答案与GT之间的归一化Levenshtein相似度评分作为这一Task的度量</p><h2 id="Baselines-and-Results"><a href="#Baselines-and-Results" class="headerlink" title="Baselines and Results"></a>Baselines and Results</h2><p>经过一系列实验和分析(略)，作者发现测试的SOTA模型均不能同时输出答案和相关的bounding box，因此提出了一个新的VQA模型：QA R-CNN</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-11.png"></p><p>如图所示，模型包含两个部分，Focusing Module (FM)和Reasoning Module (RM)，FM的核心部分是为text detection准备的Faster R-CNN。除了传统的Faster R-CNN输出的bounding box和对象标签之外，QA R-CNN还为每个box生成一个关注得分。对于词嵌入(word embedding)的生成，英文的采用GloVe，中文的则采用Word2Vec，然后词嵌入馈入LSTM来生成问题特征。然后连接图片和问题两部分特征，区分box和非box部分，这使得QA R-CNN能够将其注意力集中到图像中可能出现答案的区域</p><p>这里有一个简单的想法是，模型可以直接使用关注分数最高的box的底层文本作为问题的答案，然而这种做法忽略了文本当中的丰富语义</p><p>因此引入RM模块，以进一步完善通道，用FastText模型来取得OCR的词嵌入，再将词嵌入与图像特征和问题嵌入做进一步的融合，用于进一步的分类</p><p>实验结果展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/ESTVQA-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2020 </tag>
            
            <tag> dataset </tag>
            
            <tag> TextVQA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Squeeze-and-Excitation Networks</title>
      <link href="2020/07/17/SE/"/>
      <url>2020/07/17/SE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1709.01507">Paper Download Address</a></p><p>在卷积网络的每一层，一些卷积核沿着输入通道方向表示相邻特征模式，在局部感受野(local receptive fields)的范围内融合空间及channel-wise特征信息。通过交错的组合卷积，下采样，非线性层等构建网络，CNN可以达到理论上的全局感受野(global theoretical receptive fields)，以捕获图像的特征来进行图像的描述。最近的研究表明，将集成学习机制整合到CNN中可以提高网络的表示能力，Inception结构中嵌入了多尺度信息，聚合多种不同感受野上的特征来获得性能增益，还有进一步的工作是寻求更好地模拟空间依赖性，并将空间注意纳入网络的结构</p><p>文章跟以往的网络结构均不同，研究的是通道(channel)之间的关系。文章中提出了一种机制，允许网络执行特征重新标定，通过这种机制，网络可以学会使用全局信息，有选择地强调信息特征，抑制不太有用的特征</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-1.png"></p><p>给定输入X，通过一系列的卷积操作变成特征通道数为C的U，执行Squeeze操作，顺着空间维度进行特征压缩，将每个二维的特征通道变为一个实数，这个实数在某种程度上具有全局感受野，随后是Excitation操作，采取简单的自选门机制的形式，将embedding作为输入，为每个通道生成权重，最后是Reweight操作，将输出的权重加权乘到通道特征上</p><p>可以通过简单地堆叠SE-block来组成SE-Net，也可以轻松地插入到其它网络中，虽然构建块的模板是通用的，但在整个网络中，它在不同深度执行的角色是不同的，在较低的层中，它以一种与类无关的方式激发信息特性，加强了共享的低层表示，随着层次的加深，SE-block变得越来越专门化，并以高度类特定的方式响应不同的输入，因此SE块实现的特征重标定的好处可以通过网络的层次积累</p><p>设计和实现一个新的CNN架构通常需要选择许多新的超参数和层配置，但是SE-block可以通过简单地替换组件，应用在SOTA模型中来提升性能，同时，SE-block在计算上是轻量级的，只轻微地增加模型复杂度和计算负担</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="Deeper-architectures"><a href="#Deeper-architectures" class="headerlink" title="Deeper architectures"></a>Deeper architectures</h3><p>VGGNets和Inception models显示了提升网络的深度可以显著地提高网络的表达能力，ResNet证明了通过skip-connection，可以学习到更深更强的网络，Highway networks通过引入一个门控系统调节shortcut connections的信息流</p><p>另一个与之密切相关的研究方向集中于改进包含在网络中的计算元素的函数形式，分组卷积已被证明可以用来提升转换能力，通过多分支卷积可以实现更灵活的操作符组合，这可以被视为分组卷积的自然扩展。在之前的工作中，卷积通道的相关性通常被映射为特征的新组合，或者独立于空间结构，或使用1*1卷积核的标准卷积滤波器联合，这些研究大多致力于降低模型和计算复杂度，而作者认为，使用全局信息显式地建模通道之间的动态非线性依赖关系，可以简化学习过程，并显著增强网络的表征能力</p><h3 id="Algorithmic-Architecture-Search"><a href="#Algorithmic-Architecture-Search" class="headerlink" title="Algorithmic Architecture Search"></a>Algorithmic Architecture Search</h3><p>另有一部分研究在考虑放弃手工架构设计，求自动学习网络结构，该领域的许多早期工作是在神经进化领域进行的，该领域建立了用进化方法搜索网络拓扑的方法，尽管经常需要大量的计算，进化搜索已经取得了显著的成功，包括为序列模型找到良好的记忆细胞和学习用于大规模图像分类的复杂体系结构，为了减少这些方法的计算负担，学术界提出了有效的替代方法，Lamarckian inheritance和可微体系结构搜索，SE-block可以作为这些搜索结构的子模块，并且在工作中取得较高的效率</p><h3 id="Attention-and-gating-mechanisms"><a href="#Attention-and-gating-mechanisms" class="headerlink" title="Attention and gating mechanisms"></a>Attention and gating mechanisms</h3><p>注意力机制就是将可用计算资源的分配偏向于信号中信息最丰富的部分，注意力机制已经在序列学习，图片定位和图像理解等task中展现了其效用</p><p>文章提出的SE块包含一个轻量级的门机制，该机制主要通过高效地对通道关系建模来增强网络的表征能力</p><h2 id="SQUEEZE-AND-EXCITATION-BLOCKS"><a href="#SQUEEZE-AND-EXCITATION-BLOCKS" class="headerlink" title="SQUEEZE-AND-EXCITATION BLOCKS"></a>SQUEEZE-AND-EXCITATION BLOCKS</h2><p>SE-block是一个计算单元，可以建立在将$X \in R^{H’\times W’\times C’}$转化为$U \in R^{H \times W\times C}$的转换函数$F_{tr}$的基础上，我们用$V = [v_1, v_2,\dots v_C]$来表示滤波核集，那么有$U = [u_1, u_2,\dots u_C]$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-2.png"></p><p>这里的*代表卷积，$u_c \in R^{H\times W}$</p><p>由于输出是通过所有通道的总和产生的，因此通道依赖被隐式地嵌入到$v_c$中，但是与过滤器捕获的局部空间相关性相纠缠，由卷积建模的通道关系本质上是隐式的和局部的，作者希望通过明确地建模通道相互依赖关系来增强卷积特征的学习，这样网络就能够提高其对信息特征的敏感性，这些信息特征可以被后续转换利用，因此，作者希望为它提供获取全局信息的途径，并在它们被馈入下一个转换之前，分两个步骤squeeze 和excitation来重新校准</p><h3 id="Squeeze-Global-Information-Embedding"><a href="#Squeeze-Global-Information-Embedding" class="headerlink" title="Squeeze: Global Information Embedding"></a>Squeeze: Global Information Embedding</h3><p>为了利用通道相关性，文章首先考虑输出特征中每个通道的信号，每个学习滤波器都有一个局部感受野，因此变换输出U的每个单元都不能利用该区域之外的上下文信息</p><p>为了解决这个问题，作者将全局空间信息压缩(squeeze)到一个通道描述符中，这是通过全局池化来生成通道信息来实现的</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-3.png"></p><h3 id="Excitation-Adaptive-Recalibration"><a href="#Excitation-Adaptive-Recalibration" class="headerlink" title="Excitation: Adaptive Recalibration"></a>Excitation: Adaptive Recalibration</h3><p>信息压缩之后的操作则是要完全捕捉通道间的依赖关系，为了完成这个任务，这个函数需要具有两个特点：一是灵活(它必须能够学习通道之间的非线性相互作用)，二是能够学习一种非互斥的关系，因为要允许多通道被强调(而不是强制一次性激活(enforcing a one-hot activation))，作者通过一个简单的门控机制和sigmoid函数来实现</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-4.png"></p><p>$\delta$表示relu函数，$\sigma$表示sigmoid函数，$W_1 \in R^{\frac{C}{r}\times C}$，$W_2 \in R^{C\times \frac{C}{r}}$</p><p>用第一个FC层将$C$个通道压缩为$\frac{C}{r}$个通道来降低计算量，通过relu函数之后，再通过第二个FC层恢复到$C$个通道，然后用sigmoid函数计算</p><p>最后SE-block的输出为(也就是作者前文所说的Reweight)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-5.png"></p><p>$F_{scale}$即权重(Excitation的输出)和通道特征相乘的操作</p><h3 id="Instantiations"><a href="#Instantiations" class="headerlink" title="Instantiations"></a>Instantiations</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-6.png"></p><p>以上是SE-block插入到Inception结构和含有skip-connections的模块</p><p>两个FC层中间夹一个relu的优点是</p><ol><li>具有更多的非线性，可以更好地拟合通道间复杂的相关性</li><li>极大地减少了参数量和计算量</li></ol><p>Resnet需要在Addition前对分支上Residual的特征进行了特征重标定，如果对Addition后主支上的特征进行重标定，由于在主干上存在0~1的scale操作，在网络较深BP优化时就会在靠近输入层容易出现梯度弥散的情况，导致模型难以优化</p><p>目前大多数的主流网络都是由这两种网络叠加构造的，因此SE-block可以比较容易地嵌入</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>训练过程比较，可以发现嵌入了SE模块的网络可以收敛到更低的错误率上</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-7.png"></p><p>SOTA模型的对比</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SE-8.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SEblock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, channel, reduction=<span class="number">16</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(SEblock, self).__init__()</span><br><span class="line">        <span class="comment"># 全局池化</span></span><br><span class="line">        self.avg_pool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.fc = nn.Sequential( </span><br><span class="line">            <span class="comment"># 压缩通道</span></span><br><span class="line">            nn.Linear(channel, channel // reduction, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            <span class="comment"># 恢复通道</span></span><br><span class="line">            nn.Linear(channel // reduction, channel, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        b, c, _, _ = x.size() <span class="comment"># batch和channel不变</span></span><br><span class="line">        y = self.avg_pool(x).view(b, c) <span class="comment"># Sequeeze</span></span><br><span class="line">        y = self.fc(y).view(b, c, <span class="number">1</span>, <span class="number">1</span>) <span class="comment"># Excitation</span></span><br><span class="line">        <span class="keyword">return</span> x * y.expand_as(x) <span class="comment"># Reweight</span></span><br></pre></td></tr></table></figure><p><code>inplace = true</code>是覆盖运算(比如运算过程中是x=x+1，而不是y=x+1，x=y)，这样可以节省运算内存</p>]]></content>
      
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> attention </tag>
            
            <tag> CVPR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUTD注意力机制</title>
      <link href="2020/07/15/BUTD/"/>
      <url>2020/07/15/BUTD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1707.07998">Paper Download Address</a></p><p>在图像字幕和VQA中使用的大多数传统视觉注意机制都是自顶而下的，这些机制通常被训练成有选择地关注CNN的一个或多个层的输出，然而这种方法很少确定图像的关注区域</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-1.png"></p><p>传统的CNN网络在引入注意力机制的时候，图像区域会分成大小均一的网格(左图)，为了生成更像人类的字幕和问题答案，要将注意力自然地放在物体和其他突出的图像区域上，因此文章中提出的注意力机制是对象层面的(右图)</p><p>文章提出了一种结合自顶向下和自底向上的注意力机制，自底向上采用Faster R-CNN模型处理显著图像区域，每个区域由一个池化卷积特征向量表示，自顶向下采用task-specific来预测注意力区域，将其特征作为所有区域的图像特征的权重</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>在VQA和图像字幕领域产生了大量基于注意力机制的深度神经网络，这些模型可以被归类为自顶向下的方法，注意力机制被应用于CNN的一个或多个层的输出。然而，确定图像区域的最佳数目总是需要在不同细节层次之间进行权衡，此外，与图像内容相关的区域的任意定位可能会导致检测到与区域不一致的物体，且将同一物体相关的视觉概念结合起来会变得更加困难</p><p>相对而来之前的研究很少考虑到将注意力集中到图像中的突出区域，注意到有这样两篇文献，[1]中使用选择性搜索来识别图像的显著区域，用分类器对显著区域进行过滤，然后对显著区域进行大小调整和CNN编码，并集合注意力输入到图像字幕模型中；注意力区域字幕模型[2]使用edge boxes或spatial transformer networks生成图像特征，使用基于三个双线性两两交互的注意力模型处理图像特征</p><p>[1] J. Jin, K. Fu, R. Cui, F. Sha, and C. Zhang. Aligning where to see and what to tell: image caption with regionbased attention and scene factorization. arXiv preprint arXiv:1506.06272, 2015.</p><p>[2] M. Pedersoli, T. Lucas, C. Schmid, and J. Verbeek. Areas of attention for image captioning. In ICCV, 2017.</p><h2 id="文章工作"><a href="#文章工作" class="headerlink" title="文章工作"></a>文章工作</h2><h3 id="BottomUp-Attention-Model"><a href="#BottomUp-Attention-Model" class="headerlink" title="BottomUp Attention Model"></a>BottomUp Attention Model</h3><p>在研究中，用bounding boxes来定义空间区域，用Faster R-CNN来实现自底向上注意力。Faster R-CNN是一个对象检测模型，用于识别属于特定类的对象实例，并使用边框对其进行定位</p><p>Faster R-CNN对对象的检测可以分为两个阶段，第一个阶段被称为区域候选网络(Region Proposal Network，RPN)，用于预测目标区域，第二个阶段用region of interest (RoI)池化对每个候选区域提取一个小的feature map，这些feature map组合在一起，作为CNN最后一层的输入，最终输出一个基于类标签的softmax分布</p><p>文章中采用嵌入了ResNet-101的Faster R-CNN，原先的Faster R-CNN的多任务loss函数包含四个部分，文章中保留了这些部分，并添加一个额外的multi-class loss来训练属性预测器</p><p>以下是BottomUp模型输出的一个例子</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-2.png"></p><h3 id="Captioning-Model"><a href="#Captioning-Model" class="headerlink" title="Captioning Model"></a>Captioning Model</h3><p>给定一组图像特征V，文章中提出的字幕模型使用一种自上而下的”软”注意机制，在字幕生成过程中使用现有的部分输出序列作为上下文，对每个特征添加权重</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-3.png"></p><p>模型由两个LSTM构成</p><h4 id="Top-Down-Attention-LSTM"><a href="#Top-Down-Attention-LSTM" class="headerlink" title="Top-Down Attention LSTM"></a>Top-Down Attention LSTM</h4><p>输入：Language LSTM的上一步输出+平均池化后的BottomUp Attention Model输出的特征集+word embedding和one-hot编码的乘积</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-4.png"></p><h4 id="Language-LSTM"><a href="#Language-LSTM" class="headerlink" title="Language LSTM"></a>Language LSTM</h4><p>输入：经过注意力处理的图像特征+Attention LSTM的上一步输出</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-5.png"></p><p>最后输出为每个单词的概率，整个句子的概率是单个单词概率的连乘</p><p>模型要求最小化交叉熵损失</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-6.png"></p><h3 id="VQA-Model"><a href="#VQA-Model" class="headerlink" title="VQA Model"></a>VQA Model</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-7.png"></p><p>作者采用了tanh激活函数，用GRU提取问题特征，根据GRU的输出对图像特征生成非标准化注意力权重，然后计算标准化注意力权重和注意力图像特征</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>SOTA比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-8.png"></p><p>图像字幕</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-9.png"></p><p>VQA</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-10.png"></p><p>更多图像字幕的示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-11.png"></p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-12.png"></p><p>成功的VQA示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-13.png"></p><p>失败的VQA示例</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/BUTD-14.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2018 </tag>
            
            <tag> attention </tag>
            
            <tag> image captioning </tag>
            
            <tag> CVPR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VC R-CNN [将常识引入特征]</title>
      <link href="2020/07/14/VCRCNN/"/>
      <url>2020/07/14/VCRCNN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2002.12204">Paper Download Address</a></p><p>现今的计算机视觉系统擅于告诉我们”什么”，”哪里”，但并不擅长告诉我们”为什么”，这个”为什么”指的就是视觉原因，缺乏常识很容易导致机器学习中的认知误差，比如和leg区域相比，有更多的person区域和ski单词一同出现，那么视觉注意力会更多地放在人身上，但如果我们拥有”常识性”的特征，看到ski的时候我们就会把注意力集中到脚上</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-1.png"></p><p>常识并不总是包含在语言中的(因为有reporting bias)，比如我们会看到”人在路上走”，但应该很少见到”人用脚走路”。NLP中词X可以通过预测上下文中的Y来学习，但是这种做法很难迁移到图像中，因为图像中对象同现的显式原因无法被观察到，那么导致X和Y同现的真正常识会被observational bias混淆，比如如果键盘和鼠标总是被观察到在桌子上，那么得到的常识可能是键盘和鼠标是桌子的一部分而非电脑</p><p>文章利用MS-COCO数据集中的标注信息，计算Association P(Y|X)和Intervention P(Y|do(X))之间的区别，这里可以简单地理解为1.从别的图片”bollow”一个对象Z；2.将这个Z”put”在X和Y的周围；3.看看在Z的影响下X是否还会导致Y的出现，这里”bollow”和”put”就是干预的核心，这里的Z是干预的结果，不依赖于X和Y，通过这种方法，来自背景的bias会减轻</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-2.png"></p><p>文章在R-CNN的基础上提出了VC R-CNN框架，对do-operation提出了一种新算法，VC R-CNN框架如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-3.png"></p><p>而学习到的VC Feature就作为了干预武器的化身</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="Multimodal-Feature-Learning"><a href="#Multimodal-Feature-Learning" class="headerlink" title="Multimodal Feature Learning"></a>Multimodal Feature Learning</h3><p>随着最近NLP中预训练语言模型(pre-training language models, LM)的成功，研究者开始寻求从大的、未标记的多模态数据中进行弱监督学习来编码视觉-语义知识。然而，所有这些方法都存在语言的报告偏差(reporting bias)，以及下游微调的巨大记忆成本，而VC R-CNN是只基于图片的无监督学习，且能和原先的表征串联</p><h3 id="Un-Self-supervised-Visual-Feature-Learning"><a href="#Un-Self-supervised-Visual-Feature-Learning" class="headerlink" title="Un-/Self-supervised Visual Feature Learning"></a>Un-/Self-supervised Visual Feature Learning</h3><p>这类研究通过一个精心设计的代理任务(proxy task)来学习视觉特征，比如去噪自动编码器，上下文和旋转预测和数据扩充，上下文预测是通过相关性来学习的，而图像的旋转和增强可以看作是采用随机对照试验，这些都是主动的和非观察的(non-observational)，而VC R-CNN是通过因果推论，是被动和非观察的</p><h3 id="Visual-Common-Sense"><a href="#Visual-Common-Sense" class="headerlink" title="Visual Common Sense"></a>Visual Common Sense</h3><p>之前的研究分为两类：1.使用常识知识从图像中学习；2.从视频中学习行为。然而，前者将常识局限于人类注释的知识，而后者本质上又是从相关性中学习</p><h3 id="Causality-in-Vision"><a href="#Causality-in-Vision" class="headerlink" title="Causality in Vision"></a>Causality in Vision</h3><p>和其它工作不同的是，VC R-CNN提供了一个通用的特征提取器</p><h2 id="Sense-making-by-Intervention"><a href="#Sense-making-by-Intervention" class="headerlink" title="Sense-making by Intervention"></a>Sense-making by Intervention</h2><h3 id="Causal-Intervention"><a href="#Causal-Intervention" class="headerlink" title="Causal Intervention"></a>Causal Intervention</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-4.png"></p><p>如上左图所示，在现实世界中，很多情况下X和Y的发生是存在混杂因子(confounders)Z的，如果只从P(Y|X)中学习会导致虚假的相关性，也可以从贝叶斯公式来说明这一点</p><p>$P(Y|X)=\sum_zP(Y|X,z)P(z|X)$</p><p>confounder Z通过$P(z|X)$造成observational bias</p><p>do操作的本质就是去切断Z和X之间的联系</p><p>$P(Y|(do(X))=\sum_zP(Y|X,z)P(z)$</p><p>通过干预$P(Y|do(X))$作为特征学习目标，可以在”common”和”sense-making”之间进行调整，从而缓解observational bias</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-5.png"></p><p>图a中是分别用$P(Y|X)$和$P(Y|do(x))$统计的特征，可以发现相比于$P(Y|X)$中，window和leg被放在一起的情况(因为人在街道上走的图片中通常有带窗的建筑)，$P(Y|do(x))$中两者显然被分开了，而图b中可以看到在VC R-CNN特征图中，ski明显离leg和snow更近</p><h3 id="The-Proposed-Implementation"><a href="#The-Proposed-Implementation" class="headerlink" title="The Proposed Implementation"></a>The Proposed Implementation</h3><p>因为现实中的confounder是很难被收集全的，文章建立了一个confounder词典，将RoI特征在每个类别上取平均，特征是通过Faster R-CNN得到的</p><p>干预实现如下：</p><p>$P(Y|do(X))=E_z[Softmax(f_y(x,z))]$</p><p>考虑到$E_z$成本高昂，用Normalized Weighted Geometric Mean (NWGM)来近似</p><p>由于混淆因子作为类别平均特征的因果关系尚未验证，即Z可能包含碰撞器(或v型结构)干预时，会导致虚假的相关性。为此，文章应用NCC从z移除可能的碰撞器。给定x和z, NCC(x to z)输出从x到z的相对因果强度，然后丢弃碰撞器因果强度大于阈值的训练样本</p><h2 id="VC-R-CNN"><a href="#VC-R-CNN" class="headerlink" title="VC R-CNN"></a>VC R-CNN</h2><p>VC R-CNN以图像为输入，从CNN主干(如ResNet101)中生成feature map。与faster R-CNN不同，VC R-CNN丢弃了Region Proposal Network(RPN)，直接利用ground-truth bounding boxes提取RoIAlign层的目标层表示。最后每两个RoI特征x，y最终成为两个预测因子分支：使用全连接层来估计每个对象类的Self Predictor，以及利用do-calculus来预测context label的Context Predictor</p><p>对于RoI X来说，损失函数为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-6.png"></p><p>p是Self Predictor输出的N个类别的离散概率分布，$x^c$是RoI X的ground-truth class，$y_i^c$是ground-truth label</p><p>$L_{self}(p,x^c)=-log(p[x^c])$</p><p>$L_{cxt}(p_i,y_i^c)=-log(p_i[y_i^c])$</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-7.png"></p><p>Only VC是单纯的VC feature，+Det是只有Self Detection，+Cor是只有context labels，无干预，+VC是文章中的完整的干预过程得到的特征连接上原始特征</p><p>对SOTA model的影响</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-8.png"></p><p>效果展示(右侧是VC feature)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VCRCNN-9.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> 2020 </tag>
            
            <tag> debias </tag>
            
            <tag> feature extraction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQulNTing [子问题一致性]</title>
      <link href="2020/07/09/SQuINTing/"/>
      <url>2020/07/09/SQuINTing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2001.06927">Paper Download Address</a></p><p>VQA问题要求模型在多个抽象层面进行推理，比如要回答问题”这个香蕉熟到能吃的地步了么”，VQA model需要检测香蕉并且提取它的相关属性比如大小和颜色。抽象概念是复杂，多细节层次的。</p><p>文章中将问题分为感知和推理两类，感知问题只要求对对象确认存在，查询对象的物理属性和判断对象之间的空间关系，比如”图中香蕉是什么颜色的”或者”这个人的左边的是什么”，推理问题则需要结合视觉感知，逻辑和先验知识来完成，比如”这个香蕉熟到能吃的地步了么”</p><p>将问题划分为感知和推理可以更好地评估模型的视觉感知和高级推理能力，作者认为，将感知问题作为推理问题的子任务是有帮助的。通过阐述这样的子任务，可以检测模型是通过合理推断还是通过数据集中的bias和捷径来得到答案。就比如，我们需要留意一下模型的推理能力当其对于香蕉的颜色答案为黄，但对于香蕉能否食用答案是否的时候。高水平推理任务与低水平感知任务之间的不一致表明model还没有有效地学习如何回答推理问题。这些子问题可以用来对任何VQA模型评估而不仅是那些被用来提供理由的模型</p><p>随着推理问题的复杂化，目前使用的方法实现良好的覆盖和泛化需要大量的数据，作者采用一种层次分解策略，在这种策略中，用一组合适的问题来识别和连接推理问题。这种方法可以通过组合建模来提高效率，也可以提高回答推理问题的模型的一致性。感知任务为推理问题提供了语言基础，光有视觉基础是不够的，比如图中强调香蕉对问题的重要性并没有告诉是如何重要的(颜色比形状和大小更重要)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-1.png"></p><p>作者从VQA数据集中分割出只包含推理问题的子集，然后提出了VQA-introspect数据集，一个由238K个相关感知子问题组成的新数据集，这些子问题包含了回答原始问题所需的子问题。作者用这个模型对SOTA model进行了细粒度评估(fine-grained evaluation)，这些模型在回答感知和推理任务方面具有相似的准确性，但存在一致性问题，在28.14%的样本中，他们回答对了推理问题，却答错了相应的子认知问题，这种情况突出了一致性问题以及模型可能通过学习常见答案和bias来学习回答推理问题的风险</p><p>最后作者介绍了一种通用的建模方法SQuINT，其灵感来自于在人类中观察到的组合学习范式。SQuINT将VQA-introspect注释和一个新的损失函数结合到学习中，该函数鼓励对子问题重要的图像区域在回答主要推理问题中发挥作用。经验评估表明，该方法产生的模型具有更好的一致性，相关感知任务的准确性也没有大的损失。并且SQuINT使得模型对推理问题产生了更好的注意力图，使得模型更可靠</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>VQA model可能利用语言和数据集bias获得很好的效果，比如对香蕉的颜色直接回答黄色。这种情况促使研究者采用其它评估方式，[1]检查了model是否理解问题，[2][3]检查了模型是否在逻辑上保持一致性，文章对需要推理能力的问题提出了一种新的评估，检查模型回答高级推理问题和回答相应的感知子问题之间的一致性</p><p>[1] Meet Shah, Xinlei Chen, Marcus Rohrbach, and Devi Parikh. Cycle-consistency for robust visual question answering. In IEEE Conference on Computer Vision and Pattern Recognition, 2019.</p><p>[2] Marco Tulio Ribeiro, Carlos Guestrin, and Sameer Singh. Are red roses red? evaluating consistency of questionanswering models. In Association for Computational Linguistics. Association for Computational Linguistics, 2019.</p><p>[3] Arijit Ray, Karan Sikka, Ajay Divakaran, Stefan Lee, and Giedrius Burachas. Sunny and dark outside?! improving answer consistency in vqa through entailed question generation. Conference on Empirical Methods in Natural Language Processing, 2019.</p><p>关于VQA数据集的工作，一些数据集在图片上标注了问题相关的重要的注意力区域，文章的工作是这些工作的补充，提供了语言事实而非视觉事实，同时，评估了感知能力之间的联系，以及它们是如何组合来回答推理问题的</p><h2 id="Reasoning-VQA-and-VQA-introspect"><a href="#Reasoning-VQA-and-VQA-introspect" class="headerlink" title="Reasoning-VQA and VQA-introspect"></a>Reasoning-VQA and VQA-introspect</h2><p>这个章节分两个部分，第一部分分析了将问题类型划分成认知和推理两类的必要性，并且阐述了构建推理split的方法，第二部分记录了如何构建VQA-instrospect数据集</p><h3 id="Perception-vs-Reasoning"><a href="#Perception-vs-Reasoning" class="headerlink" title="Perception vs. Reasoning"></a>Perception vs. Reasoning</h3><p>一种常见的更细粒度的评估方法是把答案类型分为yes/no和非yes/no或是根据问题的前几个单词来划分(what color，how many)，虽然有用，但是这样的切片是粗糙的，并且不能在不同抽象层次上评估模型的能力，比如”这是香蕉嘛”和”这是垃圾食品嘛”，它们都是非yes/no问题并且开头单词相同。虽说它们都需要目标识别，但是后者显然需要更多的推理能力，需要结合垃圾食品的先验知识</p><p>并不是说推理问题就比认知问题要难，只是推理问题除了视觉感知外还需要一些别的技能，比如逻辑，先验知识。举个例子，视觉感知问题”图中小立方体的右边有几个黄色的圆球”就比推理问题”图中香蕉熟到能吃了么”要难得多</p><p>撇开难度不谈，对推理或是认知进行分类能够对模型进行详细的基于能力的模型评估，并提高学习</p><p>以下是作者对两类问题更正式的划分</p><ol><li>Perception：检测和识别目标，物理性质，空间关系，文字/图标识别，计数，不超过单跳推理，不超出常识和视觉图像内容，特别注意和往常的paper不同，文章中将空间关系作为认知而非推理，是为了将视觉理解与其他类型的推理和知识分开</li><li>Reasoning：推理任务的定义非常简单：非认知任务，需要认知任务和先验知识结合</li></ol><p>作者对VQA数据集中的感知问题的分析发现，大多数感知问题具有不同的模式，可以使用高精度的基于正则的规则识别，通过这样的规则，最后选出了VQA数据集中18%可能是推理任务的数据。为了验证这个规则以及推理任务，让AMT的worker对数据集进行标定，大概有89.25%的正确率</p><h3 id="VQA-introspect-data"><a href="#VQA-introspect-data" class="headerlink" title="VQA-introspect data"></a>VQA-introspect data</h3><p>考虑到区分认知和推理问题以及为推理问题提供子认知问题的复杂性，研究团队首先对AMT的worker进行培训和筛选，然后利用他们来产生高质量的子问题</p><h4 id="Worker-Training"><a href="#Worker-Training" class="headerlink" title="Worker Training"></a>Worker Training</h4><p>首先手动标注了VQA数据集中100个样本作为认知问题，100个样本作为图例问题作为例子。首先给出定义和每个定义的几个例子，单独都给出了解释。然后向crowdworkers展示QA对让他们对其分类。最后，要求workers添加所有感知问题和相应的答案以回答主要问题，如果他们对6个判定问题至少能答对5个，则这个worker就合格了</p><p>随后，对通过第一轮筛选的crowdworkers进行了进一步的试点实验，根据他们的子问题是否是基于图像的感知问题，是否足以回答主要问题，手工评估他们的子问题的质量，在通过第一次资格考试的540名工人中，144人通过手工评估被选为高质量工人，最终有资格完成论文的主要任务</p><h4 id="Main-task"><a href="#Main-task" class="headerlink" title="Main task"></a>Main task</h4><p>在主要数据收集中，所有被regex规则识别为推理的VQA问题和被识别为感知的问题的随机子集被工人进一步判断，研究团队通过进一步过滤掉worker对答案有高度分歧的问题来消除模糊的问题</p><p>然后每个QI对的子问题由3个独立的worker生成，去重之后每个问题有平均3.1个子问题，结果如下列图</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-2.png"><br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-3.png"><br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-4.png"></p><h3 id="Dataset-Quality-Validation"><a href="#Dataset-Quality-Validation" class="headerlink" title="Dataset Quality Validation"></a>Dataset Quality Validation</h3><p>为了确认数据集中的子问题都是认知问题，研究团队让通过了质量测试而又未参与子问题生成的workers对这些子问题进行判断，判断结果是87.8%在三个workers中得到了至少两个人的认可</p><h2 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h2><p>数据分布如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-5.png"></p><p>细节描述详见论文</p><h2 id="Fine-grained-evaluation-of-VQA-Reasoning"><a href="#Fine-grained-evaluation-of-VQA-Reasoning" class="headerlink" title="Fine grained evaluation of VQA Reasoning"></a>Fine grained evaluation of VQA Reasoning</h2><p>通过检查这些问题的正确性与相关问题的正确性是否一致，VQA-introspect能够更详细地评估SOTA模型在推理问题上的性能</p><p>认知失败(不能正确回答子问题)可能是视觉部分的问题，也有可能是grounding problem：model知道大多数情况下香蕉是黄的，然后用这个信息去回答是否成熟的问题，同时，可能不知道黄色跟这个问题有什么关系又或是无法理解子任务的问题。意识到这一点，文章将评估分为四类：</p><h3 id="Q1-Both-main-amp-sub-questions-correct"><a href="#Q1-Both-main-amp-sub-questions-correct" class="headerlink" title="Q1: Both main &amp; sub-questions correct"></a>Q1: Both main &amp; sub-questions correct</h3><p>虽然不能声称由于子问题的存在，模型正确地预测了主要问题(因为香蕉大部分是黄的，就说香蕉是成熟的)，但是正确回答两个问题说明与良好的推理是一致的</p><h3 id="Q2-Main-correct-amp-sub-question-incorrect"><a href="#Q2-Main-correct-amp-sub-question-incorrect" class="headerlink" title="Q2: Main correct &amp; sub-question incorrect"></a>Q2: Main correct &amp; sub-question incorrect</h3><p>认知错误说明可能存在推理过程错误，当然也有可能model捕获了其它的感知知识，但没有被确定的子问题涵盖(香蕉是熟的因为表面上有黑点)，也可能是model建立了虚假的shortcut或是随机正确</p><h3 id="Q3-Main-incorrect-amp-sub-question-correct"><a href="#Q3-Main-incorrect-amp-sub-question-correct" class="headerlink" title="Q3: Main incorrect &amp; sub-question correct"></a>Q3: Main incorrect &amp; sub-question correct</h3><p>这里的失败清楚地表明了推理失败，因为我们验证了子问题足以回答主要问题(在这种情况下，模型知道香蕉大部分是黄色的，但仍然认为它们不够成熟，因此它没有把”黄色香蕉成熟了”联系起来)</p><h3 id="Q4-Both-main-amp-sub-question-incorrect"><a href="#Q4-Both-main-amp-sub-question-incorrect" class="headerlink" title="Q4: Both main &amp; sub-question incorrect"></a>Q4: Both main &amp; sub-question incorrect</h3><p>虽然模型可能没有推理能力来回答这一象限的问题，但感知失败可以解释不正确的预测</p><p>总结一下Q2和Q4有显然的认知错误，Q2可能存在推理错误，Q3一定存在推理错误，Q4无法判断推理是否错误</p><h2 id="Improving-learned-models-with-VQAintrospect"><a href="#Improving-learned-models-with-VQAintrospect" class="headerlink" title="Improving learned models with VQAintrospect"></a>Improving learned models with VQAintrospect</h2><p>这章介绍了VQA-introspect如何用于提升在VQA数据集中训练的模型，主要是为了解决Q2和Q3的问题</p><h3 id="Finetuning"><a href="#Finetuning" class="headerlink" title="Finetuning"></a>Finetuning</h3><p>将VQA-introspect合并到一个学习的模型中最简单的方法是对其上的模型进行微调，采用主问题和子问题的二叉熵损失函数的平均值作为损失函数</p><h3 id="SubQuestion-Importanceaware-Network-Tuning"><a href="#SubQuestion-Importanceaware-Network-Tuning" class="headerlink" title="SubQuestion Importanceaware Network Tuning"></a>SubQuestion Importanceaware Network Tuning</h3><p>Sub-Question Importance-aware Network Tuning(SQuINT)的初衷是模型在回答推理问题时，应该像在回答相关问题时一样关注图像中的相同区域，SQuINT通过学习如何关注感兴趣的子问题区域，并对它们进行推理以回答主要问题来做到这一点</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-6.png"></p><h4 id="Attention-loss"><a href="#Attention-loss" class="headerlink" title="Attention loss"></a>Attention loss</h4><p>目前表现良好的基于注意力的模型在被问及简单的感知问题时，通常擅长于图像中的视觉区域定位(grounding)，因为它们是在包含大量感知问题的VQA数据集上训练的。为了使模型在回答主要问题时查看相关的子问题区域，文章在空间和边界框注意力权重上应用均方差(MSE)损失</p><h4 id="Cross-Entropy-loss"><a href="#Cross-Entropy-loss" class="headerlink" title="Cross Entropy loss"></a>Cross Entropy loss</h4><p>当注意力loss促使模型在遇到复杂的推理问题时去寻找正确的区域时，需要一种loss来帮助模型学会在给出正确的区域时进行推理，因此，作者将常规二元交叉熵损失应用于推理问题的预测答案之上，此外，还使用了预测答案和GT回答的子问题的二叉熵损失</p><h4 id="Total-SQuINT-loss"><a href="#Total-SQuINT-loss" class="headerlink" title="Total SQuINT loss"></a>Total SQuINT loss</h4><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-7.png"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>消融实验<br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-8.png"></p><p>实验结果展示<br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/SQulNTing-9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> 2020 </tag>
            
            <tag> dataset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GQA-OOD [低频样本处理]</title>
      <link href="2020/07/08/GQAOOD/"/>
      <url>2020/07/08/GQAOOD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2006.05121">Paper Download Address</a></p><p>玫瑰是红色的，紫罗兰是蓝色的，但是，VQA系统理应期待他们是这样的么？</p><p>目前多数的VQA数据集仍然非常的不平衡，大量常用的表述比如红玫瑰，与上下文无关的表述比如城市中的斑马，这些表述导致模型过分依赖于biases，缺乏一般化的能力。尽管对这个问题有普遍的共识，对误差分布的系统性评估仍然非常稀缺。整体正确率依然是主流，甚至唯一的评判依据，虽然这是不合理的。</p><p>现在对于模型的评判有这些问题：误差分布是什么样的？正确的预测是因为推理还是因为偏见？在低频样本和高频样本上的正确率如何？如何在分布之外(OOD)验证模型？</p><p>文章提出了一种新的标准，这个标准包含</p><ol><li>一个重新组合的GQA数据集，在验证集和测试集中引入分布变换</li><li>一系列评估方法</li><li>新的评价图来说明VQA在不同操作点上的推理行为</li></ol><p>选择GQA数据集是因为其问题组结构能够捕捉biases，可以以此来选择具有较强偏见的组并创建分布转换，为每一个问题添加约束</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GQAOOD-1.png"></p><p>作者用这个标准做了大量的实验发现许多SOTA VQA模型都不能胜任解决不常见问题的工作，同时在VQA降低偏见的方法上得到同样的结论。</p><p>仅在高频样本上获得的高正确率机械性地提高了整体的正确率，掩盖了当下VQA model的真实行为</p><p>文章的贡献如下</p><ol><li>公开经过重组和精校(fine-grained)的GQA数据集，提出一系列评估方法，准确评估VQA模型的推理行为，对VQA模型的泛化能力(generalisation behavior)特征化和可视化</li><li>相比于其它标准，数据集在验证集和测试集上分布的变化使得其能在OOD条件下测试</li><li>评估了最近几个VQA模型，发现其在OOD情况下难以泛化；测试了一些SOTA biases降低方法，说明在解决VQA中的biases问题还有改进的余地</li></ol><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="VQA数据集"><a href="#VQA数据集" class="headerlink" title="VQA数据集"></a>VQA数据集</h3><p>VQA1数据集是最早的大规模数据集，因为其包含大量biases，因此提出了VQA2。CLEVER数据集是一种合成数据集，优点是详细和结构化的注释，后来有人将CLEVER对应到真实世界得到GQA数据集</p><h3 id="减少bias依赖"><a href="#减少bias依赖" class="headerlink" title="减少bias依赖"></a>减少bias依赖</h3><p>尽管设计了复杂的结构，VQA模型依然缺乏泛化能力。VQA问答问题有时候不需要视觉部分，有时即使使用了视觉部分，但是使用的却不是相关区域</p><p>[1]用对抗的方式采用question-only模型和VQA模型对抗来解决bias问题；Rubi系统[2]在训练中除了使用基本模型外，还使用了一个question-only分支，来消除bias的影响；[3]使用训练集的问题类型统计数据来规范化模型预测；[4][5]则是让VQA系统将注意力集中在最重要的视觉区域，这些工作在未知分布上(unseen distributions)表现良好，但会略微降低标准测试的性能，标准测试往往对依赖biases的模型更有利</p><p>[1] Sainandan Ramakrishnan, Aishwarya Agrawal, and Stefan Lee. Overcoming language priors in visual question answering with adversarial regularization. In Advances in Neural Information Processing Systems, pages 1541– 1551, 2018.</p><p>[2] Remi Cadene, Corentin Dancette, Matthieu Cord, Devi Parikh, et al. Rubi: Reducing unimodal biases for visual question answering. In Advances in Neural Information Processing Systems, pages 839–850, 2019.</p><p>[3] Christopher Clark, Mark Yatskar, and Luke Zettlemoyer. Don’t take the easy way out: Ensemble based methods for avoiding known dataset biases. In Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP), pages<br>4060–4073, 2019.</p><p>[4] Jialin Wu and Raymond Mooney. Self-critical reasoning for robust visual question answering. In Advances in Neural Information Processing Systems, pages 8601–8611, 2019</p><p>[5] Ramprasaath R Selvaraju, Stefan Lee, Yilin Shen, Hongxia Jin, Shalini Ghosh, Larry Heck, Dhruv Batra, and Devi Parikh. Taking a hint: Leveraging explanations to make vision and language models more grounded. In Proceedings of the IEEE International Conference on Computer Vision, pages 2591–2600, 2019.</p><h3 id="重塑VQA评估标准"><a href="#重塑VQA评估标准" class="headerlink" title="重塑VQA评估标准"></a>重塑VQA评估标准</h3><p>VQA的模型日益复杂，且bias问题严重，亟需新的VQA评估方法。早期的研究采用基于词汇库的软评价方法，虽然被硬分类评价替代，带来了更多bias，但是在训练中更易使用。GQA的作者根据他们的数据集提出了一系列新的评估方法一致性(consistency)，合理性(plausibilitiy)，有效性(validity)，分布(distribution)，这些方法更好地评估了VQA模型的能力，但是并没有评估OOD环境下的泛化能力。[6]提出了GQA分割，重组了训练和验证集以清楚地评估模型在视觉场景的内容和问题的语言结构上的概括程度；[7]提出了CLOSURE标准，SOTA models(包含了为了泛化能力而设计的模型)在这些条件下没能成功泛化；[8]重组了VQA2，提出VQA-CP2，训练集分布和测试集分布不同</p><p>[6] Drew Hudson and Christopher D Manning. Learning by abstraction: The neural state machine. In Advances in Neural Information Processing Systems, pages 5901–5914, 2019.</p><p>[7] Dzmitry Bahdanau, AI Element, Harm de Vries, Shikhar Murty, Philippe Beaudoin, Yoshua Bengio, and Aaron Courville. Closure: Assessing systematic generalization of clevr models.</p><p>[8]Aishwarya Agrawal, Dhruv Batra, Devi Parikh, and Aniruddha Kembhavi. Don’t just assume; look and answer: Overcoming priors for visual question answering. In IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018.</p><h2 id="GQA-OOD"><a href="#GQA-OOD" class="headerlink" title="GQA-OOD"></a>GQA-OOD</h2><p>作者将新提出的数据集命名为GQA-OOD，OOD样本是低频事件的意思，OOD样本涵盖了训练集中的内容。比如说，提到在图片中出现玫瑰，一般回答是红色的，而GQA-OOD中更多的测试样本，答案则是蓝色之类的</p><p>GQA-OOD评估标准由数据集和新的评估方法构成，GQA-OOD和GQA的训练集是相同的，验证集和测试集则进行了分布转化</p><h3 id="Question-groups"><a href="#Question-groups" class="headerlink" title="Question groups"></a>Question groups</h3><p>为了构造分布转换，作者采用了GQA注释中的local groups，它们精确定义了问题的类型”what color”，”where is”，同时还有问题相关的概念，比如”violet”，”zebra”。作者使用了平衡版本的GQA，这个版本对问题分布进行了平滑处理，使得答案分布更加均匀，但是数据集依然是不平衡的，因为现实世界的红色玫瑰本就居多</p><h3 id="Measuring-group-imbalance"><a href="#Measuring-group-imbalance" class="headerlink" title="Measuring group imbalance"></a>Measuring group imbalance</h3><p>作者提取最不平衡的问题组的子集，因为文章感兴趣的是在特定的背景下评估预测误差，其中分布的变化是有意义的，这里的平衡性是利用信息熵来评估的</p><h3 id="OOD-setting-and-metrics"><a href="#OOD-setting-and-metrics" class="headerlink" title="OOD setting and metrics"></a>OOD setting and metrics</h3><p>作者通过根据问题的频率选择答案的子集来引入分布变换，根据评估的类别引入了三种不同的评估指标：</p><ol><li>Acc-tail，OOD样本的准确率</li><li>Acc-head，每个local group中高频样本的准确率</li><li>ACC-all，整体准确率</li></ol><h3 id="Difference-with-VQA-CP2"><a href="#Difference-with-VQA-CP2" class="headerlink" title="Difference with VQA-CP2"></a>Difference with VQA-CP2</h3><p>VQA-CP2是根据问题的首单词和相同的真实答案来分组的，这种分布转变是通过避免分组之间的重复类型而产生的，而GQA-OOD允许对VQA模型的泛化行为进行细粒度分析</p><p>VQA-CP2只包含训练集和测试集，缺乏对超参数的验证，因此，大多数技术在测试集上优化它们的超参数，这会导致overfit测试集，而GQA-OOD包含验证集</p><p>GQA-OOD要求是在原始的GQA train split上训练，这要求模型在训练集存在bias的情况下减少测试结果中的bias，有利于通过方法而不是清理训练数据来减少bias</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GQAOOD-2.png"></p><p>(1) Models fail on rare question-answer pairs</p><p>两个盲模型Question Prior和LSTM在低频样本和高频样本上的表现有较大的差距($\Delta$)，说明其对语言biases依赖较大，而BUTD和MCAN也相对比较大，但是MCAN表现比BUTD稍好，说明Transformer结构的表现更好一些</p><p>(2) Overall accuracy is dominated by frequent question-answer pairs</p><p>acc-all作为VQA的标准度量，并不能很好地评估模型的表现，因为其随着高频样本正确率的提升而提升</p><p>(3) Bias-reduction methods are not efficient on rare samples</p><p>用于减少bias的方法都没有增加acc-tail的得分，甚至降低acc-head的评分，说明阻止对高频样本的学习并不能提高对低频样本的学习能力</p><p>和其它数据集的比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/GQAOOD-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2020 </tag>
            
            <tag> dataset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为VQA生成原因</title>
      <link href="2020/07/07/generatingRationales/"/>
      <url>2020/07/07/generatingRationales/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2004.02032">Paper Download Address</a></p><p>想要在VQA任务中有突出的表现，model必须理解问题并找到问题相关答案的能力，有个严肃的问题是这些model在预测答案的时候到底能够理解image，question和answer到一个什么程度，它们是否只是利用了问题，图片或者答案中的biases</p><p>衡量模型对三个方面(questions, images, answers)的理解能力并不是一个主流工作，之前相关工作有对word进行微扰，检查视觉热力图等，文章希望做的是对三个方面做一个联合，同时测试模型语言和视觉模块</p><p>为了完成这一点，文章为VQA系统提出了一个novel task，不仅要理解问题(linguistic modality)，理解图片(visual modality)，同时也要为预测的答案提供理由，指出其和图片以及问题的关系</p><p>作者采用VCR(Visual Commonsense Reasoning)数据集，该数据集中包含图片，问题，对应的四个候选答案，和四个原因选项，作者用VQA系统选择答案，然后对答案生成原因，对比真实原因来评估model的综合理解能力</p><p>作者用这个方法测试了VCR领域领先的模型ViLBERT，随后将ViLBERT和语言模型GPT-2结合用end-to-end方式来预测答案和产生原因。idea就是将答案产生的原因loss反向传播到答案预测中，合理推断的注入能够提高模型的综合理解能力</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>整体工作如图所示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/generatingRationales-1.png"></p><p>过程分为两个部分：1. 计算预测答案的embedding $E_{A_p}$，2. 把$E_{A_p}$ feed到语言模块(预训练的GPT2)</p><h3 id="Predicted-Answer-Embedding"><a href="#Predicted-Answer-Embedding" class="headerlink" title="Predicted Answer Embedding"></a>Predicted Answer Embedding</h3><p>文章采用模型ViLBERT，输入图像和问题，对于每个答案选项产生embedding，之后将embedding输入到softmax</p><p>因为选取最大概率的答案embedding会导致网络不可微，所以根据它们的softmax score对四个embedding进行加权平均</p><h3 id="Generating-Rationales"><a href="#Generating-Rationales" class="headerlink" title="Generating Rationales"></a>Generating Rationales</h3><p>我们用条件语言生成的方式来产生理由，条件是之前生成的理由以及答案的embedding，求取最大对数似然，然后用VCR数据集来修正模型</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>生成原因比较</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/generatingRationales-2.png"></p><p>ViLBERT-Fr：预训练VQA+ground-truth rationale调整的GPT-2</p><p>ViLBERT-Ra：文章中的模型(计算ViLBERT答案得分和答案embedding的softmax得分的KL散度)</p><p>结果说明原因生成模块能够帮助VQA模型理解问题</p><p>结果展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/generatingRationales-3.png"></p><p>人工裁定 (两个模型的理由哪个更佳)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/generatingRationales-4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2020 </tag>
            
            <tag> rationales generation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过分解语言表征来克服VQA中的语言先验</title>
      <link href="2020/07/03/DLR/"/>
      <url>2020/07/03/DLR/</url>
      
        <content type="html"><![CDATA[<p><a href="https://jingchenchen.github.io/files/papers/2020/AAAI_Decom_VQA.pdf">Paper Download Address</a></p><p>目前多数VQA model中存在语言先验(Language Priors)问题，比如对于颜色会快速回答”white”，对于运动会快速回答”tennis”，对于”is there a”开头的问题会快速回答”yes”，这些模型并不能真正辨别问题中信息的不同之处，他们只是利用答案和询问词(interrogative words)的同现性来得到答案</p><p>尽管有些模型采用了问题注意力机制，将关键词和视觉信息结合，但是它们并没有消除interrogative words的影响，因此仍存在language prior</p><p>[1]的研究中，为了消除language piror，用多个手工设计的模块来处理问题中不同的信息，他们用一个问题分类器将问题划分为yes/no类别和非yes/no类别，用一种基于词性的概念抽取器来提取yes/no问题中的概念，以及答案聚类预测因子确定非yes/no问题的答案类型</p><p>[1] Agrawal, A.; Batra, D.; Parikh, D.; and Kembhavi, A. 2018. Dont just assume; look and answer: Overcoming priors for visual question answering. In Proceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 4971–4980.</p><p>本文是[1]工作的延伸，都是对内容发现和内容核验解耦，但是有两个方面的不同，一是用语言注意力机制对问题分解而不是基于词性的概念抽取器，二是将候选答案作为视觉部分去学习它们和问题以及图片的关联性，而[1]中预定义了不同的视觉内容，用预训练的分类器对图片的内容进行分类</p><p>在QA对中，通常包含三种信息：1.问题类型(question type)，2，相关目标(referring object)，3.期待的内容(expected concept)，期待的内容在yes/no问题中是包含在问题里的，而在非yes/no问题中被包含在答案中</p><p>文章中提出的VQA模型分为四个模块：</p><ol><li><p>语言注意力模块(The language attention module)将问题分为三个部分：type，object，concept，在学习concept representations的时候，文章采用软注意力和硬注意力结合的方式来评估interrogative words的影响</p></li><li><p>问题识别模块(The question identification module)利用type representation来界定问题的种类(yes/no或是具体问题比如color，number)</p></li><li><p>目标模块(The object referring module)采用top-down attention来注意目标相关的图片区域</p></li><li><p>视觉验证模块(The visual verification module) 计算注意力区域和concept的相关性得分来推断答案</p></li></ol><p>通过这四个模块，文章可以清晰呈现出答案预测的过程</p><p>文章的主要贡献有</p><p>(1) 学习对问题的语言表征进行分解，将语言相关concept和视觉相关concept解耦来消除language priors</p><p>(2) 采用了结合软注意力和硬注意力的语言注意力方法，在分离concept部分和type部分的同时灵敏地甄别问题中的不同信息</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="VQA"><a href="#VQA" class="headerlink" title="VQA"></a>VQA</h3><p>作者将VQA的方法分为两类：整体性的(holistic)和模块化的(modular)，整体指对于不同的QA对采用单一的模型进行求解，模块化的指先将问题划分到模块框架下，然后用对应的模块去解决</p><p>文章虽然采用模块设计，但是本质上属于holistic方法，因为对于不同的问题采用的是单一的模型。文章采用的方法是分析问题产生phrase，将其作为之后部分的input，而不是去预测模块框架</p><h3 id="Language-Priors"><a href="#Language-Priors" class="headerlink" title="Language Priors"></a>Language Priors</h3><p>为了降低Language Priors的影响，数据集上提出了VQA-CP(训练集和测试集QA分布不同)，训练方法上提出了对抗方式，用question-only model和VQA model对抗来减少biases；以及用人类注意力监督来提升视觉能力，即减少人类视觉注意图和网络得到的注意力之间的差异</p><h2 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h2><p>本文模型的整体框架如下，下面的图中(a)和(b)展示了在不同的问题类型下的方法</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-1.png"></p><h3 id="Language-Attention-Module"><a href="#Language-Attention-Module" class="headerlink" title="Language Attention Module"></a>Language Attention Module</h3><p>作者在[2]的hard attention启发下，设计了结合软注意力和硬注意力的语言注意力模块，</p><p>[2] Malinowski, M.; Doersch, C.; Santoro, A.; and Battaglia, P. 2018.Learning visual question answering by bootstrapping hard attention.<br>In Proceedings of the European Conference on Computer Vision (ECCV), 3–20.</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-2.png"></p><p>如上图所示，在语言注意力模块中，采用了三种不同的注意力，type attention，object attention和concept attention来学习三种分解出的representations</p><p>同时采用了一种问题分类判别loss来保证type attention确实是注意在interrogative words上，并且设置了一个阈值，对interrogative words进行过滤，使得其不参与object<br>representations和concept representations</p><p>$q_{type}$的计算公式为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-3.png"></p><p>其中${w_t}_{t=1}^T$是问题的T个单词，${e_t}_{t=1}^T$是单词对应的embeddings</p><p>同样还有$q_{obj}$和$q_{con}$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-4.png"></p><p>这两个attention都是hard attention，因为只有一部分单词参与计算</p><h3 id="Question-Identification-Module"><a href="#Question-Identification-Module" class="headerlink" title="Question Identification Module"></a>Question Identification Module</h3><p>得到了type representation $q_{type}$之后文章用question identification loss来标定问题的type</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-5.png"></p><p>$CE(a,b)=-alog(b)-(1-a)log(1-b)$，也就是交叉熵损失</p><p>yes/no问题的答案集显然是yes/no，对于非yes/no问题需要处理出一个答案集，处理过程需要衡量问题和候选答案的相关性，处理方法是生成一个候选答案维度的01向量mask，用KL散度对mask进行训练</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-6.png"></p><p>其中$m_q=sigmoid(s_q)$，$s_{qa}$是$q_{type}$和$a$的点积</p><h3 id="Object-Referring-Module"><a href="#Object-Referring-Module" class="headerlink" title="Object Referring Module"></a>Object Referring Module</h3><p>Object referring模块利用$q_{obj}$将注意力集中到问题相关的视觉区域，这部分主要follow[3]</p><p>[3] Anderson, P.; He, X.; Buehler, C.; Teney, D.; Johnson, M.; Gould,S.; and Zhang, L. 2018. Bottom-up and top-down attention for<br>image captioning and visual question answering. In Proceedings of IEEE Conference on Computer Vision and Pattern Recognition (CVPR).</p><h3 id="Visual-Verification-Module"><a href="#Visual-Verification-Module" class="headerlink" title="Visual Verification Module"></a>Visual Verification Module</h3><p>根据视觉注意力区域从答案集中选出正确答案，对于yes/no问题采用交叉熵损失，非yes/no问题用KL散度</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-7.png"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>SOTA</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-8.png"></p><p>阈值影响</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-9.png"></p><p>实验结果可视化展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-10.png"></p><p>消融实验</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/DLR-11.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2020 </tag>
            
            <tag> debias </tag>
            
            <tag> AAAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-VQA [反事实]</title>
      <link href="2020/07/02/CSSVQA/"/>
      <url>2020/07/02/CSSVQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2003.06576">Paper Download Address</a></p><p>由于数据集的问题，目前很多VQA模型仍然过于依赖language biases，比如一个对于”how many X”问题只会回答2的模型可以依然得到比较满意的表现。因此有了新的判断指标VQA-CP (VQA under Changing Priors)，这个数据集中训练集和测试集的QA分布不同，导致许多SOTA的VQA model在这个数据集中准确率都有显著的下降</p><p>当下流行一些基于集成(ensemble-based)的方法来减轻bias的影响，他们用question-only model来调整VQA model的训练过程，这些方法大致可以分为两类：</p><pre><code>1.adversary-based：用对抗的方法训练两个model，最小化VQA model的损失的同时最大化question-only model的损失，两个model共享同一个question encoder，目标是学习一个bias-neutral的问题表示。然而，因为训练过程不稳定，因此产生了巨大的噪声2.fusion-based：最后将两个model的答案分布结合起来，设计理念是让VQA model更关注那些question-only model所不能回答的问题</code></pre><p>尽管这些ensemble-based方法在VQA-CP上取得了很好的表现，但是作者认为他们仍不能铸就一个理想的VQA模型</p><p>作者认为，一个理想的VQA模型应该有两个不可缺的特点：1)视觉可解释性(visual-explainable)：模型做决定需要依赖于正确的视觉区域；2)问题敏感性(question-sensitive)：要能够敏锐地察觉到问题的变化并作出反应</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-1.png"></p><p>文章提出了Counterfactual Samples Synthesizing (CSS)训练方法，这是一种通用的方法，可以和现有的VQA模型结合，CSS包含两种样本整合方式：V-CSS和Q-CSS，V-CSS更改图片中回答问题的关键因素并和问题构成新的QA，Q-CSS则更改问题中的关键词和原图片构成新的QA。同时为了避免高昂的人工标注代价，作者提出一种动态的答案生成方法来近似得到答案，比如not green。然后用原数据和整合数据结合训练，使VQA models更加关注标注的词或者对象</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-2.png"></p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="VQA中的language-biases"><a href="#VQA中的language-biases" class="headerlink" title="VQA中的language biases"></a>VQA中的language biases</h3><p>消除VQA中的language biases有两种方法，一种是平衡数据集来减少biases，比如VQA-CP，另一种是设计模型来减少biases，比如ensemble-based methods</p><h3 id="VQA视觉可解释性"><a href="#VQA视觉可解释性" class="headerlink" title="VQA视觉可解释性"></a>VQA视觉可解释性</h3><p>早期工作中为提高VQA的视觉可解释性，通常用人类注意力作为监督来引导model的注意力，然而因为存在强biases，就算拥有合理的注意力图，model仍然会无视图中的信息。近期一些研究用Grad-CAM来观察每个对象对正确答案的贡献，然而这些模型有两个问题，一是需要额外的人工标注，二是训练并不是end-to-end</p><h3 id="VQA问题敏感性"><a href="#VQA问题敏感性" class="headerlink" title="VQA问题敏感性"></a>VQA问题敏感性</h3><p>如果VQA系统真的理解了问题，那么他们应该对问题细微之处的变化敏感。目前只有一项工作研究了语言变化对VQA的影响[1]，但这项工作中只考虑VQA系统对于问题句式的变化的稳定性，作者认为还需要让系统察觉到关键词替换时问题的不同之处</p><p>[1] Meet Shah, Xinlei Chen, Marcus Rohrbach, and Devi Parikh.Cycle-consistency for robust visual question answering. In CVPR, 2019.</p><h3 id="VQA的反事实训练样本"><a href="#VQA的反事实训练样本" class="headerlink" title="VQA的反事实训练样本"></a>VQA的反事实训练样本</h3><p>一些研究也在尝试生成VQA的反事实训练样本，但是这些工作基本上采用GAN来生成图片，而CSS仅仅是标记关键目标或者关键词，更为简单和泛用</p><h2 id="文章贡献"><a href="#文章贡献" class="headerlink" title="文章贡献"></a>文章贡献</h2><h3 id="CSS训练方法"><a href="#CSS训练方法" class="headerlink" title="CSS训练方法"></a>CSS训练方法</h3><p>训练分为三个主要步骤：</p><p>1.用原样本$(I,Q,a)$来训练模型；</p><p>2.生成反事实样本$(I^-,Q,a^-)$以及$(I,Q^-,a^-)$；</p><p>3.用反事实样本训练模型</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-3.png"></p><h4 id="V-CSS"><a href="#V-CSS" class="headerlink" title="V-CSS"></a>V-CSS</h4><p>1.最初目标选择(IO_SEL)，选取和QA高度相关的目标，方法follow[2]</p><p>2.目标贡献计算，计算每个目标对正确答案的贡献，follow了三篇使用modified Grad-CAM的文章，核心计算公式为</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-4.png"></p><p>3.关键目标选择(CO_SEL)，选取目标top K作为关键目标，将其mask为$I^-$，剩余目标mask为$I^+$</p><p>4.动态答案生成(DA_ASS)</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-5.png"></p><p>利用$I^+$生成对应的$a^-$</p><p>[2] Jialin Wu and Raymond J Mooney. Self-critical reasoning for robust visual question answering. In NeurIPS, 2019.</p><h4 id="Q-CSS"><a href="#Q-CSS" class="headerlink" title="Q-CSS"></a>Q-CSS</h4><p>1.关键词贡献计算，和V-CSS中贡献计算类似</p><p>2.关键词选择(CW_SEL)，首先提取问题种类相关的词(比如What Color)，选取除了问题种类相关的词外的top-K作为关键词，将这些词用特殊的标记[MASK]来替换得到$Q^-$，将除了关键词和问题种类相关的词外的词用特殊标记[MASK]替代得到$Q^+$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-6.png"></p><p>3.动态答案生成(DA_ASS)，同V-CSS</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>各种模型和加上文章方法后的对比<br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-7.png"></p><p>实验结果展示</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-8.png"><br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/CSSVQA-9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> CVPR </tag>
            
            <tag> counterfactual </tag>
            
            <tag> 2020 </tag>
            
            <tag> debias </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VQA:数据集，算法和未来挑战 [综述]</title>
      <link href="2020/07/02/VQA/"/>
      <url>2020/07/02/VQA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/1610.01465v4">Paper Download Address</a></p><p>VQA(Visual Question Answering)是一个计算机视觉task，给定一个图片相关的问题和对应的图片，通过程序推断出答案</p><p>要求解决的问题是任意的，并且包含了诸多计算机视觉当中的子问题，比如</p><ol><li>目标识别 (图中的物体是什么)</li><li>目标检测 (图中有猫么)</li><li>属性分类 (图中的猫是什么颜色的)</li><li>场景分类 (图中的天气是晴天么)</li><li>计数 (图中有几只猫)</li></ol><p>当然除了这些，还有更多复杂的问题，比如目标的空间关系问题 (在沙发和猫之间的物体是什么)，常识推理问题 (图中的女孩为什么哭)</p><p>这是一篇2017年发表在Computer Vision and Image Understanding关于VQA的综述，文章内容包含以下几块</p><ol><li>VQA与一些视觉和语言问题的对比</li><li>VQA当前可用的数据集以及优缺点</li><li>讨论VQA的评价指标</li><li>分析VQA已有的算法</li><li>讨论VQA未来的发展</li></ol><h2 id="VQA与其它视觉与语言任务的对比"><a href="#VQA与其它视觉与语言任务的对比" class="headerlink" title="VQA与其它视觉与语言任务的对比"></a>VQA与其它视觉与语言任务的对比</h2><p>(这部分大致是我对这个章节的翻译，了解一下背景)</p><p>VQA的最终目标是从图片中获取问题相关的信息，根据问题，任务的范围可以从微小细节的检测到整张图片场景特征的推理，其它从图片中提取信息的计算机视觉问题，和VQA相比，范围和通用性都是有限的</p><p>目标识别，动作识别，场景分类都可以被归为图片分类问题，目前最好的方法无一例外都是训练CNN，将图片划归到特定的语义类别，其中表现最佳的目标识别算法已经能够和人类平分秋色。然而目标识别只要求将图片中的显性目标分类，而并不要求了解它的空间位置或是在更大场景中扮演的角色。目标检测包含语义分割，目前最佳的目标检测算法均使用Deep CNN。语义分割通过将每个像素点分类来完成task。实例分割通过同一语义类中不同实例之间的差异进一步区分。</p><p>语义分割和示例分割是计算机视觉领域的重要问题，是对目标检测和识别的概括，但是它们对图像整体的理解是不够充分的，其面临的主要问题之一是标签的模糊性，语义标签可以由不同解释，取决于不同的任务。此外，仅这些方法无法理解对象在更大上下文中的作用，比如bag不会告诉我们这个像素是否由人携带，而将像素标记为person并不会告诉这个人是坐着，跑着或是在滑板。而VQA则要求系统回答关于图像的任意问题，这需要对对象之间的关系和整个场景推理，而适当的标签则由问题指定。</p><p>除了VQA，近期还有一些工作也结合了视觉和语言，其中有较多人研究的是图像字幕，算法的目的是为图片产生自然的描述，图像字幕是一个非常广泛的任务，包括描述复杂属性和对象的关系来从细节上描述图片。</p><p>然而视频字幕存在一些问题，对字幕的评估就是一个特殊的挑战，理想的方法是让人类评审进行评估，但是这种方法缓慢而昂贵。因此，出现了多种自动评估方案。最为广泛使用的评价系统有BLEU，ROUGE，METEOR以及CIDEr，除了CIDEr是从图片描述评分发展而来之外，其它几种都是从机器翻译评价发展而来的。这些方法都存在局限性，比如最为广泛使用的方法BLEU，对于句子结构和语义变化巨大的句子具有相同的评分。在一些研究中，BLEU将生成字幕排在人类字幕之上，但是当人工判断的时候，只有少数人认为字幕与人类字幕具有相同好的效果。而虽然CIDEr和METEOR，和人类评审具有较高的一致性，但它们仍然经常将自动生成的字幕排名高于人类字幕。</p><p>评估字幕具有挑战性的一个原因是给定图像可以有许多合理的字幕，一些是非常特殊的，而一些是一般的。然而，字幕系统如果仅生成描述图片的通用字幕往往可以得到很高的评分，比如”一个人在街上走”和”街上有几辆车”等可以适用于大量图片的通用字幕。事实上，建立一个简单的系统，用最近邻算法返回具有最相似视觉特征的图片的字幕，使用自动评估就能得到较高的分数。</p><p>密集图像字幕 (Dense image captioning, DenseCap) 通过使用与小而突出的图像区域相关的简短视觉描述密集地注释图像，避免了一般的字幕问题，比如一个DenseCap系统可以输出”一个穿黑衬衫的人”、”大绿树”和”楼顶”，每个描述都有一个边界框，系统可以为丰富的场景生成大量的这些描述。尽管这些描述中有许多是简短的，但自动评估它们的质量仍然是困难的。DenseCap还可以忽略场景中对象之间的重要关系，只为每个区域生成独立的描述。字幕和DenseCap也是任务不可知的，系统不需要对图像进行深度理解。</p><p>字幕系统是可以自动选择图像的粒度级别的，这与VQA不同，VQA的粒度级别是根据问题的性质来决定的，比如”这是什么季节”需要了解整个场景，但是”穿白裙子的女孩后面的狗是什么颜色的”需要注意场景的具体细节。此外，许多类型的问题都有明确的答案，这使得VQA比字幕更适合于自动化的评估指标。某些问题类型可能仍然存在歧义，但对于许多问题，VQA算法产生的答案可以通过与基本真实答案的一对一匹配来评估</p><h2 id="VQA的数据集"><a href="#VQA的数据集" class="headerlink" title="VQA的数据集"></a>VQA的数据集</h2><h3 id="DAQUAR"><a href="#DAQUAR" class="headerlink" title="DAQUAR"></a>DAQUAR</h3><p>第一个主要的VQA数据集，最小的数据集，包含6795张训练数据和5673张测试数据，所有图像来自于数据集NYU-DepthV2 Dataset。数据集质量较差，一些图像杂乱无章，分辨率低，并且问题和回答有明显的语法错误</p><h3 id="COCO-QA"><a href="#COCO-QA" class="headerlink" title="COCO-QA"></a>COCO-QA</h3><p>这个数据集是通过NLP算法对COCO数据集生成的，78736训练数据，38948测试数据，数据集中问题包括目标提问(69.84%)，颜色提问(16.59%),计数(7.47%)和位置提问(6.10%)，所有问题的答案都是单个单词。数据集最大的缺点在于所有的问答都是通过NLP算法生成的，因此句式单一且存在语法问题，此外只包含四种类型的问题</p><h3 id="The-VQA-Dataset"><a href="#The-VQA-Dataset" class="headerlink" title="The VQA Dataset"></a>The VQA Dataset</h3><p>该数据集的图片包括COCO数据集和抽象卡通图片，且该数据集有两个子集，COCO-VQA和SYNTH-VQA</p><p>COCO-VQA对每张图片有三个问题和对于每个问题的十个回答，问题是人工提出的，回答由10个不同的人完成，数据集包含248349训练数据，121512验证数据和244302测试数据</p><p>SYNTH-VQA包含50000张合成场景，涉及100种目标，30种不同的动物模型和20种人类卡通模型，同样这个数据集对每张图片有三个问题和对于每个问题的十个回答。合成场景的目的是为了消除biases，比如原先在真实场景中，街道上一般都是狗，而不会是斑马</p><p>因为多样性和大小，COCO-VQA被广泛使用，但是这个数据集中也有很多问题，比如有些问题不存在简单客观的答案，而有些问题可以不需要看图片就能够回答，比如”图中树的颜色”，答案基本是”绿色”，还有yes/no的问题有六成是yes，这些都是这个数据集的biases</p><h3 id="FM-IQA"><a href="#FM-IQA" class="headerlink" title="FM-IQA"></a>FM-IQA</h3><p>这个数据集的图片也来自COCO，它的提问和回答起初是中文，然后被翻译成英文，回答可以是一整个句子。数据集的提供者建议采用人工判定，即判断回答是来自机器还是人类</p><h3 id="Visual-Genome"><a href="#Visual-Genome" class="headerlink" title="Visual Genome"></a>Visual Genome</h3><p>数据集的图片来自COCO和YFCC100M，包含108249张图片和170万QA pair，目前最大的数据集(2016.10)。数据集的提问包含What, Where, How, When, Who, Why。数据集要求提问者尽量从图片整体提问，比如”图片中有几只斑马”以及”图片当中是什么天气”，这能够很好的消除提问种类的biases。同时这个数据集当中，没有yes/no类型的问题</p><h3 id="Visual7W"><a href="#Visual7W" class="headerlink" title="Visual7W"></a>Visual7W</h3><p>Visual7W是Visual Genome数据集的子集，包含47300张图片，问题种类包含What, Where, How, When, Who, Why, Which。这个数据集通过多选来评估，每个问题包含四个选项</p><h3 id="SHAPES"><a href="#SHAPES" class="headerlink" title="SHAPES"></a>SHAPES</h3><p>SHAPES是一个特殊的数据集，包含各种排列，形状和颜色，问题包含属性，位置和形状，数据集包含244个独特的问题，答案均为yes/no，SHAPES只是作为一个附加评估，而不能取代真实图片数据集，若一个算法在其它训练集上都表现良好而在SHAPES上表现不好，说明其分析图片的方式是有限的</p><h2 id="VQA的评价指标"><a href="#VQA的评价指标" class="headerlink" title="VQA的评价指标"></a>VQA的评价指标</h2><h3 id="Simple-Accuracy"><a href="#Simple-Accuracy" class="headerlink" title="Simple Accuracy"></a>Simple Accuracy</h3><p>在多选问题中被经常被用于评估，优点是能够简单地评价和说明，并且在数量少且答案唯一的数据集上表现良好。缺点是无法区别惩罚，在开放性的QA当中无法指导训练，比如答案是dogs，但是dog很明显是比zebra要更优的，尤其是以句子为答案的问题，更难以评估</p><h3 id="Modied-WUPS"><a href="#Modied-WUPS" class="headerlink" title="Modied WUPS"></a>Modied WUPS</h3><p>WUPS是通过语义上的差别来衡量答案的好坏，通过语法树来实现。优先是对简单的变化和小错误有更大的包容度，不要求完全匹配，并且可以通过脚本简单评估。缺点是对于结构相近但是意思完全不同的单词具有高评分，比如”白色”和”黑色”。并且不能用于句子或者语法答案</p><h3 id="Consensus-Metric"><a href="#Consensus-Metric" class="headerlink" title="Consensus Metric"></a>Consensus Metric</h3><p>同一问题的相同答案将会获得高分，如果有一致性数据可以简单地评估，但是允许问题存在两个答案，同时真实数据很难收集</p><h3 id="Manual-Evaluation"><a href="#Manual-Evaluation" class="headerlink" title="Manual Evaluation"></a>Manual Evaluation</h3><p>优点是短语和句子同样可以评估，但是人工评价费时费力，且存在主观判断</p><h2 id="VQA算法"><a href="#VQA算法" class="headerlink" title="VQA算法"></a>VQA算法</h2><p>VQA的算法一般分为三个步骤</p><ol><li>图像特征提取</li><li>问题特征提取</li><li>结合两者特征来产生答案</li></ol><p>图像特征提取部分常用的有VGGNet，ResNet，GoogLeNet，问题特征提取部分常用的有BOW，LSTM，GRU以及skip thought vectors，而最后结合两者特征通常被视为分类问题来处理，常见处理方法分为以下几种</p><ol><li>用简单的方法将特征结合起来，比如特征矩阵连接，矩阵元素点乘或相加，然后扔进分类器或者神经网络</li><li>用双线性池或者相关方案将特征结合然后扔进神经网络</li><li>使用分类器对问题特征分类，以计算空间注意力图，或是采用注意力机制获得图像的自适应局部特征图</li><li>采用贝叶斯模型来计算question-image-answer分布的潜在关系</li><li>用问题将VQA任务划分为多个子任务</li></ol><h3 id="Baseline-Models"><a href="#Baseline-Models" class="headerlink" title="Baseline Models"></a>Baseline Models</h3><p>基线模型对应处理方法1，简单方法结合特征，矩阵连接，矩阵元素点乘或相加等</p><p>[1]中用BOW表示问题，GoogLeNet提取图片特征，将特征矩阵连接之后放入逻辑分类器</p><p>(BOW(Bag of words)是词袋分析法，对文本，忽略其词序和语法，表达为词数量向量)</p><p>[1] B. Zhou, Y. Tian, S. Sukhbaatar, A. Szlam, and R. Fergus, “Simple baseline for visual question answering,” arXiv preprint arXiv:1512.02167, 2015.</p><p>[2]中用skip-thought提取问题特征，ResNet-152提取图片特征，用包含两个hidden layer的MLP模型做特征结合，结果是MLP模型过拟合</p><p>(skip-thought：用一个编码器对当前句进行建模，用两个独立的自回归解码器分别建模前一个句子和后一个句子)</p><p>[2] K. Kae and C. Kanan, \Answer-type prediction for visual question answering,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016</p><p>同时，有很多研究采用LSTM来处理language</p><p>[3]用LSTM处理one-hot encoding sentence来表示问题特征，GoogLeNet来表示图片特征，然后对经过CNN的图片特征进行降维以匹配问题特征，取两者的 Hadamard product (其实就是矩阵点积)，用两层的MLP处理</p><p>(one-hot encoding：独热编码，又称为一位有效编码，使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。解决了分类器不好处理属性编码的问题，起到扩充了特征的作用)</p><p>[3] S. Antol, A. Agrawal, J. Lu, M. Mitchell, D. Batra, C. L. Zitnick, and D. Parikh, \VQA: Visual question answering,” in The IEEE International Conference on Computer Vision (ICCV), 2015</p><p>在[4]中，每个单词被嵌入CNN特征后输入到LSTM，直到问题结束，之后的CNN特征用于产生答案</p><p>[4] M. Malinowski, M. Rohrbach, and M. Fritz, \Ask your neurons: A neural-based approach to answering questions about images,” in The IEEE International Conference on Computer Vision (ICCV), 2015.</p><p>[5]中的工作则是将CNN特征作为第一个词和最后一个词输入到LSTM中，随后用softmax classier预测答案</p><p>[5] M. Ren, R. Kiros, and R. Zemel, \Exploring models and data for image question answering,” in Advances in Neural Information Processing Systems (NIPS), 2015</p><p>[6]用了两个LSTM，和[5]相比，它只将CNN特征作为最后一个词输入到LSTM中，然后用另一个LSTM取代了分类器的工作</p><p>[6] H. Gao, J. Mao, J. Zhou, Z. Huang, L. Wang, and W. Xu, \Are you talking to a machine? Dataset and methods for multilingual image question answering,” in Advances in Neural Information Processing Systems (NIPS), 2015.</p><h3 id="Bayesian-and-Question-Aware-Models"><a href="#Bayesian-and-Question-Aware-Models" class="headerlink" title="Bayesian and Question-Aware Models"></a>Bayesian and Question-Aware Models</h3><p>VQA需要图像和问题之间的推断策略和关系建模，当问题和图片被特征化之后，对其共现性(co-occurrence)的建模对答案的推出大有帮助</p><p>[7]第一次提出VQA的贝叶斯框架，作者用语义分割标识出目标和其位置，随后训练贝叶斯模型对目标的空间关系进行建模，以此来衡量每个答案的可能性。然而其依赖于语义分割，因此效率低下</p><p>[7] M. Malinowski and M. Fritz, \A multi-world approach to question answering about realworld scenes based on uncertain input,” in Advances in Neural Information Processing Systems (NIPS), 2014.</p><p>[8]中先根据问题来预测答案，随后处理图像特征和问题特征，为此，使用了大量的二次判别分析</p><p>[8] K. Kae and C. Kanan, \Answer-type prediction for visual question answering,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.</p><h3 id="Attention-Based-Models"><a href="#Attention-Based-Models" class="headerlink" title="Attention Based Models"></a>Attention Based Models</h3><p>只使用全局特征会致使目标相关区域模糊化，注意力机制则尝试去解决这个问题，这些模型学习去注意与输入空间最相关的区域。注意力机制的核心思想就是特定的视觉区域或者特定的单词比剩余的包含更多的有效信息。</p><p>注意力机制的引入通常有两种方式，一种方式是将图像均匀地划分为网格，每个网格代表图像的局部特征，此操作一般设置在最后一层卷积层之前，然后池化层将特征展开。随后由问题来确定每个网格之间的相关性</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VQA-1.png"></p><p>另一种方式是为图片生成bounding boxes，用CNN对这些boxes的内容编码，然后根据问题来决定这些boxes之间的关系</p><p>Focus Regions for VQA[9]用Edge Boxes生成bounding box region proposals，用CNN提取boxes中的特征，其VQA系统的输入包括CNN特征，问题特征和答案多选，系统为每个答案产生一个分数，将最高分作为最终的答案。分数通过各个区域加权平均计算，加权平均的权重通过全连接层学习CNN特征和问题特征的点积来得到</p><p>[9] K. J. Shih, S. Singh, and D. Hoiem, \Where to look: Focus regions for visual question answering,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.</p><p>Focused Dynamic Attention (FDA)[10]中，作者只使用和问题中目标相关的proposals，他们的VQA系统的输入为bounding boxes和其对应的目标标签，训练时，bounding boxes和目标标签通过COCO annotations得到，测试时，标签通过ResNet对bounding boxes分类得到。然后用word2vec来计算问题关键词和bounding boxes的一致性得分。得分高于0.5的bounding box被输入到LSTM中，同时采用另一个LSTM来表示问题，将两个LSTM的输出同时输入到全连接层中，最后用softmax classier来预测</p><p>[10] I. Ilievski, S. Yan, and J. Feng, \A focused dynamic attention model for visual question<br>answering,” arXiv preprint arXiv:1604.01485, 2016.</p><p>Stacked Attention Network (SAN)[11]利用问题特征，CNN特征以及softmax激活函数来计算图像上的注意力分布，然后将其应用到CNN特征图中，使用加权和将空间特征位置集合起来，来生成强调特定空间区域的全局图像表示。然后这个特征向量和问题特征联合，通过softmax来产生答案。这个方法可以产生多个注意力层，使得系统可以处理多个目标之间的复杂关系</p><p>[11] Z. Yang, X. He, J. Gao, L. Deng, and A. J. Smola, \Stacked attention networks for image question answering,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.</p><p>Spatial Memory Network[12]中，通过评估图像块与问题中单个单词的相关性来产生空间注意力，这种word-guided注意力被用于预测注意分布，然后计算嵌入图像区域的视觉特征的加权和。文章研究了两种模型，在单跳模型中，整个问题的特征与加权视觉特征相结合来预测答案。在双跳模型中，视觉特征和问题特征的结合被循环回注意机制中，以重新确定注意分布</p><p>[12] H. Xu and K. Saenko, \Ask, attend and answer: Exploring question-guided spatial attention for visual question answering,” in European Conference on Computer Vision (ECCV), 2016.</p><p>modied Dynamic Memory Network (DMN)[13]中，采用了整合注意力，包含输入模块，情节记忆模块和答案模块，同样是采用CNN特征作为word输入到RNN当中的方法</p><p>[13] A. Kumar, O. Irsoy, J. Su, J. Bradbury, R. English, B. Pierce, P. Ondruska, I. Gulrajani, and R. Socher, \Ask me anything: Dynamic memory networks for natural language processing,” in International Conference on Machine Learning (ICML), 2016.</p><p>在Hierarchical Co-Attention model[14]中，主要贡献是将注意力机制同时运用在问题和图像上，图像的处理和SMN类似，问题的处理首先用了分级编码 (hierarchical encoding)：在word level使用one-hot encoding，在phrase level使用bi- or tri-gram window size，在question level使用LSTM，通过分级，可以使用两种不同的注意力机制</p><p>[14] J. Lu, J. Yang, D. Batra, and D. Parikh, \Hierarchical question-image co-attention for visual question answering,” in Advances in Neural Information Processing Systems (NIPS), 2016.</p><h3 id="Bilinear-Pooling-Methods"><a href="#Bilinear-Pooling-Methods" class="headerlink" title="Bilinear Pooling Methods"></a>Bilinear Pooling Methods</h3><p>VQA依赖于对图像和问题的联合分析，早期模型通常用简单方法将他们的特征结合起来，比如矩阵连接，矩阵元素积等，但是我们期待更复杂的方法去处理它们，比如矢量积。因此有了双线性池化方法。</p><p>[15]提出了Multimodal Compact Bilinear pooling(MCBP)，其本质是在低维度条件下进行矢量积的近似。并将其应用在VQA，一共用到了两次MCBP模块，第一个MCBP融合了文本和图像的特征进而用来提取图像的attention，第二个MCBP将图像的attention特征与文本特征再一次融合，最终结果送入softmax分类器得到答案</p><p>[15] A. Fukui, D. H. Park, D. Yang, A. Rohrbach, T. Darrell, and M. Rohrbach, \Multimodal compact bilinear pooling for visual question answering and visual grounding,” in Conference on Empirical Methods on Natural Language Processing (EMNLP), 2016</p><p>[16]中进一步优化近似矢量积的开销，用Hadamard乘积和线性映射来实现近似双线性池化</p><p>[16] J.-H. Kim, K.-W. On, J. Kim, J.-W. Ha, and B.-T. Zhang, \Hadamard product for low-rank bilinear pooling,” arXiv preprint arXiv:1610.04325, 2016.</p><h3 id="Compositional-VQA-Models"><a href="#Compositional-VQA-Models" class="headerlink" title="Compositional VQA Models"></a>Compositional VQA Models</h3><p>在VQA中，问题通常是分为多个步骤的，比如问题”马的左边是什么”首先要找到马，然后对它左边的物体命名。基于这种想法，目前有两种组合框架通过sub-step的方式来解决VQA问题，Neural Module Network (NMN)和Recurrent Answering Units (RAU)</p><p>NMN通过问题解析器将问题划分为sub-task，然后用sub-networks来分别解决，常用模块包含find，describe，transform，比如’What color is the tie’采用先find[tie]，然后describe[color]的方案完成</p><p>而RAU不需要依赖于语言解析器，模型采用多个自循环的回答单元来解决VQA的sub-task，回答答案周期性排列，以注意力机制驱动</p><h3 id="其它有价值的模型"><a href="#其它有价值的模型" class="headerlink" title="其它有价值的模型"></a>其它有价值的模型</h3><p>引入知识库，先验知识可以帮助系统在特定问题上更好地回答；[17]在CNN的全连接层之前引入了Dynamic Parameter Prediction layer，这一层的参数通过RNN处理问题得到，这使得视觉特征在最终的分类步骤之前就能够和问题建立关系，这种做法可以看做是一种隐注意力机制；[18]采用Multimodal Residual Networks (MRN)来处理VQA，MRN改自ResNet，同时对视觉和问题特征进行残差映射，视觉和问题拥有各自的残差块，而在每个残差块之后，视觉信息被掺入了问题信息，作者尝试了多种残差块的处理方式</p><p>[17] H. Noh, P. H. Seo, and B. Han, \Image question answering using convolutional neural network with dynamic parameter prediction,” in The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.</p><p>[18] J.-H. Kim, S.-W. Lee, D.-H. Kwak, M.-O. Heo, J. Kim, J.-W. Ha, and B.-T. Zhang, Multimodal residual learning for visual qa,” in Advances in Neural Information Pro-cessing Systems (NIPS), 2016.</p><h3 id="何种方法模型表现更佳"><a href="#何种方法模型表现更佳" class="headerlink" title="何种方法模型表现更佳"></a>何种方法模型表现更佳</h3><p>ResNet的提取特征能力更佳，注意力机制有相比较好的效果，贝叶斯模型和组合模型对于正确率提升没有明显的帮助</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VQA-2.png"></p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="VQA中的视觉和问题"><a href="#VQA中的视觉和问题" class="headerlink" title="VQA中的视觉和问题"></a>VQA中的视觉和问题</h3><p>相比于图片，当下VQA系统更依赖于问题，数据集中的bias对VQA的影响非常大。通过实验可以发现image-blind模型在正确率上甚至可以超过早期结合了问题和图片的模型。同时问题和答案之间也存在bias，比如相同意思的问题，VQA对不同的句式会产生不同的答案</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/VQA-3.png"></p><p>之后要解决的问题就是减少数据集中答案和问题之间的bias，同时要求算法可以更充分地使用图片特征，而不是极大地依赖于问题特征</p><h3 id="注意力机制在VQA中有多有用"><a href="#注意力机制在VQA中有多有用" class="headerlink" title="注意力机制在VQA中有多有用"></a>注意力机制在VQA中有多有用</h3><p>很难说注意力在VQA中起到了多大的作用，有简化研究表明去除注意力机制会使模型的正确率下降，在COCO-VQA表现最好的模型也使用了注意力机制，然而有的未使用注意力机制的简单模型比采用了复杂注意力机制的模型表现更佳</p><p>注意力机制受到bias的影响，比如查询图片中是否存在窗帘(drapes)，注意力可能会从图片底部开始寻找，最后锁定在床(bed)，因为drapes在问题中通常和bedroom相关</p><h3 id="bias的损害"><a href="#bias的损害" class="headerlink" title="bias的损害"></a>bias的损害</h3><p>数据集的bias影响了对VQA算法的评估，场景以及目标属性的问题具有很强的bias，而这类问题在COCO-VQA正确率的提升对整体正确率的提升有较大影响，而复杂的’Why’ and ‘Where’问题的正确率提升对整体正确率提升却影响甚微，这个情况可以通过对每种类型的问题分别评估来解决</p><h3 id="二值问题是否充分"><a href="#二值问题是否充分" class="headerlink" title="二值问题是否充分"></a>二值问题是否充分</h3><p>目前主要的争论是二值问题是否会导致问题复杂性的缺失</p><p>二值问题的优点是非常容易用于评估，如果bias能够得到控制，那么这类问题用于测试就完全没有问题</p><h3 id="开放式-vs-多选"><a href="#开放式-vs-多选" class="headerlink" title="开放式 vs 多选"></a>开放式 vs 多选</h3><p>因为开放式多词回答是难以评估的，因此多选答案这种方式在多个数据集中被使用</p><p>然而多选题这种方式本质上是对任务的简化，它使得任务变成判断哪个答案是对的，而不是真正地去回答这个问题。比如将答案也作为特征进行训练，就能达到SOTA，但其实，这种方法只是学习了答案中的bias，作者提议所有的VQA系统都必须在不给定答案作为input的时候能够运作</p><h2 id="未来VQA数据集的建议"><a href="#未来VQA数据集的建议" class="headerlink" title="未来VQA数据集的建议"></a>未来VQA数据集的建议</h2><ol><li>Future datasets need to be larger. (更大)</li><li>Future datasets need to be less biased. (更少bias)</li><li>Future datasets need more nuanced analysis for benchmarking. (问题种类更多更全面)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 📚VQA藏书阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VQA </tag>
            
            <tag> 2017 </tag>
            
            <tag> 文献综述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于样例的相机行为控制器</title>
      <link href="2020/06/01/cinematography/"/>
      <url>2020/06/01/cinematography/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>相机规划一直是虚拟现实领域一个活跃的讨论话题<br>但相机行为(轨迹)的计算问题却甚少有人关注</p><p>已有用路径或者运动规划来指导相机轨迹的研究，主要受机器人学文献的启发</p><p>但大多数相机规划方法的关键实际上是描述何为好的运动(轨迹)</p><p>文章更倾向于从真实的电影片段中提取相机行为，文章在有限行为集上训练的深度学习网络，能够从真实的电影序列中提取相机行为，并利用对相机行为集合的先验学习将其重新定位到虚拟环境中</p><p>文章提出：<br>基于样例的相机行为控制器</p><p>1.能够处理比单目标摄像更一般的情况(特别是电影中常见的双人交互)</p><p>2.通过从合成和真实电影剪辑中获得的一系列不同相机行为进行训练</p><p>3.自动从用户选择的电影片段中提取相机行为，投射到虚拟环境中</p><p>系统架构<br><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cinematography-2.png"><br>(1)a cinematic feature estimator</p><p>从电影剪辑中提取相关特征作为输入，在电影特征空间进行表示(输出)</p><p>(2)a gating network</p><p>通过low dimensional manifold学习，充当选择器</p><p>输入电影特征空间 (a path in the cinematic feature space)</p><p>输出为一系列相机行为，作为相机行为预测网络的专家权重</p><p>(3)a camera pose prediction network</p><p>可以通过给定3D动画连续的相机和角色姿态预测下一个相机姿态，预测网络的输出是以复曲面空间坐标表示的相对相机姿势，应用于3D动画计算最终相机姿势</p><h2 id="电影特征估计器-Cinematic-Feature-Estimator"><a href="#电影特征估计器-Cinematic-Feature-Estimator" class="headerlink" title="电影特征估计器(Cinematic Feature Estimator)"></a>电影特征估计器(Cinematic Feature Estimator)</h2><p>文章采用了基于Deep Learning的Cinematic Feature Estimation从影像demo中自动分析和提取电影特征序列</p><h3 id="电影特征空间-Cinematic-Feature-Space"><a href="#电影特征空间-Cinematic-Feature-Space" class="headerlink" title="电影特征空间(Cinematic Feature Space)"></a>电影特征空间(Cinematic Feature Space)</h3><p>首先实现相机行为控制需要一个低维电影特征空间来作为一个数学模型表示相机和两个对象之间的联系<br>(相机角度，相机与对象之间的距离，屏幕的布局，角色之间的相对配置)</p><p>文章提出了一种低维空间：cinematic feature space，用于描述相机和角色之间的特征关系，空间设计需考虑 (1)简化从真实镜头中提取电影特征的过程, (2)允许从电影特征中重建三维环境中的相机姿势(包括相机和角色的相对位置和方向，以及2D帧信息)</p><p>在此基础上，文章设计了一个电影特征估计器(Cinematic Feature Estimator)，从带有人物角色的RGB图像中提取电影特征</p><p>电影特征估计器由三个阶段组成</p><p>(1) 基于LCR-Net的角色姿态估计，从图像中提取2d角色姿态</p><p>(2) 姿态关联与填充，将不同帧的角色相匹配，提高姿态检测的稳定性(过程包括填补缺失的关节和曲线平滑化)</p><p>(3) 训练神经网络，通过输入时间相关的角色姿态(temporally coherent character poses)，输出电影特征</p><p>(1)(2)阶段用于降低数据维度，简化收敛过程，降低了对数据量的要求</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cinematography-3.png"></p><p>角色之间的空间关系(角度，距离)以及相机的框架(角色在屏幕中的构成方式，相机的距离和角度)是电影表意的关键因素，不同的协调方式能传达出不同的信息，这就是相机行为(camera behavior)</p><p>从电影片段中提取哪些特征需要理解相机行为，也就是需要理解两个角色之间的行为进展(evolution)与相机角度，帧和距离变化(evolution)之间的相关性</p><h4 id="相机姿态-Camera-features"><a href="#相机姿态-Camera-features" class="headerlink" title="相机姿态 (Camera features)"></a>相机姿态 (Camera features)</h4><p>从单个RGB图像中估计相机姿态仍然是一个具有挑战性的问题，解决方案只能依赖于场景内容的强优先级(例如曼哈顿假设(?))</p><p>文章工作建立在这样的假设之上：屏幕中至少有两名角色，并且能够通过训练一个网络从这些角色的姿态中估计相机的相对姿态，文章建议在复曲面空间坐标系中表达相机姿态，这种表达方式专用于基于两个给定目标的相机定格，操作和插值任务</p><p>对于目标A和B，carema feature c可以表示为</p><p>$c = {p_A, p_B,\theta,\phi} \in R^6$</p><p>$p_A$和$p_B$表示两个角色在屏幕中的位置，$\theta$和$\phi$表示横摆角和俯仰角,给定两个屏幕位置和一组可能的相机视点形成一个2-parametric manifold surface $(\theta,\phi)$</p><p>形状类似于主轴环面，每个视点在两个目标和相同的视觉构成(A和B的屏幕位置)之间选定相同的角度$\alpha$(?)</p><p>优点</p><p>(1) 摄像机在目标A和B的局部基础上定义，可以很容易地将角色的2D屏幕运动与摄像机在Toric坐标系中的相对运动关联起来</p><p>(2) 角色的屏幕位置被嵌入到模型当中，使得其方便在不同的3D场景中复现</p><p>(3) 输入和输出具有强关联性，参数集容易学习<br>(输入：屏幕上的角色姿态，输出：Toric坐标系中的相机姿态)</p><h4 id="角色姿态-Character-features"><a href="#角色姿态-Character-features" class="headerlink" title="角色姿态(Character features)"></a>角色姿态(Character features)</h4><p>character features的定义考虑了(1)从2D姿态估计中学习这些参数的可能性以及(2)参数对gating+prediction网络的指导能力，测试了不同的参数，最终保留参数为：</p><p>$v = {d_{AB}, s_A, s_B, s_{AB},M} \in R^5$</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cinematography-4.png"></p><p>$d_AB$表示两个character之间的3D距离, $s_A$和$s_B$表示AB线与连接角色的代表点(shoulder)的front vector之间的夹角，$s_{AB}$表示两个front vector之间的difference，M是一个二进制变量，指示电影片段(sequence)的主角</p><h4 id="特征提取-Feature-extraction"><a href="#特征提取-Feature-extraction" class="headerlink" title="特征提取 (Feature extraction)"></a>特征提取 (Feature extraction)</h4><p>p_A和p_B通过角色姿态估计的头部位置来提供值，主角参数M通过姿态估计和Hitchcock摄影原理(最重要的应该是在屏幕上占据区域最大的)确定，因此需要通过network来学习的参数只有Toric坐标系中的相机位置$(\theta,\phi)$和角色相对位置参数$(d_{AB},s_A,s_B,s_{AB})$</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cinematography-5.png"></p><p>estimate network采用经过时间关联修正(temporally corrected)的LCR-Net处理后的数据作为输入。并且做了数据简化，只保留能够提供角色和相机位置，大小，方向的节点。</p><p>对于每一帧，保留$R^{28}$的参数</p><p>$u = {p_A, p_B, n_A, n_B, h_A, h_B} \in R^{28}$</p><p>$p_A,p_B \in R^2$：2D屏幕中角色头部位置</p><p>$n_A,n_B \in R^6$：颈部和左右肩关节位置，与角色之间的相对方向以及与相机的关系有关</p><p>$h_A, h_B \in R^6$：臀部，左右大腿关节位置，与相机和角色距离以及相机倾斜角度有关</p><p>影片剪辑具有时间一致性(?)，文章采用滑动窗口技术来处理数据中可能存在的噪声，提高鲁棒性</p><p>选定窗口大小为8，采用4个previous frames和3个following consecutive frames，即共$R^{8×28}$的参数量，执行一维卷积时，每个节点信道独立</p><p>电影特征的六个参数通过具有相同结构但权重和输入不同的三个不同网络进行估计</p><p>训练采用算法为Adam adaptive gradient descent algorithm，epochs为100，batch size为256，基础学习率为0.01，在包含77万个注释数据的数据集上训练，数据(8帧)来自30个不同的动画序列</p><p>Loss Function：$L(\hat{y},y) =||\hat{y} −y||$</p><p>这是一个典型的回归问题，误差函数采用网络输出值与期望值之间的方差</p><h2 id="相机运动预测网络-Camera-Motion-Prediction-Network"><a href="#相机运动预测网络-Camera-Motion-Prediction-Network" class="headerlink" title="相机运动预测网络(Camera Motion Prediction Network)"></a>相机运动预测网络(Camera Motion Prediction Network)</h2><p>相机与角色运动之间的相关性是一个典型的时间序列建模问题，只要有足够的时间序列数据，便可以设计出预测网络，在给定一系列相机和角色过去以及当前状态的情况下预测下一个相机姿态</p><p>但是真实影片的模糊性使得大量相机行为是合理的，即对于同一段角色动画可能会有不同的Camera Motion，一个相同的序列可以由不同的相机运动产生，没有简单的规则可以从单独的输入数据中确定最佳行为，训练数据的模糊性往往导致均值回归(tend to regress toward mean values)</p><p>文章采用的是混合专家系统(MoE)，采用多个预测网络(专家)和一个选择网络，预测网络对输入数据的不同Camera Motion进行专门化，选择网络来决定激活哪些专家，这种方法通过experts和gating通过反向传播来联合训练，因此对数据集的预处理和标记没有要求(?)</p><p>Gating Network本质上是一个encoder，用于得到有效相机行为的low dimension manifold，通过gating得到的电影特征序列，采用相应的experts组合，在新的3d片段中再现这个序列</p><h3 id="门控网络-Gating-Network"><a href="#门控网络-Gating-Network" class="headerlink" title="门控网络(Gating Network)"></a>门控网络(Gating Network)</h3><p>门控网络负责提取给定片段中的特定行为或行为组合，通过权衡其影响激活预测网络中的特定专家，Gating Network的输入为电影特征序列，通过标准的single-output LSTM捕获序列全局潜在相机行为信息，通过FC将其压成维度向量，然后用softmax规范化，使得m维特征和为1</p><p><img src= "https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/loading.gif" data-lazy-src="https://forever97-picture-bed.oss-cn-hangzhou.aliyuncs.com/img/cinematography-6.png"></p><h3 id="预测网络-Prediction-Network"><a href="#预测网络-Prediction-Network" class="headerlink" title="预测网络(Prediction Network)"></a>预测网络(Prediction Network)</h3><p>预测网络负责通过3d动画和来自gating network的权重，计算相机行为</p><p>预测网络是一个简单的三层FC网络，通过sliding window将i帧和前面的帧的相机姿态作为输入，预测下一帧，通过m个训练系数$\alpha_1, \alpha_2, \dots , \alpha_m$来计算预测网络的全局权重，$\alpha = \sum \alpha_i \omega_i$，$\omega$是gating网络得到的权重</p><p>预测网络的输入以i帧为中心，包含过去的60帧和将来的59帧</p><p>输入由这120帧的character cinematic features和过去60帧的camera features构成</p><p>经过训练的网络的输入大小为60*5+120*9=1380，为未来30帧输出相机复曲面参数，尺寸为30*5=150</p><p>文章做过将输出减少到1帧的实验，结果是两个连续帧之间相机姿态变化太小，无法使网络执行合理的预测</p><p>Loss Function：$L(\hat{c},c) = ||\hat{c_i} −c_i||+\eta\sum_{j=i+1}^{i+29}||\hat{c_j} −c_j||$</p><p>这个Loss Function比较好理解，同样是回归问题，考虑预测结果的结果与期望结果偏差的基础上，还需要考虑连续帧语义表达上的偏差</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h3 id="文章主要的贡献"><a href="#文章主要的贡献" class="headerlink" title="文章主要的贡献"></a>文章主要的贡献</h3><p>1.人体姿态和相机行为的简单表达(如何简单地学习出相机移动轨迹这种专业性的操作)</p><p>2.从连续帧中获取语义并用于预测虚拟场景中的行为(gating+prediction)</p><h3 id="可能可以扩展的点"><a href="#可能可以扩展的点" class="headerlink" title="可能可以扩展的点"></a>可能可以扩展的点</h3><p>1.行为表述角度：可以考虑影片光照对相机轨迹姿态的影响(可以减少几种可能的相机运动轨迹)，非主要角色对主要角色的行为影响(路人行为对影片主角的影响，比如多加几维环境变量)</p><p>2.语义获取角度: 电影原声语义判断(对话对行为判定的影响)，背景语义判断(室内室外，白天晚上，这些对行为判定应该也是有指导意义的)</p>]]></content>
      
      
      
        <tags>
            
            <tag> SIGGRAPH </tag>
            
            <tag> 姿态估计 </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wasserstein GAN</title>
      <link href="2020/04/10/WGAN/"/>
      <url>2020/04/10/WGAN/</url>
      
        <content type="html"><![CDATA[<p>Wasserstein GAN希望采用Earth Mover Distance来取代JS-divergence，以解决GAN训练中梯度弥散和梯度不稳定的问题</p><p>首先是梯度弥散问题，生成器梯度弥散的原因是过分优秀的判别器，判别器越能准确的分辨$G$和$Data$，生成器梯度消失就越严重</p><p>对于最优参数的判别器，生成器Loss为</p><p>$C(G)=-log4+2D_{JS}(p_{data}||p_G)$</p><p><a href="https://forever97.github.io/2020/03/13/GAN/">上式推导戳此处</a></p><p>最小化Loss就是最小化JS散度，具体在训练中就是尽量将$P_G$拉向$P_{data}$</p><p>JS divergence的问题就在于生成的数据和真实数据往往没有任何重叠，一是Data本质的问题，image在高维空间中的分布是一个低维的manifold，两者很难有overlap，其次在具体实现中Sampling使得overlap的概率更低</p><p>观察JS散度的表达式</p><p>$D_{JS}(P||Q)=\frac{1}{2}D_{KL}(P(x)||\frac{P(x)+Q(x)}{2})+\frac{1}{2}D_{KL}(Q(x)||\frac{P(x)+Q(x)}{2})$</p><p>$D_{KL}(P||Q) = E_{P}[log(\frac{P}{Q})]$</p><p>若P和Q没有任何重合，则代入JS散度计算的采样点x只会产生两种情况</p><ol><li>$P(x)=0，Q(x) \neq 0$</li><li>$P(x) \neq 0，Q(x)=0$</li></ol><p>即两者完全没有重叠或者重叠部分可以忽略不计</p><p>那么$JS(P||Q)=log\frac{P}{\frac{1}{2}P+0}=log2$</p><p>或是$JS(P||Q)=log\frac{Q}{\frac{1}{2}Q+0}=log2$</p><p>也就是说就算有一种分布更接近真实分布，如果没有重合就和完全不接近是相同的效果，JS散度的计算结果都是$log2$，这对梯度下降方法就意味着，梯度为0，可能没法按照更接近真实分布的训练方向前进(train不动)</p><p>所以Discriminator需要适当的迭代次数，次数太多，判别器过优，生成器梯度弥散，次数太少，生成器梯度不准，这也是GAN难以训练的原因之一</p><p>为了解决这个问题，Goodfellow提出了改进的损失函数</p><p>将$E_{x\sim p_{G}(x)}[log(1-D(x))]$替换为$E_{x\sim p_{G}(x)}[-logD(x)]$</p><p>在最优的D参数下有$C(G)=-log4+2D_{JS}(p_{data}||p_G)$</p><p>我们拆解KL散度可以得到</p><p>$D_{KL}(p_G||p_{data})=E_{x \sim p_G}[log \frac{p_G(x)}{p_{data}(x)}]$</p><p>$=E_{x \sim p_G}[log \frac{p_G(x)/(p_G(x)+p_{data(x)})}{p_{data}(x)/(p_G(x)+p_{data(x)})}]$</p><p>$=E_{x \sim p_G}[log \frac{1-D(x)}{D(x)}]$</p><p>$=E_{x \sim p_G}[log (1-D(x))]-E_{x \sim p_G}[log (D(x))]$</p><p>因此我们可以得到</p><p>$C(G)=D_{KL}(p_G||p_{data})-E_{x \sim p_G}[log (D(x))]$</p><p>$=D_{KL}(p_G||p_{data})-2D_{JS}(p_{data}||p_G)+log4+E_{x \sim p_{data}}[logD(x)]$</p><p>刨除不依赖G的部分</p><p>$C(G)=D_{KL}(p_G||p_{data})-2D_{JS}(p_{data}||p_G)$</p><p>我们发现最小化Loss，在减小KL散度的同时需要增大JS散度，这个最优化结果会导致梯度的不稳定</p><p>同时$D_{KL}(p_G||p_{data})$在$p_G(x)$趋于0而$p_{data}(x)$趋于1时值趋于0，在$p_G(x)$趋于1而$p_{data}(x)$趋于0时值趋于正无穷</p><p>前者对应的是缺乏多样性的问题，后者对应的是缺乏准确性的问题，也就是准确性缺失的惩罚远大于多样性缺失的惩罚，最优化这种Loss的结果就是mode collapse，生成器宁愿生成重复的安全样本也不愿意去尝试产生多样性的可能会触发更大惩罚的样本</p><p>Wasserstein GAN为了解决这些问题，提出了Earth Mover Distance(推土机距离)</p><p>将distribution看成两堆土，推土机距离就是将P的土形状铲成Q的最短平均距离，铲土有很多种方式，我们穷举moveing plan(matrix)，求最优的plan</p><p>$V(G,D)=max_{D \in 1-Lipschitz}(E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)])$</p><p>1-Lipschitz的意思是D has to be smooth enough，也就是说，discriminator学出来的划分线必须足够平滑，否则趋于无穷的话推土机距离没法算</p><p>用数学式子来表示就是满足$|f(x_1)-f(x_2)| \le K|x_1-x_2|$</p><p>f函数的Lipschitz常数为K</p><p>为了保证这个限制，文章作者给了一种朴素的办法叫Weight Clipping：限制权值w使得在c和-c之间，使得D平滑</p><p>所以相比于原始GAN，WGAN只做了几点改动</p><ol><li><p>判别器的最后一层去掉sigmoid，将二分类问题转化为回归问题 (近似拟合Earth Mover Distance)</p></li><li><p>去掉G和D的Loss中的log (损失函数变动)</p></li><li><p>更新判别器参数的时候将其绝对值截断到常数c以内 (1-Lipschitz)</p></li><li><p>不用基于动量的优化算法 (实验玄学)</p></li></ol><p>总的来说，WGAN的优势在于理论上解决了梯度弥散和collapse mode的问题，不需要精巧的网络设计，也不需要去注意平衡G和D的训练程度，同时提供了一个可以用于衡量训练进程的指标</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> WGAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fGAN--任意散度GAN</title>
      <link href="2020/04/03/fGAN/"/>
      <url>2020/04/03/fGAN/</url>
      
        <content type="html"><![CDATA[<p>fGAN的基本想法就是希望用不同的散度来取代JS散度</p><p>使得任何divergence都可以应用到GAN的框架中</p><p>f-divergence ：$D_f(P||Q) = \int_{x} q(x)f(\frac{p(x)}{q(x)})dx$</p><p>$f$函数需满足当$x=1$时 $f(x)=0$ 且$f$是$convex$</p><p>这个式子可以衡量分布P和Q的差异</p><p>若P分布和Q分布相同，则$D_f(P||Q) = \int_{x} f(1)dx=0$</p><p>当P分布与Q分布不同时，$D_f(P||Q) = \int_{x} q(x)f(\frac{p(x)}{q(x)})dx \ge f(\in_{x}q(x)\frac{p(x)}{q(x)}) =f(1) = 0$</p><p>(这里的积分大于等于是因为$f$是$convex$)</p><p>当$f(x)=xlogx$时</p><p>$D_f(P||Q)=\int_{x} \frac{p(x)}{q(x)} log(\frac{p(x)}{q(x)})<br>=\int_{x} p(x)log(\frac{p(x)}{q(x)})=D_{KL}(P||Q)$</p><p>当$f(x)=-logx$时</p><p>$D_f(P||Q)=D_{KL}(Q||P)$，即$Reverse KL$</p><p>共轭函数(Fenchel Conjugate)：</p><p>每个convex function $f$，都有一个conjugate function $f^*$</p><p>$f^*(t)=max_{x \in dom(f)}{xt-f(x)}$</p><p>即$f(t_1)$是$xt_1-f(x)$对$x$的任意取值取得的最大值</p><p>我们将x取不同值的$xt-f(x)$直线画出来</p><p>取每一段位置的upperbound就是f的Fenchel Conjugate</p><p>比如$xlogx$的Fenchel Conjugate就是$f^*(t)=exp(t-1)$</p><p>$f^*(t)=max_{x \in dom(f)}{xt-f(x)}$</p><p>$g(x)=xt-xlogx$ </p><p>现在给定t要使得$g(x)$最大</p><p>prove:</p><p>$t-logx-1=0$ </p><p>$x=\exp(t-1)$</p><p>$f^*(t)=\exp(t-1) \cdot t-\exp(t-1) \cdot (t-1)=\exp(t-1)$</p><p>得证</p><p>因为$f$和$f^*$是共轭函数</p><p>所以$f^*(t)=max_{x \in dom(f)}{xt-f(x)}$ </p><p>可以转化为$f(x)=max{xt-f^{*}(t)}$</p><p>$t \in dom(f^*)$</p><p>$D_f(P||Q)=\int_{x} q(x)f(\frac{p(x)}{q(x)})dx$</p><p>$=\int_{x} q(x)(max{\frac{p(x)}{q(x)}t-f^*(t)})dx$</p><p>$D_f(P||Q) \ge \int_{x}q(x)(\frac{p(x)}{q(x)}D(x)-f^*(D(x)))dx$</p><p>$=\int_{x}p(x)D(x)dx-\int_xq(x)f^*(D(x))dx$</p><p>所以说我们只要找一个$D(x)$输出为$t$</p><p>只要其能逼近$t$，那么这个式子就能逼近$x-divergence$</p><p>$D_f(P||Q)$</p><p>$\approx max_D \int_x p(x)D(x)dx - \int_xq(x)f^*(D(x))dx$</p><p>$=max_D{E_{x \sim P}[D(x)]-E_{x \sim Q}[f^*(D(x))]}$</p><p>$G^*=arg min_GD_f(P_{data}||P_G)$</p><p>$=arg min_Gmax_D{E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[f^*(D(x)]}$</p><p>那么只要得到f的共轭函数，我们就能构造出一个对应的GAN</p><p>在GAN的训练中通常会碰到以下两个问题：</p><p>Mode Collapse：训练到最后可能生成结果中同一张人脸会反复出现</p><p>Mode Dropping：Generator switches mode during training(比如第t次迭代全是黄皮肤，t+1次全是白皮肤，t+2次全是黑皮肤)</p><p>不同的divergence测试说明了这两个问题和JS-divergence无关</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> fGAN </tag>
            
            <tag> 散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CycleGAN的隐写术</title>
      <link href="2020/03/27/CycleGAN1/"/>
      <url>2020/03/27/CycleGAN1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://forever97.github.io/2020/03/27/CycleGAN/">(CycleGAN的介绍戳此处)</a></p><p>在CycleGAN的训练过程中</p><p>研究者发现，一张图片从Domain X到Domain Y的过程中可能会丢失了细节</p><p>但是令人惊讶的是，这张缺失细节的图从Domain Y映射回Domain X的时候这些细节又会被补全</p><p>也就是说CycleGAN在做Domain X到Domain Y的转化的时候隐藏了一些细节，使得我们肉眼无法观察到，但是其本身可以通过某些手段将这些记录的细节还原</p><p>用自适应直方图均衡化的手段可以观察到，CycleGAN学会了用低振幅高频信号的形式来隐藏原始图像中的细节信息，这种信号看起来几乎像是噪声，而利用这些信息，G可以再现原始图像，使得循环一致性的要求被满足</p><p>CycleGAN这种编码信息的特性很容易使得其遭受对抗性的攻击，攻击者可以通过干扰选定的原图像，使得Generator产生他们所选择的图像</p><p>文章作者认为CycleGAN模型的这种问题来自于循环一致性损失和Domain之间的熵差，因此改进的手段有修改循环一致性和添加额外的隐藏变量来人为地增加一个Domain的熵</p><p>比如在Cycle的时候引入噪声干扰信息编码等</p><p>不得不说CycleGAN利用信息编码确实很好地完成了循环一致性的任务，但是这也同时表明了，CycleGAN出现这种情况可能是网络没有足够的能力做到完全映射，所以机器选择了耍小聪明的办法来完成任务</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> CycleGAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cycle Generative Adversarial Nets</title>
      <link href="2020/03/27/CycleGAN/"/>
      <url>2020/03/27/CycleGAN/</url>
      
        <content type="html"><![CDATA[<p>风格迁移问题中，我们需要实现从输入图片到输出图片的映射，那么在训练一个Generator的时候我们需要成对的训练集，然而成对的训练集并不容易获得</p><p>因此我们希望采用GAN的形式处理风格迁移问题，$G$负责学习映射，$D$负责判别是否为规定风格</p><p>然而GAN处理的问题就在于自由度过大，可能一张清明上河图进到GAN里面风格转化的结果是一张梵高的自画像，即G完全可以为了骗过$D$将Domain X中的所有内容映射到Domain Y中的一张图，使得损失函数无效化</p><p>那么我们需要的就不仅是风格上的正确了，而是图片的分布也不能发生太大的变化</p><p>所以除去生成器$G(X\to Y)$之外，我们再建立一个生成器$G(Y \to X)$，我们希望在一张图片被映射到Domain Y之后能够被映射回Domain X，且与原来的图片大致相同</p><p>与此同时，一张图片在通过$G(Y \to X)$映射到Domain X之后，也应该能通过$G(X \to Y)$得到一张和原图大致相同的图片</p><p>定义一个循环一致性损失<br>$L_{cyc}(F,G,X,Y)=E_{x \sim p_{data(x)}}[||G(F(x))-x||<em>1]+E</em>{y \sim p_{data(y)}}[||F(G(y))-y||_1]$</p><p>最终的损失函数由三部分组成<br>$L=L_{GAN}(G(X\to Y)，D_Y)+L_{GAN}(G(Y \to X)，D_X)+L_{cyc}(G(X \to Y),G(Y \to X),X,Y)$</p><p>$L_{GAN}$即基础GAN的损失函数</p><p>CycleGAN的方法和传统的pix2pix相比对数据集的要求更低<br>比如需要做春和秋两种风格变换的，并不需要pair的数据,只要一个春风格的数据集和一个秋风格的数据集即可，并且训练完成后能够实现双向转化</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> CycleGAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conditional Generative Adversarial Nets</title>
      <link href="2020/03/25/CGAN/"/>
      <url>2020/03/25/CGAN/</url>
      
        <content type="html"><![CDATA[<p>CGAN(Conditional Generative Adversarial Nets)指的是带有附加条件的GAN网络</p><p><a href="/2020/03/13/GAN/">(GAN的介绍戳此处)</a></p><p>用传统的方法去训练一个输入为text输出的image的generator最后的学习结果会是同一类图片的平均，图片通常非常的模糊</p><p>CGAN的Generator是通过一个接受一个正态分布z和目标限定词$c$得到对应的产出$G(c,z)$，额外信息$c$的引入对生成增加了条件来指导生成，将原先无监督的GAN模型变成了一个有监督的学习过程</p><p>与此同时Discriminator也要发生相应的变化，因为如果采用原始GAN的Discriminator的话难以起到对限定词$c$的训练效果，因为不管你的限定词是猪或者是狗，$G$发现只要生成一张清晰的猫的图片，$D$就能给出高分，那么$G$就可以无视限定词直接去学习生成猫就可以了（completely ignore the input conditions）</p><p>因此CGAN中，Discriminator不能只接受Generator的输出，还要接受G的输入，Discriminator需要做的不仅是判断图片是否是真实的图片，而是在判断是否是真实图片的同时需要判断text和image的匹配程度</p><p>即Discriminator的打分对象从图片变为一个图片和词条的pair，低分的样本有（虚假图片，词条），（与词条不符的真实图片，词条）</p><p>因为只是单纯加入了一个条件限定，因此CGAN的最优化过程和GAN十分相似</p><p>$min_Gmax_DV(D,G)=E_{x\sim p_{data}(x)}[logD(x|y)]+E_{z\sim p_{z}(z)}[1-logD(G(z|y))]$</p><p>是一个条件概率极大极小博弈</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> CGAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generative Adversarial Networks</title>
      <link href="2020/03/13/GAN/"/>
      <url>2020/03/13/GAN/</url>
      
        <content type="html"><![CDATA[<p>GAN(generative adversarial networks)指生成对抗网络</p><p>GAN包含一个Generator(以下简称$G$)和一个Discriminator(以下简称$D$)</p><p>$G$是一个生成器，其本质是一个多层感知机，接收一个向量，将其映射到新的数据空间(输出为图片，句子或者其它)</p><p>$D$是一个判别器，也是一个多层感知机，输出一个标量，表示输入数据属于真实数据的概率</p><p>GAN就是$G$和$D$协同演化的过程</p><p>用图像生成作为例子，就是$G$不断去生成图片企图混淆真实图片，欺骗过$D$</p><p>而$D$呢，则是不断提高自己的辨别能力，尝试分辨出真实图片和$G$产生的虚假图片</p><p>那么GAN作为整体的最优化问题该如何去表示？</p><p>判别器$D$需要做的事情是判定x是来自数据集$Data$的概率，因此我们需要最大化$E_{x\sim p_{data}(x)}[logD(x)]$</p><p>再考虑企图去欺骗$D$的$G$，有$E_{z\sim p_{z}(z)}[1-logD(G(z))]$，判别器希望这项最大化，而生成器$G$希望这项最小化</p><p>所以我们得到了GAN的目标函数</p><p>$min_Gmax_DV(D,G)=E_{x\sim p_{data}(x)}[logD(x)]+E_{z\sim p_{z}(z)}[1-logD(G(z))]$</p><p>这是一个极大极小博弈的过程，在具体实现中这是迭代的，轮流进行</p><p>在每次迭代中：</p><p>我们首先固定$G$的参数，用随机的$vector$(原始GAN的论文中采用的是高斯噪声)去得到$Data_G$，并且从$Data$中抽取$Sample$，我们将产生的$Data_G$和Sample混合打上标签用于训练$D$</p><p>在$D$的训练完成之后，我们固定$D$的参数，不断用随机的$vector$通过$G$去得到$Data_G$，用$D$对生成打分，调整$G$的参数直到得到较高的分数，也就是在做的是learn to fool discriminator</p><p>迭代直到模型达到最优，也就是$D$已经混淆了$Data_G$和原始$Data$，判断输入来自两者的概率都是$0.5$</p><p>这就像是一个什么都不懂的幼儿园小朋友在学画画，那么幼儿园老师只要一个很低的判定标准就能够给小红花的，看到大致一个圆脸，和两个眼睛就能好好表扬一通，那么小朋友们通过这个标准就知道画一个圈中间扣两个洞是好的，等到了一年级，二年级，老师也会根据学生的水平提高评判标准，标准的更新则带来了学生水平的提高，相互促进</p><p>接下来我们需要证明，最优化问题存在唯一解，并且满足$P_{Data}$=$P_G$，也就是数据的概率分布相同</p><p>首先将期望展开为积分</p><p>$\int p_{data}(x)logD(x)dx+\int p_{z}(z)(1-logD(G(z)))dz$</p><p>=$\int p_{data}(x)logD(x)dx+\int p_G(x)(1-logD(x))dx$</p><p>以上积分等式原始GAN论文认为可通过</p><p>$E_{z\sim p_{z}(z)}\log(1-D(G(z)))=E_{x\sim p_{G(x)}}\log (1-D(x))$</p><p>来证明，来源于测度论中的 $Radon-Nikodym$ 定理</p><p>$f(D)=p_{data}log(D)+p_G(1-log(D))$</p><p>我们求解取得极值时的参数</p><p>$\frac{df(D)}{dD}=p_{data} \times \frac{1}{D} + P_G \times \frac{1}{1-D} \times -1=0$</p><p>可以得到$D^*(x)=\frac{P_{data}(x)}{P_{data}(x)+P_G(x)}$</p><p>GAN的目标是使得$P_{Data}$=$P_G$，在这种情况下$D^*(x)=\frac{1}{2}$</p><p>至此我们得到了原文中的第一条推论</p><blockquote><p>For G fixed, the optimal discriminator D is<br>$D^*<em>G(x)=\frac{P</em>{data}(x)}{P_{data}(x)+P_G(x)}$</p></blockquote><p>也就是说在固定$G$的参数的情况下，得到能够使得价值函数最大化的最优的$D$</p><p>证明$G$是极大极小博弈的解，还需要考虑求使得价值函数最小化的生成器$G$</p><p>作者在文中提出定理</p><blockquote><p>The global minimum of the virtual training criterion $C(G)$ is achieved if and only if $p_g=p_{data}$. At that point，$C(G)$ achieves the value $-log4$</p></blockquote><p>$P_G=P_{Data}$的充分性证明是比较简单的，因为我们fix了$D$的参数，去求解使得$V(G,D^*)$最小的$G$，因为$P_G=P_{Data}$，因此$D=\frac{1}{2}$</p><p>所以$V(G,D^*)=\int p_{data}(x)log(\frac{1}{2})dx+\int p_G(x)(1-\frac{1}{2})dx$</p><p>=$-log2\int p_{data}(x)dx-log2\int p_G(x)dx$</p><p>=$-2log2$ = $-log4$</p><p>$P_G=P_{Data}$的必要性证明则需要从$C(G)=-log4$反推</p><p>$C(G)=\int p_{data}(x)logD(x)dx+\int p_G(x)(1-logD(x))dx$</p><p>=$\int (p_{data}(x)log(\frac{p_{data}(x)}{p_{data}(x)+p_G(x)})+p_G(x)log(\frac{p_G(x)}{p_{data}(x)+p_G(x)}))dx$</p><p>=$\int ((log2-log2)p_{data}(x)+p_{data}(x)log(\frac{p_{data}(x)}{p_{data}(x)+p_G(x)})+(log2-log2)p_G(x)+p_G(x)log(\frac{p_G(x)}{p_{data}(x)+p_G(x)}))dx$</p><p>=$-log2\int_x(p_G(x)+p_{data}(x))dx+\int_xp_{data}(x)(log2+log(\frac{p_{data}(x)}{p_{data}(x)+p_G(x)}))+p_G(x)(log2+log(\frac{p_G(x)}{p_{data}(x)+p_G(x)}))dx$</p><p>因为$-log2\int_x(p_G(x)+p_{data}(x))dx=-log4$</p><p>所以$C(G)=-log4+\int_xp_{data}(x)(log2+log(\frac{p_{data}(x)}{p_{data}(x)+p_G(x)}))+p_G(x)(log2+log(\frac{p_G(x)}{p_{data}(x)+p_G(x)}))dx$</p><p>=$-log4+\int_xp_{data}(x)(log(\frac{p_{data}(x)}{(p_{data}(x)+p_G(x))/2}))+p_G(x)(log(\frac{p_G(x)}{(p_{data}(x)+p_G(x))/2}))dx$</p><p>=$-log4+D_{KL}(p_{data}(x)||\frac{p_{data}(x)+p_G(x)}{2})+D_{KL}(p_G(x)||\frac{p_{data}(x)+p_G(x)}{2})$</p><p>=$-log4+2D_{JS}(p_{data}||p_G)$</p><p>当$p_G=p_{data}$时，JS散度为0</p><p>证毕，当且仅当生成数据分布等于真实数据分布时得到最优的Generator</p><p><a href="https://forever97.github.io/2020/03/12/KLdivergence/" title="With a Title">(KL散度和JS散度说明戳此处)</a></p><p>现在我们明白了GAN的工作原理和目标函数的正确性</p><p>那么我们来解决一些理论上的问题，为什么$G$不直接从真实图片中学习，以及为什么$D$选择做鉴定而不是直接去生成图片呢</p><p>若$G$选择直接从图片中学习然后生成，则学习的流程为</p><p>图片1 -&gt; auto-encoder -&gt; code -&gt; NN Decoder -&gt; 图片2</p><p>即我们需要一个编码器将图片转化为vector，然后NN试图将这个图片还原，也就是图片1和图片2要尽可能相似</p><p>但是这样产生的$G$是没有creat能力的，通俗一点讲，就是他画不出没见过的图片，学习最终将code和image定死，学习两张不同朝向的1并不能使得它产生一个正向的1，而可能是噪声</p><p>VAE在这个问题上有所改进，在code进入NN之前加入了noise，希望图片仍然能被还原，这样的约束提高了网络creat的能力，但是没有对抗的加入，VAE的图片会相对的比GAN产生的模糊</p><p>还有一个问题是，缺乏监督者，因为想要input和output尽量像未必会使得结果向需要的靠拢，pixel的比对仍然属于component level的，每个神经元在同一个layer难以相互影响，那么达成目标可能需要更深的网络，并且容易造成过拟合</p><p>那么如果想采用$D$直接学习并且生成呢</p><p>$D$是可以做到Creat的，因为$D$本质上是一个Evaluation Function，Discriminator比起Generator存在的优势就是可以从整体上判定图片，我们只要穷举输入，根据Discriminator给出的分数选择高的生成</p><p>那么考虑Discriminator的训练，我们发现我们只有正样本(真实的图片)，则最大的问题就是如何寻找负样本(noise？画的差的图？)，我们需要一个质量好的负样本才能训练Discriminator</p><p>这个训练可以采用迭代的方法</p><p>先用不太好的负样本(noise)和正样本得到第一代的Discriminator，然后一代的Discriminator就可以生成质量略微提升的负样本，然后用这个负样本和Data去训练下一代的Discriminator</p><p>问题在于得到负样本的过程相当于求解argmax problem，这是一个不同情况极其个例的求解问题，难度比较高(模型未知)，甚至极大似然估计难以得到结果</p><p>因此有了GAN，Generator本质就是学习如何解argmax problem的解题机器，更容易一般化问题(不需要知道模型，直接通过NN解)，Discriminator本质就是两个数据分布的距离计算器</p><p>GAN是一种structured learning，Generator是一种Bottom Up方法，只能从component层面学习生成，Discriminator是Top Down方法，能够对整体evaluate，两者结合产生了更好的效果(生成图片更清晰)</p><p>但是GAN也存在难训练，易崩溃的问题，在学习过程中，生成器可能会发生退化，反复生成相同样本，导致判别器指向相似的地方，使得训练难以继续，而前面提到的不需要预知模型带来优点的同时也带来了模型过于自由的问题，使得在图片质量较高，pixel较多情况下GAN变得非常不可控</p>]]></content>
      
      
      <categories>
          
          <category> 🎪GAN马戏团 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KL散度</title>
      <link href="2020/03/12/KLdivergence/"/>
      <url>2020/03/12/KLdivergence/</url>
      
        <content type="html"><![CDATA[<h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><p>概率分布指的是变量X取值及其对应的概率</p><p>其包含所有取值和对应的概率</p><p>概率函数指的是用函数的形式来表示概率</p><p>$P_i=P(X=a_i)(i=1,2,3,4,5,6)$</p><p>概率分布函数$F(x)=P(X \le x)$</p><p>即概率分布函数是累积概率函数</p><p>分布参数$\hat\Theta$是一个概率分布的量化指数，它是样本总数的数值特征或一个统计模型，分布参数为一个或者多个，比如泊松分布只需要一个参数$\lambda$，正态分布则需要两个参数来决定均值和方差</p><h2 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h2><p>KL散度又被称为相对熵</p><p>是一种衡量两个分布之间匹配程度的方法</p><p>$D_{KL}(P||Q)=\sum_{i=1}^NP(x_i)log(\frac{P(x_i)}{Q(x_i)})$</p><p>其计算的是给定分布偏离真实分布的程度</p><p>在深度学习中通常用来评估模型输出的预测值分布与真值分布之间的差异</p><p>在公式中，我们用$P(x_i)$对$log(\frac{P(x_i)}{Q(x_i)})$加权</p><p>即概率越高的匹配区域的偏离系数更加重要</p><p>KL散度并不像范数一样是对称的，也就是其不是真正的度量值</p><p>即$D_{KL}(P||Q) \neq D_{KL}(Q||P)$</p><p>除去不对称性，KL散度还有一个重要的性质是非负性</p><p>$D_{KL}(P||Q) = E_{P}[log(\frac{P}{Q})] = -E_{P}[log(\frac{Q}{P})] \ge -log(E_{P}[\frac{Q}{P}]) = -log(\int P\frac{Q}{P}) = 0$</p><h2 id="最大似然估计-MLE"><a href="#最大似然估计-MLE" class="headerlink" title="最大似然估计(MLE)"></a>最大似然估计(MLE)</h2><p>最大似然估计希望从样本数据中估计总体参数</p><p>假设我们有一个概率分布D</p><p>我们从分布D中抽取n个参数$x_1,x_2,\dots,x_n$</p><p>利用n个采样数据来估计分布参数$\hat\Theta$，最终找到使得采样数据可能性最大化的分布参数$\hat\Theta$</p><p>即最大化$f_D(x_1,x_2,\dots,x_n|\hat\Theta)$</p><p>那么我们可以得到求解式$\hat\Theta=argmax_\theta \Pi_{i=1}^Np(x_i|\Theta)$</p><p>注意到乘法在实际处理中容易导致溢出，因此我们做取log处理</p><p>$\hat \Theta =argmin_\Theta - \Sigma_{i=1}^Nlog(p(x_i|\Theta))$</p><p>式子中的$argmax_\theta$和$argmin_\theta$表示$\theta$使得后式取得最大\小值时的取值</p><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>熵的概念起源于物理学，用于度量热力学系统的无序程度</p><p>信息学中的熵则类似，是用于度量信息的不确定程度</p><p>信息的作用是消除不确定性</p><p>熵越高，能传递的信息越多，不确定性越高</p><blockquote><p>确定的事件没有信息，随机事件包含最多的信息</p></blockquote><p>熵的计算式子为$H(x)=-\Sigma_xP(x)log(P(x))$</p><p>交叉熵指用分布Q的参数对分布为P的信息x编码需要的最少比特数</p><p>$H(P, Q)=-\Sigma_xP(x)log(Q(x))$</p><p>我们发现交叉熵跟KL散度以及最大似然估计十分相似</p><p>$H(P,Q)=-\Sigma_xP(x)log(Q(x))$</p><p>$=-\Sigma_{x\in X}p(x)log(q(x|\Theta))$</p><p>$=-\Sigma_xP(x)log(P(x))+\Sigma_xP(x)log(P(x))-\Sigma_xP(x)log(Q(x))$</p><p>$=H(P)+D_{KL}(P||Q)$</p><p>所以最小化交叉熵，最小化KL散度和最大似然估计过程从参数更新的角度上看意义是相同的</p><p>因为KL散度和熵均非负，因此交叉熵也具有非负性</p><h2 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h2><p>JS散度是KL散度的一种变形</p><p>$D_{JS}(P||Q)=\frac{1}{2}D_{KL}(P(x)||\frac{P(x)+Q(x)}{2})+\frac{1}{2}D_{KL}(Q(x)||\frac{P(x)+Q(x)}{2})$</p><p>因其是对称的，因此JS散度又可以称为JS距离，相比于KL散度，其对相似度的判断更为准确</p>]]></content>
      
      
      
        <tags>
            
            <tag> KL散度 </tag>
            
            <tag> 最大似然估计 </tag>
            
            <tag> 交叉熵 </tag>
            
            <tag> JS散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019 南昌站 J Summon [Poyla+BSGS+矩阵乘法]</title>
      <link href="2019/12/09/icpc2019ncJ/"/>
      <url>2019/12/09/icpc2019ncJ/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定四种颜色，去给一个长度为$n(n \le 10^5)$的环染色</p><p>有$m$种长度为$4$的序列不能在环中出现</p><p>通过旋转能够重合的环染色记做同一种染色法，求不同的染色方案数</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>通过旋转能够产生n种置换，将置换按照$gcd(step,n)$分类</p><p>则答案为$\frac{\sum_{d|n}f(d)*phi(\frac{n}{d})}{n}$</p><p>考虑计算$f(d)$，即统计长度为$d$的带$ban$位置的环染色方案数</p><p>我们建立一个$64*64$的矩阵$M$，表示长度为$3$的序列之间的转移情况</p><p>则$f(d)$为$M^d$的斜对角数字之和，即$blk=\sqrt{n}$</p><p>我们用$BSGS$来处理$M^d=(M^{blk})^{\frac{d}{blk}}*M^{d % blk}$</p><p>每次通过两个矩阵的乘积来计算$f(d)$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MTX</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[L][L];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reset();</span><br><span class="line">        rep(i, L) v[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rep(i, <span class="number">4</span>) rep(j, <span class="number">4</span>) rep(k, <span class="number">4</span>) rep(l, <span class="number">4</span>) &#123;</span><br><span class="line">            v[(i * <span class="number">4</span> + j) * <span class="number">4</span> + k][(j * <span class="number">4</span> + k) * <span class="number">4</span> + l] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123; rep(i, L) rep(j, L) v[i][j] = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ban</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        v[(x * <span class="number">4</span> + y) * <span class="number">4</span> + z][(y * <span class="number">4</span> + z) * <span class="number">4</span> + u] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A[<span class="number">400</span>], B[<span class="number">400</span>];</span><br><span class="line"><span class="function">MTX <span class="title">mul</span><span class="params">(MTX a, MTX b)</span> </span>&#123;</span><br><span class="line">    MTX c;</span><br><span class="line">    c.reset();</span><br><span class="line">    rep(i, L) rep(j, L) rep(k, L) c.v[i][j] =</span><br><span class="line">        (c.v[i][j] + <span class="number">1l</span>l * a.v[i][k] * b.v[k][j] % P) % P;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_Euler</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) phi[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll m)</span> </span>&#123; <span class="keyword">return</span> (a == <span class="number">1</span> ? <span class="number">1</span> : inv(m % a, m) * (m - m / a) % m); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Get_Euler(<span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    A[<span class="number">1</span>].reset(), A[<span class="number">1</span>].conn();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        A[<span class="number">1</span>].ban(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> blk = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>) + <span class="number">1</span>;</span><br><span class="line">    A[<span class="number">0</span>].init(), B[<span class="number">0</span>].init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= blk; i++) A[i] = mul(A[i - <span class="number">1</span>], A[<span class="number">1</span>]);</span><br><span class="line">    B[<span class="number">1</span>] = A[blk];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= blk; i++) B[i] = mul(B[i - <span class="number">1</span>], B[<span class="number">1</span>]);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> f = [&amp;](<span class="keyword">int</span> n) &#123;</span><br><span class="line">            ll t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = n / blk, a = n % blk;</span><br><span class="line">            <span class="keyword">auto</span> tmp = mul(A[a], B[b]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L; j++) t = (t + tmp.v[j][j]) % P;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;;</span><br><span class="line">        ans = (ans + f(i) * phi[n / i] % P) % P;</span><br><span class="line">        <span class="keyword">if</span> (i * i != n) ans = (ans + f(n / i) * phi[i] % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * inv(n, P) % P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Poyla </tag>
            
            <tag> BSGS </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gym 102396K Preparing Tests [动态树]</title>
      <link href="2019/12/09/GYM102396K/"/>
      <url>2019/12/09/GYM102396K/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定一个长度为$n(1 \le n \le 3*10^5)$的序列，问有多少个子序列可以作为一个合法的森林输入数据</p><p>一个合法的森林输入数据可以是多组数据，每组第一个数字给出边的数量，然后给出若干条边，要求这些边连接后构成森林</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>每组数据包含一个数字$m$表示边数，$2*m$个数字表示边</p><p>我们发现边可以分为两类，起始节点下标为奇数和起始节点下标为偶数</p><p>我们分两类用尺取法和动态树来维护有效数据位置</p><p>相邻的有效数据可以合并成为新的方案，我们记录有效数据始末端点，$dp$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(), x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) (int)x.size()</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; v;</span><br><span class="line"><span class="keyword">int</span> n, f[N], son[N][<span class="number">2</span>], tmp[N], a[N];</span><br><span class="line">ll R[N];</span><br><span class="line"><span class="keyword">bool</span> rev[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !f[x] || son[f[x]][<span class="number">0</span>] != x &amp;&amp; son[f[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    swap(son[x][<span class="number">0</span>], son[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[x]) rev1(son[x][<span class="number">0</span>]), rev1(son[x][<span class="number">1</span>]), rev[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = f[x], w = son[y][<span class="number">1</span>] == x;</span><br><span class="line">    son[y][w] = son[x][w ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[x][w ^ <span class="number">1</span>]) f[son[x][w ^ <span class="number">1</span>]] = y;</span><br><span class="line">    <span class="keyword">if</span> (f[y]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = f[y];</span><br><span class="line">        <span class="keyword">if</span> (son[z][<span class="number">0</span>] == y)</span><br><span class="line">            son[z][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (son[z][<span class="number">1</span>] == y)</span><br><span class="line">            son[z][<span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = f[y];</span><br><span class="line">    f[y] = x;</span><br><span class="line">    son[x][w ^ <span class="number">1</span>] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, i = x, y;</span><br><span class="line">    tmp[<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">while</span> (!isroot(i)) tmp[++s] = i = f[i];</span><br><span class="line">    <span class="keyword">while</span> (s) pb(tmp[s--]);</span><br><span class="line">    <span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line">        y = f[x];</span><br><span class="line">        <span class="keyword">if</span> (!isroot(y)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((son[f[y]][<span class="number">0</span>] == y) ^ (son[y][<span class="number">0</span>] == x))</span><br><span class="line">                rotate(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rotate(y);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = f[x]) splay(x), son[x][<span class="number">1</span>] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">while</span> (son[x][<span class="number">0</span>]) x = son[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    rev1(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    f[x] = y;</span><br><span class="line">    access(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    access(x);</span><br><span class="line">    splay(x);</span><br><span class="line">    f[son[x][<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    son[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    cutf(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(son, <span class="number">0</span>, <span class="keyword">sizeof</span>(son));</span><br><span class="line">    <span class="built_in">memset</span>(rev, <span class="number">0</span>, <span class="keyword">sizeof</span>(rev));</span><br><span class="line">    <span class="built_in">memset</span>(R, <span class="number">0</span>, <span class="keyword">sizeof</span>(R));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> lower_bound(all(t), p) - begin(t) + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), t.pb(a[i]);</span><br><span class="line">    sort(all(t));</span><br><span class="line">    t.erase(unique(all(t)), end(t));</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l += <span class="number">2</span>) &#123;</span><br><span class="line">        r = max(l, r);</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">2</span> &lt;= n &amp;&amp; root(findx(a[r + <span class="number">1</span>])) != root(findx(a[r + <span class="number">2</span>]))) &#123;</span><br><span class="line">            link(findx(a[r + <span class="number">1</span>]), findx(a[r + <span class="number">2</span>]));</span><br><span class="line">            r += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt;= <span class="number">2</span> * a[l]) v.push_back(&#123;l, l + <span class="number">2</span> * a[l]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (a[l + <span class="number">1</span>] != a[l + <span class="number">2</span>]) cut(findx(a[l + <span class="number">1</span>]), findx(a[l + <span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    r = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l += <span class="number">2</span>) &#123;</span><br><span class="line">        r = max(l, r);</span><br><span class="line">        <span class="keyword">while</span> (r + <span class="number">2</span> &lt;= n &amp;&amp; root(findx(a[r + <span class="number">1</span>])) != root(findx(a[r + <span class="number">2</span>]))) &#123;</span><br><span class="line">            link(findx(a[r + <span class="number">1</span>]), findx(a[r + <span class="number">2</span>]));</span><br><span class="line">            r += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt;= <span class="number">2</span> * a[l]) v.push_back(&#123;l, l + <span class="number">2</span> * a[l]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (a[l + <span class="number">1</span>] != a[l + <span class="number">2</span>]) cut(findx(a[l + <span class="number">1</span>]), findx(a[l + <span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(all(v));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v) &#123;</span><br><span class="line">        R[i.second] += R[i.first - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        ans += R[i.first - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态树 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 尺取法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gym 102396C Jet Trains [启发式合并+并查集]</title>
      <link href="2019/12/09/GYM102396C/"/>
      <url>2019/12/09/GYM102396C/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定两张有$n(n \le 10^5)$个点的图，原图中至多$k(k \le 10^5)$条边</p><p>给定$m(m \le 10^5)$个操作，操作分三类：</p><pre><code>1. 在第一张图中增加一条边2. 在第二张图中增加一条边3. 查询a点在第二张图中直接相连的点中，能够在第一张图中直接或者间接到达的数量</code></pre><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们用并查集维护第一张图，在对应的集合上记录在第二张图中出现但在第一张图中未连通的点对</p><p>当发生操作一时我们对集合进行启发式合并，将未连通点对数量少的集合并入未连通点对数量多的点对</p><p>发生点对连通时，我们修改对应两个点的答案，并将点对记录删去</p><p>总复杂度$O(Mlog(M))$，其中$M=2*(m+k)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st[N];</span><br><span class="line"><span class="keyword">int</span> n, m, k, q, f[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? x : f[x] = sf(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (st[x].size() &gt; st[y].size()) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : st[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[y].count(u)) &#123;</span><br><span class="line">            ans[u.fi]++;</span><br><span class="line">            ans[u.se]++;</span><br><span class="line">            st[y].erase(u);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st[y].insert(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        st[a].insert(&#123;a, b&#125;);</span><br><span class="line">        st[b].insert(&#123;a, b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        merge(sf(a), sf(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            merge(sf(x), sf(y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (sf(x) == sf(y)) &#123;</span><br><span class="line">                ans[x]++;</span><br><span class="line">                ans[y]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st[sf(x)].insert(&#123;x, y&#125;);</span><br><span class="line">                st[sf(y)].insert(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackerRank Similar Strings [Hash+后缀排序+二分]</title>
      <link href="2019/09/25/HACKERRANKsimilarstrings/"/>
      <url>2019/09/25/HACKERRANKsimilarstrings/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>两个字符串$a$和$b$相似当且仅当两个串长度相等</p><p>且$a_i = a_j$时$b_i = b_j， a_i \neq a_j$时$b_i \neq b_j$</p><p>给定一个字符串，多次询问其某个子串在原串中相似匹配的次数</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于每个子串，我们根据每个字母第一次出现的位置对其标号</p><p>用标号来表示这个子串，那么如果标号序列的哈希值相同则子串相等</p><p>当子串起始位置不同时，我们会得到不同的标号，我们发现标号序列存在后缀递推关系</p><p>因此我们从后往前预处理这个标号，得到每个位置作为子串起点时标号对字母的映射</p><p>维护每个字符的位置哈希，对于两个子串的比较，只要比较子串区间内所有对应标号的字符的位置哈希是否相同即可</p><p>我们对所有后缀按照相似匹配的定义进行排序，那么包含与查询子串相似的串的后缀一定是连续的段</p><p>对于查询一个子串相似匹配的次数，我们只要在后缀排名中二分找到这样的相似段的左右端点即可</p><p>即两个后缀的最长匹配大于等于子串长度的最远位置，求最长匹配的过程可以二分加速</p><p>复杂度$O(knlognlogn)$，$k$为字符集大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>, C = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N][C], id[N], rk[N];</span><br><span class="line">ull p[N], b[N][C];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> r = n - y + <span class="number">1</span>, l = <span class="number">0</span>, ans = <span class="number">0</span>, mid, h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; h == i &amp;&amp; i &lt; C; i++)</span><br><span class="line">            h += (((b[x + mid - <span class="number">1</span>][a[x][i]] - b[x - <span class="number">1</span>][a[x][i]]) * p[y - x] -</span><br><span class="line">                   b[y + mid - <span class="number">1</span>][a[y][i]] + b[y - <span class="number">1</span>][a[y][i]]) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (h == C)</span><br><span class="line">            l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = getmax(x, y);</span><br><span class="line">    <span class="keyword">if</span> (d == n - max(x, y) + <span class="number">1</span>) <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    <span class="keyword">int</span> _A = <span class="number">0</span>, _B = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[x + d] == a[x][i]) _A = i;</span><br><span class="line">        <span class="keyword">if</span> (s[y + d] == a[y][i]) _B = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _A &lt; _B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; i++) p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) a[n + <span class="number">1</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">            a[i][j] = a[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == s[i]) pos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pos--) swap(a[i][pos], a[i][pos + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        b[i][s[i]] = p[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) b[i][j] = b[i][j] + b[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[i] = i;</span><br><span class="line">    stable_sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[id[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, ans;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> x = rk[l];</span><br><span class="line">        <span class="keyword">int</span> d = r - l + <span class="number">1</span>;</span><br><span class="line">        l = ans = <span class="number">1</span>;</span><br><span class="line">        r = x;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getmax(id[x], id[mid]) &gt;= d)</span><br><span class="line">                ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = ans;</span><br><span class="line">        l = x;</span><br><span class="line">        r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getmax(id[x], id[mid]) &gt;= d)</span><br><span class="line">                ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> R = ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, R - L + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
            <tag> 后缀排序 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 963 D Frequency of String [Hash]</title>
      <link href="2019/09/17/CF963D/"/>
      <url>2019/09/17/CF963D/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>现在给定一个母串，询问多个子串</p><p>对于每个子串，求母串中最短的子串使得子串在其中出现至少$k$次</p><p>子串长度和 $\le 10^5$，母串长度 $\le 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们将询问串按照长度分组，对于每种分组，我们计算母串中对应长度的哈希值</p><p>将每个哈希值在分组中找对应的询问子串，把下标保存在对应询问上，用保存的下标计算答案</p><p>考虑子串长度和限制，复杂度均摊，最坏情况$O(n\sqrt{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">using</span> PI = <span class="built_in">pair</span>&lt;ull, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">ull p[N], Hash[N], h[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;PI&gt; v[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ID[N];</span><br><span class="line"><span class="keyword">int</span> n, k[N], L[N], L1[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N]; </span><br><span class="line"><span class="function">ull <span class="title">get_hash</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> h[R] - h[L - <span class="number">1</span>] * p[R - L + <span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">0</span>] = <span class="number">1</span>; i &lt; N; i++) p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) h[i + <span class="number">1</span>] = h[i] * base + s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;k[i], t);</span><br><span class="line">        Hash[i] = <span class="number">0</span>;</span><br><span class="line">        L1[i] = L[i] = <span class="built_in">strlen</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; L[i]; j++) Hash[i] = Hash[i] * base + t[j];</span><br><span class="line">        v[L[i]].emplace_back(Hash[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(L + <span class="number">1</span>, L + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = unique(L + <span class="number">1</span>, L + n + <span class="number">1</span>) - (L + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        sort(v[L[i]].begin(), v[L[i]].end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len - L[i] + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            ull H = get_hash(j, j + L[i] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(v[L[i]].begin(), v[L[i]].end(), PI&#123;H, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first == H) ID[it-&gt;second].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ID[i].size() &lt; k[i])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + k[i] - <span class="number">1</span> &lt; ID[i].size(); j++)</span><br><span class="line">                ans = min(ans, ID[i][j + k[i] - <span class="number">1</span>] - ID[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans + L1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 上海站 G Substring [Hash]</title>
      <link href="2019/09/16/icpc2019netshG/"/>
      <url>2019/09/16/icpc2019netshG/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>规定一个字符串和另一个字符串匹配的条件为首尾两个字符相同，且所有字符的出现次数相同</p><p>现在给定一个母串，询问多个子串，问子串在母串中的匹配次数</p><p>子串长度和 $\le 10^5$，母串长度 $\le 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们将询问串按照长度分组，对于每种分组，我们计算母串中对应长度的哈希值</p><p>然后统计对应组询问在该长度子串的哈希值中出现次数即可</p><p>我们对除串首尾做字符的集合哈希，串首尾特殊处理累加到哈希值上去</p><p>考虑子串长度和限制，复杂度均摊，最坏情况$O(n\sqrt{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, T, L[N], ans[N];</span><br><span class="line">ull p[<span class="number">125</span>], Hash[N], h[N];</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">0</span>] = <span class="number">1</span>; i &lt; <span class="number">125</span>; i++) p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t);</span><br><span class="line">            Hash[i] = <span class="number">0</span>;</span><br><span class="line">            L[i] = <span class="built_in">strlen</span>(t);</span><br><span class="line">            id[L[i]].push_back(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; L[i] - <span class="number">1</span>; j++) Hash[i] += p[t[j]];</span><br><span class="line">            Hash[i] += p[<span class="number">123</span>] * t[<span class="number">0</span>];</span><br><span class="line">            Hash[i] += p[<span class="number">124</span>] * t[L[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(L + <span class="number">1</span>, L + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = unique(L + <span class="number">1</span>, L + n + <span class="number">1</span>) - (L + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            ull H = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= L[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                    H -= p[s[j - L[i] + <span class="number">1</span>]];</span><br><span class="line">                    h[++tot] = H + p[<span class="number">123</span>] * s[j - L[i] + <span class="number">1</span>] + p[<span class="number">124</span>] * s[j];</span><br><span class="line">                &#125;</span><br><span class="line">                H += p[s[j]];</span><br><span class="line">            &#125;</span><br><span class="line">            sort(h + <span class="number">1</span>, h + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : id[L[i]]) &#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = upper_bound(h + <span class="number">1</span>, h + tot + <span class="number">1</span>, Hash[x]) - h;</span><br><span class="line">                <span class="keyword">int</span> p2 = lower_bound(h + <span class="number">1</span>, h + tot + <span class="number">1</span>, Hash[x]) - h;</span><br><span class="line">                ans[x] = p1 - p2;</span><br><span class="line">            &#125;</span><br><span class="line">            id[L[i]].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 上海站 C Triple [FFT+BigSmall]</title>
      <link href="2019/09/15/icpc2019netshC/"/>
      <url>2019/09/15/icpc2019netshC/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定三个长度为$n(n \le 10^5)$的数组$A,B,C$，数字范围$1 \le m \le 10^5$</p><p>求三个数组各选出一个数字使得最大的数字小于等于剩余两个数字相加的方案数</p><p>数据组数$T\le 100$，保证至多只有$20$组$n$大于$1000$ </p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑求补集，枚举最大的数字来自的集合，考虑求其大于剩余两个数字相加的方案</p><p>对于$n$大于$1000$的情况我们求剩余两个集合的权值数组卷积，求前缀和之后用最大数字集合查询即可</p><p>对于$n$小于等于$1000$的情况，我们暴力枚举剩余两个集合的数字组合，查询最大数字集合的权值数组前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">262144</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">        p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = nc(), b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; !(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>); c = nc())</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) b = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = nc())</span><br><span class="line">        ;</span><br><span class="line">    x *= b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i;</span><br><span class="line">    comp(<span class="keyword">double</span> _r = <span class="number">0</span>, <span class="keyword">double</span> _i = <span class="number">0</span>) : r(_r), i(_i) &#123;&#125;</span><br><span class="line">    comp <span class="keyword">operator</span>+(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r + x.r, i + x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>-(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r - x.r, i - x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>*(<span class="keyword">const</span> comp &amp;x) &#123;</span><br><span class="line">        <span class="keyword">return</span> comp(r * x.r - i * x.i, i * x.r + r * x.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">comp <span class="title">conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> comp(r, -i); &#125;</span><br><span class="line">&#125; A[N], B[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(comp a[], <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (pos[i] &gt; i) swap(a[i], a[pos[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; d) &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; d, m2 = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> o = pi * <span class="number">2</span> / m2 * t;</span><br><span class="line">        comp _w(<span class="built_in">cos</span>(o), <span class="built_in">sin</span>(o));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m2) &#123;</span><br><span class="line">            <span class="function">comp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                comp &amp;A = a[i + j + m], &amp;B = a[i + j], t = w * A;</span><br><span class="line">                A = B - t;</span><br><span class="line">                B = B + t;</span><br><span class="line">                w = w * _w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i].r /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *a, <span class="keyword">long</span> <span class="keyword">long</span> *b, <span class="keyword">long</span> <span class="keyword">long</span> *c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) A[i] = comp(a[i], b[i]);</span><br><span class="line">    j = __builtin_ctz(k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        pos[i] = pos[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i &amp; <span class="number">1</span>) &lt;&lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(A, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        j = (k - i) &amp; (k - <span class="number">1</span>);</span><br><span class="line">        B[i] = (A[i] * A[i] - (A[j] * A[j]).conj()) * comp(<span class="number">0</span>, <span class="number">-0.25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(B, k, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) c[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)(B[i].r + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n, len, a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fa[N], fb[N], fc[N], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) fa[i] = fb[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[a[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fb[b[i]]++;</span><br><span class="line">    mul(fa, fb, fc, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) fc[i] = fc[i] + fc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = ans - fc[c[i] - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doitsp</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) fc[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fc[c[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i; i--) fc[i] = fc[i] + fc[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            <span class="keyword">if</span>(a[i] + b[j] + <span class="number">1</span> &lt;= len) ans -= fc[a[i] + b[j] + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= T; cas++) &#123;</span><br><span class="line">        read(n);</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">1l</span>l * n * n * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]), len = max(a[i], len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(b[i]), len = max(b[i], len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(c[i]), len = max(c[i], len);</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            doitsp(a, b, c);</span><br><span class="line">            doitsp(b, c, a);</span><br><span class="line">            doitsp(c, a, b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, cas, ans);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &lt; len) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        doit(a, b, c, N);</span><br><span class="line">        doit(b, c, a, N);</span><br><span class="line">        doit(c, a, b, N);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %lld\n&quot;</span>, cas, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> BigSmall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 上海站 E Counting Sequences II [生成函数+泰勒展开]</title>
      <link href="2019/09/15/icpc2019netshE/"/>
      <url>2019/09/15/icpc2019netshE/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>构造一个长度为$n(n \le 10^{18})$数列，每个数字属于$[1,m]$$(m \le 2*10^5)$，要求每个偶数出现次数均为偶数次</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>多重集排列问题，用指数型生成函数处理</p><p>$G(x)=(1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\dots)$</p><p>本题的指数型生成函数为</p><p>$G(x)=(1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\dots)^{\frac{m+1}{2}}(1+\frac{x^2}{2!}+\frac{x^4}{4!}+\frac{x^6}{6!}+\dots)^{\frac{m}{2}}$</p><p>根据泰勒公式</p><p>$e^x=(1+\frac{x^1}{1!}+\frac{x^2}{2}+\frac{x^3}{3!}+\dots)$</p><p>$e^{-x}=(1-\frac{x^1}{1!}+\frac{x^2}{2!}-\frac{x^3}{3!}+\dots)$</p><p>得$G(x)=(e^x)^{\frac{m+1}{2}}(\frac{e^x+e^<br>{-x}}{2})^{\frac{m}{2}}$</p><p>二项式展开后代入得第$n$项系数为$\sum_{i=0}^{\frac{m}{2}}C(\frac{m}{2}, i)*(m-2\ast i)^n$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> U = <span class="number">200000</span>;</span><br><span class="line"><span class="keyword">int</span> f[U + <span class="number">3</span>], rf[U + <span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll m)</span> </span>&#123; <span class="keyword">return</span> (a == <span class="number">1</span> ? <span class="number">1</span> : inv(m % a, m) * (m - m / a) % m); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= U; i++) f[i] = (ll)f[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    rf[U] = inv(f[U], P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = U; i; i--) rf[i - <span class="number">1</span>] = (ll)rf[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (ll)f[n] * rf[m] % P * rf[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b, ll P)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) t = t * a % P;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, m;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = m &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            ans = (ans + C(t, i) * powmod(m - <span class="number">2</span> * i, n, P) % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * powmod(powmod(<span class="number">2</span>, t, P), P - <span class="number">2</span>, P) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 泰勒展开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackerRank Circular Palindromes [Manacher+二分答案]</title>
      <link href="2019/09/14/HACKERRANKcircularpalindromes/"/>
      <url>2019/09/14/HACKERRANKcircularpalindromes/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>求每一种旋转串的最长回文子串，串长小于等于$10^6$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>倍长字符串，转化为区间回文子串，$manacher$预处理倍长后的回文串</p><p>对于查询区间$[L,R]$最长回文子串</p><p>我们可以二分答案，检验区间$[L+x-1,R-x+1]$中是否存在长度大于$x$的回文中心即可</p><p>$ST$表预处理$r$数组的区间最大值，复杂度$O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[N &lt;&lt; <span class="number">1</span>], r[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> s[N], c[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N &lt;&lt; <span class="number">1</span>][<span class="number">21</span>], lg2[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg2[i] = lg2[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">0</span>] = r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">            dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) swap(l, r);</span><br><span class="line">    <span class="keyword">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) c[i &lt;&lt; <span class="number">1</span>] = s[i], c[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    c[n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">    c[(n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k;</span><br><span class="line">    n = n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (c[i - j - <span class="number">1</span>] == c[i + j + <span class="number">1</span>]) j++;</span><br><span class="line">        r[i] = j;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= j &amp;&amp; r[i] - k != r[i - k]; k++)</span><br><span class="line">            r[i + k] = min(r[i - k], r[i] - k);</span><br><span class="line">        i += k;</span><br><span class="line">        j = max(j - k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m = n;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) s[i] = s[i - n];</span><br><span class="line">    n = n * <span class="number">2</span>;</span><br><span class="line">    manacher();</span><br><span class="line">    Init(n);</span><br><span class="line">    <span class="comment">// 区间[i,i+n-1]的最长回文子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = m, ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">2</span> * i, R = <span class="number">2</span> * (i + m - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (Max(L + mid - <span class="number">1</span>, R - mid + <span class="number">1</span>) &gt;= mid)</span><br><span class="line">                ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 南昌站 D Interesting Series [生成函数+FFT]</title>
      <link href="2019/09/11/icpc2019netncD/"/>
      <url>2019/09/11/icpc2019netncD/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定$F_1=1$，$F_n=a*F_{n-1}+1$</p><p>有一个有$n$个元素的多重集合$S$</p><p>$value(s)=F_{\sum{s_i}}$</p><p>定义$ans(k)=\sum_{s \subset S \ and \ |s|=k}value(s)$</p><p>求$ans(1),ans(2),……,ans(n) \ mod \ 100003$</p><p>$n \le 10^5，2 \le a \le 1000，1 \le s_i \le 1e9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$F_n=\frac{a^n-1}{a-1}$</p><p>对于给定的$k$，我们计算出不同方案下的$a^{sum}$之和，$sum$由$k$个$s$相加得到，减去方案数$C_n^k$，然后除以$(a-1)$即可</p><p>前者为母函数$(x+a^{s_1})(x+a^{s_2})……(x+a^{s_n})$的$x^{n-k}$前的系数</p><p>所以我们计算这个母函数前的系数，$FFT$计算即可</p><p>我们可以通过分治区间优化多次等长数组的卷积，复杂度$O(nlognlogn)$</p><p>此题精度不足需要用$long \ double$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">524300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">100003</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">namespace</span> FFT &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i;</span><br><span class="line">    comp(<span class="keyword">double</span> _r = <span class="number">0</span>, <span class="keyword">double</span> _i = <span class="number">0</span>) : r(_r), i(_i) &#123;&#125;</span><br><span class="line">    comp <span class="keyword">operator</span>+(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r + x.r, i + x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>-(<span class="keyword">const</span> comp &amp;x) &#123; <span class="keyword">return</span> comp(r - x.r, i - x.i); &#125;</span><br><span class="line">    comp <span class="keyword">operator</span>*(<span class="keyword">const</span> comp &amp;x) &#123;</span><br><span class="line">        <span class="keyword">return</span> comp(r * x.r - i * x.i, i * x.r + r * x.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">comp <span class="title">conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> comp(r, -i); &#125;</span><br><span class="line">&#125; A[N], B[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(comp a[], <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (pos[i] &gt; i) swap(a[i], a[pos[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; d) &lt; n; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> &lt;&lt; d, m2 = m &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> o = pi * <span class="number">2</span> / m2 * t;</span><br><span class="line">        comp _w(<span class="built_in">cos</span>(o), <span class="built_in">sin</span>(o));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += m2) &#123;</span><br><span class="line">            <span class="function">comp <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                comp &amp;A = a[i + j + m], &amp;B = a[i + j], t = w * A;</span><br><span class="line">                A = B - t;</span><br><span class="line">                B = B + t;</span><br><span class="line">                w = w * _w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i].r /= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *a, <span class="keyword">long</span> <span class="keyword">long</span> *b, <span class="keyword">long</span> <span class="keyword">long</span> *c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) A[i] = comp(a[i], b[i]);</span><br><span class="line">    j = __builtin_ctz(k) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        pos[i] = pos[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i &amp; <span class="number">1</span>) &lt;&lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(A, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        j = (k - i) &amp; (k - <span class="number">1</span>);</span><br><span class="line">        B[i] = (A[i] * A[i] - (A[j] * A[j]).conj()) * comp(<span class="number">0</span>, <span class="number">-0.25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(B, k, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) c[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)(B[i].r + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace FFT</span></span><br><span class="line">ll a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">int</span> pw[N], s[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        v[x].push_back(<span class="number">1</span>);</span><br><span class="line">        v[x].push_back(pw[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    solve(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    solve(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N &lt;= r - l + <span class="number">1</span>) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid - l + <span class="number">1</span>; i++) a[i] = v[x &lt;&lt; <span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r - mid; i++) b[i] = v[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][i];</span><br><span class="line">    FFT::mul(a, b, c, N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r - l + <span class="number">1</span>; i++) v[x].push_back(c[i] % P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Comb &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> U = P - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> f[U + <span class="number">3</span>], rf[U + <span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll m)</span> </span>&#123; <span class="keyword">return</span> (a == <span class="number">1</span> ? <span class="number">1</span> : inv(m % a, m) * (m - m / a) % m); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= U; i++) f[i] = (ll)f[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    rf[U] = inv(f[U], P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = U; i; i--) rf[i - <span class="number">1</span>] = (ll)rf[i] * i % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (ll)f[n] * rf[m] % P * rf[n - m] % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace Comb</span></span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b, ll P)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = a * a % P)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) t = t * a % P;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, A, k, q, ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comb::init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;A, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pw[i] = powmod(A, s[i], P);</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> t = powmod((A - <span class="number">1</span> + P) % P, P - <span class="number">2</span>, P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans[i] = <span class="number">1l</span>l * (v[<span class="number">1</span>][i] - Comb::C(n, i) + P) % P * t % P;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackerRank How Many Substrings [后缀自动机+线段树+动态树]</title>
      <link href="2019/09/11/HACKERRANKhowmanysubstrings/"/>
      <url>2019/09/11/HACKERRANKhowmanysubstrings/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定长度为$n(n \le 10^5)$的字符串求区间本质不同的子串数量</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们用线段树维护每个节点为左端点的，到r为右端点为止的本质不同子串数量</p><p>每个相同的子串只将值保留在最后一次出现的左端点</p><p>当一个字符被新增到原串的末尾时，会在某些左端点增加新的本质不同的串</p><p>同时部分子串最后一次出现的左端点将移动到串尾</p><p>我们对$[1,pos]$前缀的所有左端点答案$+1$，考虑减去重复的串</p><p>对于串$[v,r]$，如果出现在$[l,r-v+l]$，那么两者在后缀自动机$fail$树上的$lca$就是两者的重复串集</p><p>在每个串位置记录最后一次出现的位置$ps$，我们从根到当前叶节点按照长度处理重复串，更新对应$right$集新的位置</p><p>我们发现重复串和$LCT$的$access$操作一致，只会发生$O(logn)$段$ps$的变动</p><p>我们通过$LCT$的$access$操作保存在$fail$链上上一次串的出现位置，提取变动段，用线段树维护即可</p><p>均摊复杂度$O(nlog^2n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Ask &amp;a, Ask &amp;b) &#123; <span class="keyword">return</span> a.r &lt; b.r; &#125;;</span><br><span class="line">&#125; ask[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="comment">// SAM</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> cnt, lst, a[N &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], l[N &lt;&lt; <span class="number">1</span>], f[N &lt;&lt; <span class="number">1</span>], mrk[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = lst;</span><br><span class="line">    <span class="keyword">int</span> np = lst = ++cnt;</span><br><span class="line">    l[np] = l[p] + <span class="number">1</span>;</span><br><span class="line">    mrk[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!a[p][c] &amp;&amp; p) a[p][c] = np, p = f[p];</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        f[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = a[p][c];</span><br><span class="line">        <span class="keyword">if</span> (l[p] + <span class="number">1</span> == l[q])</span><br><span class="line">            f[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">            l[nq] = l[p] + <span class="number">1</span>;</span><br><span class="line">            mrk[nq] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(a[nq], a[q], <span class="keyword">sizeof</span>(a[q]));</span><br><span class="line">            f[nq] = f[q];</span><br><span class="line">            f[np] = f[q] = nq;</span><br><span class="line">            <span class="keyword">while</span> (a[p][c] == q) a[p][c] = nq, p = f[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Segment Tree</span></span><br><span class="line">ll tag[N &lt;&lt; <span class="number">1</span>], sum[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> l + r | l != r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tag[x] = sum[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    build(l, mid);</span><br><span class="line">    build(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_tag</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r);</span><br><span class="line">    tag[x] += v;</span><br><span class="line">    sum[x] += v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        add_tag(l, mid, tag[x]);</span><br><span class="line">        add_tag(mid + <span class="number">1</span>, r, tag[x]);</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[idx(l, r)] = sum[idx(l, mid)] + sum[idx(mid + <span class="number">1</span>, r)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) &#123;</span><br><span class="line">        add_tag(l, r, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pd(l, r);</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) upd(l, mid, ul, ur, v);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; ur) upd(mid + <span class="number">1</span>, r, ul, ur, v);</span><br><span class="line">    up(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[x];</span><br><span class="line">    pd(l, r);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += qry(l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) res += qry(mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LCT</span></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp[N];</span><br><span class="line"><span class="keyword">int</span> fa[N &lt;&lt; <span class="number">1</span>], son[N &lt;&lt; <span class="number">1</span>][<span class="number">2</span>], tmp[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cov[N &lt;&lt; <span class="number">1</span>], ps[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cov1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    cov[x] = v;</span><br><span class="line">    ps[x] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cov[x]) &#123;</span><br><span class="line">        cov1(son[x][<span class="number">0</span>], cov[x]);</span><br><span class="line">        cov1(son[x][<span class="number">1</span>], cov[x]);</span><br><span class="line">        cov[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lct_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (son[x][<span class="number">0</span>]) ps[x] = max(ps[x], ps[son[x][<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">if</span> (son[x][<span class="number">1</span>]) ps[x] = max(ps[x], ps[son[x][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], w = son[y][<span class="number">1</span>] == x;</span><br><span class="line">    son[y][w] = son[x][w ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (son[x][w ^ <span class="number">1</span>]) fa[son[x][w ^ <span class="number">1</span>]] = y;</span><br><span class="line">    <span class="keyword">if</span> (fa[y]) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = fa[y];</span><br><span class="line">        <span class="keyword">if</span> (son[z][<span class="number">0</span>] == y)</span><br><span class="line">            son[z][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (son[z][<span class="number">1</span>] == y)</span><br><span class="line">            son[z][<span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = fa[y];</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    son[x][w ^ <span class="number">1</span>] = y;</span><br><span class="line">    lct_up(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !fa[x] || son[fa[x]][<span class="number">0</span>] != x &amp;&amp; son[fa[x]][<span class="number">1</span>] != x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, i = x, y;</span><br><span class="line">    tmp[<span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">while</span> (!isroot(i)) tmp[++s] = i = fa[i];</span><br><span class="line">    <span class="keyword">while</span> (s) pb(tmp[s--]);</span><br><span class="line">    <span class="keyword">while</span> (!isroot(x)) &#123;</span><br><span class="line">        y = fa[x];</span><br><span class="line">        <span class="keyword">if</span> (!isroot(y)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((son[fa[y]][<span class="number">0</span>] == y) ^ (son[y][<span class="number">0</span>] == x))</span><br><span class="line">                rotate(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rotate(y);</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    lct_up(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mcnt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    mcnt = <span class="number">0</span>;</span><br><span class="line">    cov1(x, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x]) &#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        son[x][<span class="number">1</span>] = y;</span><br><span class="line">        mp[++mcnt] = <span class="built_in">make_pair</span>(len[x], ps[x]);</span><br><span class="line">        lct_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lct_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = fa[i] = <span class="number">0</span>;</span><br><span class="line">        ps[i] = cov[i] = len[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> b[N &lt;&lt; <span class="number">1</span>], x[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ver[N &lt;&lt; <span class="number">1</span>], id[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    lct_init();</span><br><span class="line">    build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">memset</span>(l, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (cnt + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (cnt + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (cnt + <span class="number">1</span>));</span><br><span class="line">    cnt = <span class="number">0</span>, lst = ++cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) extend(Tr(s[i]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) b[l[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) x[b[l[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        id[x[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> (mrk[x[i]]) ver[l[x[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        len[i] = l[x[i]];</span><br><span class="line">        <span class="keyword">if</span> (f[x[i]]) fa[i] = id[f[x[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        ask[i] = &#123;l + <span class="number">1</span>, r + <span class="number">1</span>, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ask + <span class="number">1</span>, ask + q + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        upd(<span class="number">1</span>, n, <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">        access(ver[i], i);</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mcnt; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[j].first == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (mp[j].second != <span class="number">0</span>)</span><br><span class="line">                upd(<span class="number">1</span>, n, mp[j].second - mp[j].first + <span class="number">1</span>, mp[j].second - pre,</span><br><span class="line">                    <span class="number">-1</span>);</span><br><span class="line">            pre = mp[j].first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= q &amp;&amp; ask[p].r == i) &#123;</span><br><span class="line">            ans[ask[p].id] = qry(<span class="number">1</span>, n, ask[p].l, ask[p].r);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 动态树 </tag>
            
            <tag> 扫描线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 700 E Cool Slogans [线段树合并+后缀自动机]</title>
      <link href="2019/09/10/CF700E/"/>
      <url>2019/09/10/CF700E/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>我们定义一个字符串$a$比一个字符串$b$酷</p><p>当$b$在$a$中作为子串出现至少两次</p><p>现在给定一个字符串$S$，要求找到最长的子串序列$S_1$,$S_2$,$S_3$……</p><p>要求对于任意$i$，$S_{i+1}$比$S_i$酷</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们发现，如果我们要找一个字符串$b$，使得字符串$a$作为子串在其中出现至少两次</p><p>即$a$的$endpos$集合在$[pos[b]-len[b]+len[a],pos[b]]$中出现至少两次</p><p>最短的$b$串一定是以$a$为前缀且以$a$为后缀的，可以得出结论$a$为$b$的$border$</p><p>那么只要$a$的$endpos$集合在$[pos[b]-len[b]+len[a],pos[b]-1]$中出现即可</p><p>用线段树维护$endpos$，将$endpos$按$fail$链进行线段树合并得到每个节点的$endpos$集合，在对应集合查询区间$[pos[b]-len[b]+len[a],pos[b]-1]$是否有值即可</p><p>我们需要在$fail$链节点上保存最长子序列的最后一位，每次扩展时在这一位的线段树上查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> p, q, np, nq, cnt, lst, a[N][<span class="number">26</span>], l[N], f[N], pos[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> ps)</span> </span>&#123;</span><br><span class="line">    p = lst;</span><br><span class="line">    np = lst = ++cnt;</span><br><span class="line">    l[np] = l[p] + <span class="number">1</span>;</span><br><span class="line">    pos[np] = ps;</span><br><span class="line">    <span class="keyword">while</span> (!a[p][c] &amp;&amp; p) a[p][c] = np, p = f[p];</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        f[np] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q = a[p][c];</span><br><span class="line">        <span class="keyword">if</span> (l[p] + <span class="number">1</span> == l[q])</span><br><span class="line">            f[np] = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nq = ++cnt;</span><br><span class="line">            l[nq] = l[p] + <span class="number">1</span>;</span><br><span class="line">            pos[nq] = pos[q]; </span><br><span class="line">            <span class="built_in">memcpy</span>(a[nq], a[q], <span class="keyword">sizeof</span>(a[q]));</span><br><span class="line">            f[nq] = f[q];</span><br><span class="line">            f[np] = f[q] = nq;</span><br><span class="line">            <span class="keyword">while</span> (a[p][c] == q) a[p][c] = nq, p = f[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">30</span>], rs[N * <span class="number">30</span>], rt[N], tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    x = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    p &lt;= mid ? upd(ls[x], l, mid, p) : upd(rs[x], mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">int</span> z = ++tot;</span><br><span class="line">    ls[z] = merge(ls[x], ls[y]);</span><br><span class="line">    rs[z] = merge(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res |= qry(ls[x], l, mid, ql, qr);</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res |= qry(rs[x], mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n, b[N], x[N], r[N], top[N], dp[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>, lst = ++cnt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        extend(Tr(s[i]), i);</span><br><span class="line">        upd(rt[lst], <span class="number">1</span>, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) b[l[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) x[b[l[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt; <span class="number">1</span>; i--) rt[f[x[i]]] = merge(rt[f[x[i]]], rt[x[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x[i], fu = f[u];</span><br><span class="line">        <span class="keyword">if</span> (fu == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[u] = <span class="number">1</span>, top[u] = u;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t = qry(rt[top[fu]], <span class="number">1</span>, n, pos[u] - l[u] + l[top[fu]], pos[u] - <span class="number">1</span>);</span><br><span class="line">        dp[u] = dp[fu] + t;</span><br><span class="line">        top[u] = t ? u : top[fu];</span><br><span class="line">        ans = max(ans, dp[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 南京站 G Quadrilateral [计数]</title>
      <link href="2019/09/02/icpc2019netnjG/"/>
      <url>2019/09/02/icpc2019netnjG/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定a,b,c,d四条边的取值范围，求能构成的合法四边形数量</p><p>$a,b,c \le 10^5,d \le 10^3$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑求答案的补集，即不合法四边形数量</p><p>假定最长边为$a$，则我们需要对于每个取值统计$b+c+d$不超过$a$的数量</p><p>因为是连续取值范围，我们可以用差分数组维护$b+c+d$</p><p>首先对于每个$b$，产生区间值$[b+l_c,b+r_c]$，差分数组处理得到$b+c$</p><p>此时$b+c$是离散的，但是$d$是连续的，所以可以考虑枚举$b+c$，对区间$[b+c+l_d,b+c+r_d]$产生贡献，差分数组处理</p><p>二次前缀和之后得到$b+c+d$的权值数组的前缀和，$O(n)$枚举$a$，$O(1)$查询贡献</p><p>因为要不合法是$b+c+d&lt;=a$，所以在差分过程中，只要保留$a$值域范围的权值数组</p><p>枚举其余边作为最长边，按照上述方法计算，从总方案中减去即可</p><p>总复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s1[N], s2[N], tot, ans;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">4</span>], r[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id[<span class="number">3</span>], c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r[x]; i++) s1[i] = s2[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == x) <span class="keyword">continue</span>;</span><br><span class="line">        id[c++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l[id[<span class="number">0</span>]]; i &lt;= r[id[<span class="number">0</span>]]; i++) &#123;</span><br><span class="line">        s1[l[id[<span class="number">1</span>]] + i]++;</span><br><span class="line">        s1[r[id[<span class="number">1</span>]] + i + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r[x]; i++) s1[i] += s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r[x]; i++) &#123;</span><br><span class="line">        s2[l[id[<span class="number">2</span>]] + i] += s1[i];</span><br><span class="line">        s2[r[id[<span class="number">2</span>]] + i + <span class="number">1</span>] -= s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r[x]; i++) s2[i] += s2[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r[x]; i++) s2[i] += s2[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l[x]; i &lt;= r[x]; i++) ans += s2[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        tot = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">            tot = tot * (r[i] - l[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) solve(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tot - ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分数组 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 南京站 D Robots [期望DP]</title>
      <link href="2019/09/02/icpc2019netnjD/"/>
      <url>2019/09/02/icpc2019netnjD/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>一个机器人在一张n个点m条边的有向无环图上行走，每天等概率地在原地不动或者移动到相邻的位置</p><p>每天消耗的能量为已经过去的天数，问从起点抵达终点最小耗能</p><p>$2 \le n \le 10^5,1 \le m \le 2 \ast 10^5$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>因为从起点出发到终点转移是等概率的，所以考虑按照从终点到起点的拓扑序转移</p><p>记$g_u$为$u$点到终点的期望步数，$f_u$为$u$点到终点的期望代价</p><p>考虑在路径序列前端多加一个点，其之后每一天的代价都会增加1</p><p>那么其和有向图上的后继节点关系有：</p><p>$g_u=(\sum(g_v+1)+g_u+1)/(sz_u+1)$</p><p>$f_u=(\sum(f_v+g_v+1)+f_u+g_u+1)/(sz_u+1)$</p><p>按照从终点到起点拓扑序转移计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret, v[N], G[N];</span><br><span class="line"><span class="keyword">double</span> g[N], f[N];</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(n);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        ret.push_back(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v[u]) &#123;</span><br><span class="line">            --d[x];</span><br><span class="line">            <span class="keyword">if</span> (!d[x]) Q.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear(), v[i].clear();</span><br><span class="line">        ret.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            v[y].push_back(x);</span><br><span class="line">            G[x].push_back(y);</span><br><span class="line">            d[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        TopSort();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : ret) &#123;</span><br><span class="line">        f[x] = <span class="number">0</span>;</span><br><span class="line">        g[x] = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">if</span> (!G[x].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x]) &#123;</span><br><span class="line">                g[x] = g[x] + g[y] + <span class="number">1</span>;</span><br><span class="line">                f[x] = f[x] + f[y] + g[y] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g[x] = (g[x] + <span class="number">1</span>) / G[x].size();</span><br><span class="line">            f[x] = (f[x] + g[x] + <span class="number">1</span>) / G[x].size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, f[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期望DP </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC2019网络赛 南京站 E K Sum [杜教筛+欧拉降幂]</title>
      <link href="2019/09/01/icpc2019netnjE/"/>
      <url>2019/09/01/icpc2019netnjE/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>定义函数$f_n(k)=\sum_{l_1=1}^n\sum_{l_2=1}^n\dots\sum_{l_k=1}^n(gcd(l_1,l_2,\dots,l_k))^2$</p><p>求$S=\sum_{i=2}^kf_n(i)$</p><p>答案对$10^9+7$取模</p><p>$1 \le n \le 10^9,2 \le k \le 10^{10^5}$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$f_n(k)=\sum_{g=1}^ng^2\sum_{l_1=1}^n\sum_{l_2=1}^n\dots\sum_{l_k=1}^n[gcd(l_1,l_2,\dots,l_k)==g]$</p><p>设$F(x)=\sum_{l_1=1}^n\sum_{l_2=1}^n\dots\sum_{l_k=1}^n[x \mid gcd(l_1,l_2,\dots,l_k)]$</p><p>$g(x)=\sum_{l_1=1}^n\sum_{l_2=1}^n\dots\sum_{l_k=1}^n[gcd(l_1,l_2,\dots,l_k)==x]$</p><p>$F(x)=\sum_{x \mid d}g(d)=\lfloor\frac{n}{x}\rfloor^k$</p><p>$g(x)=\sum_{x|d}\mu(\frac{d}{x})F(d)=\sum_{x \mid d}\mu(\frac{d}{x})\lfloor\frac{n}{d}\rfloor^k$</p><p>$f_n(k)=\sum_{g=1}^ng^2\sum_{g \mid d}\mu(\frac{d}{g})\lfloor\frac{n}{d}\rfloor^k$</p><p>枚举约数转枚举倍数</p><p>有$f_n(k)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor^k\sum_{g|i}g^2\mu(\frac{i}{g})$</p><p>则$S(n)=\sum_{i=1}^n(\lfloor\frac{n}{i}\rfloor^2+\lfloor\frac{n}{i}\rfloor^3+\dots+\lfloor\frac{n}{i}\rfloor^k)\sum_{g|i}g^2\mu(\frac{i}{g})$</p><p>记$F(n)=n^2+n^3+\dots+n^k$</p><p>$G(n)=\sum_{d|n}d^2\mu(\frac{n}{d})$</p><p>$F(n)$可以通过等比数列求和公式得到，因为$k$比较大，需要在等比数列求和公式中使用欧拉降幂，需要特殊注意的是，当公比是1时答案是$k-1$，此时$k$并非指数，因此需要分别处理指数取模的$k$以及底数取模的$k$</p><p>$G(n)=(id^2\ast\mu)(n)$</p><p>考虑卷上$I$来消除$\mu$</p><p>$(g*G)(n)=((id^2\ast \mu)\ast I)(n)=(id^2\ast(\mu\ast I))(n)$</p><p>$(\mu\ast I)(n)=e,(e\ast f)(n)=f$</p><p>因此我们得到$(I\ast G)(n)=id^2$</p><p>所以对于$SumG(n)=\sum_{i=1}^nG(n)=\sum_{i=1}^ni^2-\sum_{d \mid n}SumG(\lfloor\frac{n}{d}\rfloor)$</p><p>预处理前缀和，杜教筛计算即可</p><p>对于$G(n)=(id^2\ast\mu)(n)$前缀和的预处理，$G(n)$是积性函数，并且有$G(1)=1$，$G(p)=p^2-1$，$G(p^c)=p^{2c-2}\ast (p^2-1)$</p><p>$S(n)=\sum_{i=1}^nF(\lfloor\frac{n}{i}\rfloor)\ast G(i)$</p><p>我们对$G$数值分块，通过$SumG$前缀差得到区段和即可计算最终答案$S$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> notp[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], pnum, f[N];</span><br><span class="line">ll sum[N], inv6;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notp, <span class="number">0</span>, <span class="keyword">sizeof</span>(notp));</span><br><span class="line">    notp[<span class="number">0</span>] = notp[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    pnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notp[i]) &#123;</span><br><span class="line">            prime[++pnum] = i;</span><br><span class="line">            f[i] = (<span class="number">1l</span>l * i * i - <span class="number">1</span> + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pnum &amp;&amp; <span class="number">1l</span>l * prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            notp[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i * prime[j]] = <span class="number">1l</span>l * f[i] * prime[j] % P * prime[j] % P;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i * prime[j]] = <span class="number">1l</span>l * f[prime[j]] * f[i] % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) sum[i] = (sum[i - <span class="number">1</span>] + f[i]) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum2</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1</span>) % P * (<span class="number">2</span> * x + <span class="number">1</span>) % P * inv6 % P; &#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> sum[n];</span><br><span class="line">    <span class="keyword">if</span> (mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll res = sum2(n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, last; i &lt;= n; i = last + <span class="number">1</span>) &#123;</span><br><span class="line">        last = n / (n / i);</span><br><span class="line">        res -= (last - (i - <span class="number">1</span>) + P) % P * S(n / i) % P;</span><br><span class="line">        res = (res % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[n] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll x, ll y, ll P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * y - (ll)(x / (<span class="keyword">long</span> <span class="keyword">double</span>)P * y + <span class="number">1e-3</span>) * P + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a, ll b, ll P)</span> </span>&#123;</span><br><span class="line">    ll t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = mul(a, a, P))</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) t = mul(t, a, P);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll x, <span class="keyword">int</span> k, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> (rk - <span class="number">1</span> + P) % P;</span><br><span class="line">    ll res = (x * x % P - powmod(x, k + <span class="number">1</span>, P) + P) % P;</span><br><span class="line">    res = res * powmod((<span class="number">1</span> - x + P) % P, P - <span class="number">2</span>, P) % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last; i &lt;= n; i = last + <span class="number">1</span>) &#123;</span><br><span class="line">        last = n / (n / i);</span><br><span class="line">        res += (S(last) - S(i - <span class="number">1</span>) + P) % P * cal(n / i, k, rk) % P;</span><br><span class="line">        res %= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = phi(P);</span><br><span class="line">    inv6 = powmod(<span class="number">6</span>, P - <span class="number">2</span>, P);</span><br><span class="line">    sieve();</span><br><span class="line">    <span class="keyword">int</span> T, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        ll k = <span class="number">0</span>, rk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            rk = mul(rk, <span class="number">10</span>, P);</span><br><span class="line">            rk = (rk + s[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line">            k = mul(k, <span class="number">10</span>, mod);</span><br><span class="line">            k = (k + s[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, solve(n, k, rk));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
            <tag> 数值分块 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 欧拉降幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gym 102201I Increasing Sequence [树上倍增+支配树]</title>
      <link href="2019/08/28/GYM102201I/"/>
      <url>2019/08/28/GYM102201I/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定一个排列，对于每个位置$i$，求出除这个位置之外有多少个位置$j$，如果删去$j$位置上的数会使得包含位置$i$的$LIS$变短</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们对排列求一遍$LIS$，在过程中对每个长度的$LIS$保存结束位置，则其位置上数字的大小单调递减</p><p>对于位置$i$来说，若其$LIS$长度为$len$，一定是从$LIS$长度为$len-1$且数值小于$a_i$的位置转移过来的</p><p>我们将$LIS$转移对应的两端点连边，构成一张拓扑图，那么求$i$位置前面有哪些数字删除会导致包含位置$i$的$LIS$变短，就等价于求这张拓扑图的支配树上$i$节点的深度</p><p>我们正反做两遍$LIS$，将对应支配树深度相加就是答案</p><p>支配树的构造可以在$LIS$的同时完成，所有长度为$len-1$的小于$a_i$的点$LCA$向$i$点连边即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], c[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; N) c[x] = max(c[x], y), x += x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) s = max(s, c[x]), x -= x &amp; -x;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">18</span>], d[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = v[x].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[v[x][mid]] &gt; y)</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x ^ y) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">        x = f[x][<span class="number">0</span>], y = f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LIS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prv = qry(a[i]);</span><br><span class="line">        v[prv + <span class="number">1</span>].push_back(i);</span><br><span class="line">        upd(a[i], prv + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> pos = find(prv, a[i]);</span><br><span class="line">        <span class="keyword">int</span> fx = lca(v[prv][pos], v[prv].back());</span><br><span class="line">        f[i][<span class="number">0</span>] = fx;</span><br><span class="line">        d[i] = d[fx] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">18</span>; j++) f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    v[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">    LIS(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans[i] += d[i] - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    reverse(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = n + <span class="number">1</span> - a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) v[i].clear(); </span><br><span class="line">LIS();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i] + d[n + <span class="number">1</span> - i] - <span class="number">1</span>, <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上倍增 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 支配树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出现次数大于集合大小一半的数字</title>
      <link href="2019/08/28/HALF/"/>
      <url>2019/08/28/HALF/</url>
      
        <content type="html"><![CDATA[<h2 id="集合版本"><a href="#集合版本" class="headerlink" title="集合版本"></a>集合版本</h2><p>给定一个集合，问出现次数大于一半的数字</p><h3 id="权值数组统计"><a href="#权值数组统计" class="headerlink" title="权值数组统计"></a>权值数组统计</h3><p>权值数组计数，upd后超过一半即为答案</p><h2 id="区间版本"><a href="#区间版本" class="headerlink" title="区间版本"></a>区间版本</h2><p>给一个长度为$n$的序列$a$，$1 \le a_i \le n$</p><p>给定$m$组询问，每次询问一个区间$[l,r]$</p><p>查询是否存在一个数在$[l,r]$中出现的次数大于$\frac{r-l+1}{2}$</p><p>如果存在，输出这个数，否则输出0</p><h3 id="单增莫队"><a href="#单增莫队" class="headerlink" title="单增莫队"></a>单增莫队</h3><p>莫队处理询问</p><p>权值数组计数，保存出现次数最多的点权和次数</p><p>非可加数据，需单增处理</p><p>复杂度$O((m+n)\sqrt{n})$</p><h3 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h3><p>建立可持久化的权值线段树</p><p>对于区间查询，在线段树上二分查询R和L-1版本间的数值差符合要求的位置</p><p>复杂度$O(nlog_2n)$</p><h2 id="树上版本"><a href="#树上版本" class="headerlink" title="树上版本"></a>树上版本</h2><p>给定一棵$n$个点的点权树，点权$c_i \le n$</p><p>$m$组询问，查询一条树链上是否有出现次数大于长度一半的点权值</p><p>有则输出点权，没有则输出$-1$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>构造一个偏序对$(a,w)$</p><p>表示一个集合中可能出现次数最多的元素，以及其权值，初始权值为1</p><p>当两个集合合并时，如果出现次数最多元素相同，则权值相加</p><p>否则权值相减，权值大的减去权值小的，保留权值大的</p><p>当一个元素在最终集合中出现次数大于一半时，必定能被保留到最后</p><p>用这种方法在树上倍增可以得到可能出现次数大于一半的数字</p><p>用线段树验证该数字在这条树链上的出现次数即可</p><p>因此，对于每个点权需要建立一棵线段树</p><p>动态开点，一个点最多消耗一条链的内存</p><p>空间复杂度$O(nlog_2n)$，时间复杂度$O(nlog_2n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="区间版本-1"><a href="#区间版本-1" class="headerlink" title="区间版本"></a>区间版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询[lx,rx]区间内超过cnt的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = n, mid, x, y;</span><br><span class="line">    x = root[lx - <span class="number">1</span>], y = root[rx];</span><br><span class="line">    <span class="keyword">while</span> (L != R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[y] - v[x] &lt;= cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v[l[y]] - v[l[x]] &gt; cnt)</span><br><span class="line">            R = mid, x = l[x], y = l[y];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v[r[y]] - v[r[x]] &gt; cnt)</span><br><span class="line">            L = mid + <span class="number">1</span>, x = r[x], y = r[y];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树上版本-1"><a href="#树上版本-1" class="headerlink" title="树上版本"></a>树上版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> tot, rt[<span class="number">20</span> * N], v[<span class="number">20</span> * N], ls[<span class="number">20</span> * N], rs[<span class="number">20</span> * N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> p, <span class="keyword">int</span> c, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++tot;</span><br><span class="line">    v[x] += c;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    p &lt;= mid ? upd(ls[x], p, c, l, mid) : upd(rs[x], p, c, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> v[x];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (L &lt;= mid ? qry(ls[x], L, R, l, mid) : <span class="number">0</span>) +</span><br><span class="line">           (mid &lt; R ? qry(rs[x], L, R, mid + <span class="number">1</span>, r) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 2&gt; mx[N][<span class="number">18</span>];</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 2&gt; <span class="keyword">operator</span>+(<span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; a, <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] ^ b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;&#123;a[<span class="number">0</span>], a[<span class="number">1</span>] - b[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;&#123;b[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;&#123;a[<span class="number">0</span>], a[<span class="number">1</span>] + b[<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">18</span>], d[N], st[N], en[N], a[N], dfn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x = <span class="number">1</span>, <span class="keyword">int</span> fx = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fx;</span><br><span class="line">    d[x] = d[fx] + <span class="number">1</span>;</span><br><span class="line">    mx[x][<span class="number">0</span>] = &#123;a[x], <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        mx[x][i] = mx[x][i - <span class="number">1</span>] + mx[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    st[x] = dfn++;</span><br><span class="line">    upd(rt[a[x]], st[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y : G[x])</span><br><span class="line">        <span class="keyword">if</span> (y ^ fx) dfs(y, x);</span><br><span class="line">    en[x] = dfn;</span><br><span class="line">    upd(rt[a[x]], en[x], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">array&lt;int, 2&gt; getmx(int x, int y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 2&gt; res&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> up = [&amp;](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        res = res + mx[x][k];</span><br><span class="line">        x = f[x][k];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (d[f[x][i]] &gt;= d[y]) up(x, i);</span><br><span class="line">    <span class="keyword">if</span> (x ^ y) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (f[x][i] ^ f[y][i]) up(x, i), up(y, i);</span><br><span class="line">        up(x, <span class="number">0</span>), up(y, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;&#123;(res + mx[x][<span class="number">0</span>])[<span class="number">0</span>], x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        G[x].push_back(y);</span><br><span class="line">        G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x, y; q--;) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">auto</span> res = getmx(x, y);</span><br><span class="line">        <span class="keyword">int</span> c = res[<span class="number">0</span>], lca = res[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = qry(rt[c], <span class="number">0</span>, st[x]) + qry(rt[c], <span class="number">0</span>, st[y]) - qry(rt[c], <span class="number">0</span>, st[lca]);</span><br><span class="line">        <span class="keyword">if</span> (f[lca][<span class="number">0</span>]) cnt -= qry(rt[c], <span class="number">0</span>, st[f[lca][<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = d[x] + d[y] - <span class="number">2</span> * d[lca] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt &gt; cnt0 / <span class="number">2</span> ? c : <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树上倍增 </tag>
            
            <tag> 莫队 </tag>
            
            <tag> 可持久化线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6706 huntian oy [杜教筛]</title>
      <link href="2019/08/27/HDU6706/"/>
      <url>2019/08/27/HDU6706/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>求解$\sum ^{n}<em>{i=1}\sum ^{i}</em>{j=1}\gcd ( i^{a}-j^{a} , i^b-j^b)[\gcd(i,j)=1][\gcd(a,b)=1]$</p><p>$1 \le n \le 10^9$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>因为$\gcd(i,j)=1$</p><p>原式等价于$\sum ^{n}<em>{i=1}\sum ^{i}</em>{j=1}i^{\gcd (a,b)}-j^{\gcd (a,b)}[\gcd(i,j)=1][\gcd(a,b)=1]$</p><p>又$\gcd(a,b)=1$</p><p>式子化简为$\sum ^{n}<em>{i=1}\sum ^{i}</em>{j=1}i-j[\gcd(i,j)=1]$</p><p>对称变换得$(\sum ^{n}<em>{i=1}\sum ^{i}</em>{j=1}j[\gcd(i,j)=1])-1$</p><p>$\sum^n_{i=1}i[\gcd(i,n)=1]=\frac{n\ast\varphi(n)+[n=1]}{2}$</p><p>所以原式等价于$\frac{(\sum^{n}_{i=1}i\ast\varphi(i))-1}{2}$</p><p>记$S(n)=\sum^{n}_{i=1}i\ast\varphi(i)，f(n)=n\ast\varphi(n)$</p><p>考虑到狄利克雷卷积$(\varphi \ast I)(n) = id$</p><p>我们对$f$卷上单位函数$id$来消除系数</p><p>$(f \ast id)(n)=\sum_{d|n}f(d) \ast \frac{n}{d}=\sum_{d|n}d \ast \varphi(d) \ast \frac{n}{d}=n \ast \sum_{d|n}\varphi(d)=n^2$</p><p>$\sum_{i=1}^ni^2=\sum_{i=1}^n\sum_{d|i}d \ast \varphi(d)\ast \dfrac{i}{d}$</p><p>枚举约数转枚举倍数有 $\sum_{d=1}^n\sum_{d|i}\frac{i}{d}\ast \varphi(\frac{i}{d}) \ast d$</p><p>提取$d$之后发现我们可以得到原函数</p><p>$\sum_{d=1}^nd\sum_{d|i}\dfrac{i}{d} \ast \varphi(\frac{i}{d})=\sum_{d=1}^ndS(\lfloor \dfrac{n}{d} \rfloor)$</p><p>则有$S(n)=\sum_{i=1}^ni^2-\sum_{i=2}^niS(\lfloor \frac{n}{i} \rfloor)$</p><p>预处理$S$的$n^{\frac{2}{3}}$项，递归数值分块计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> notp[N];</span><br><span class="line"><span class="keyword">int</span> prime[N], pnum;</span><br><span class="line">ll phi[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(notp, <span class="number">0</span>, <span class="keyword">sizeof</span>(notp));</span><br><span class="line">    notp[<span class="number">0</span>] = notp[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    pnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notp[i]) &#123;</span><br><span class="line">            prime[++pnum] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pnum &amp;&amp; prime[j] * i &lt; N; j++) &#123;</span><br><span class="line">            notp[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> inv(m % a, m) * (m - m / a) % m;</span><br><span class="line">&#125;</span><br><span class="line">ll inv6, inv2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) phi[i] = (<span class="number">1l</span>l * phi[i] * i + phi[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">ll mp[<span class="number">2</span>][N], n;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1l</span>l * x * (x + <span class="number">1</span>) / <span class="number">2</span>) % MOD; &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;ll, ll&gt; hs;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; N) <span class="keyword">return</span> phi[n];</span><br><span class="line">    <span class="keyword">if</span> (hs[n]) <span class="keyword">return</span> hs[n];</span><br><span class="line">    ll res = (n % MOD) * ((n + <span class="number">1</span>) % MOD) % MOD * ((<span class="number">2</span> * n + <span class="number">1</span>) % MOD) % MOD *</span><br><span class="line">             inv6 % MOD;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, last; i &lt;= n; i = last + <span class="number">1</span>) &#123;</span><br><span class="line">        last = n / (n / i);</span><br><span class="line">        res += MOD - (f(last) - f(i - <span class="number">1</span>) + MOD) % MOD * S(n / i) % MOD;</span><br><span class="line">        res %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hs[n] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(mp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">    init();</span><br><span class="line">    inv6 = inv(<span class="number">6</span>, MOD);</span><br><span class="line">    inv2 = inv(<span class="number">2</span>, MOD);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (S(n) - <span class="number">1</span> + MOD) % MOD * inv2 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
            <tag> 数值分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BZOJ 1483 梦幻布丁 [启发式合并]</title>
      <link href="2019/08/21/BZOJ1483/"/>
      <url>2019/08/21/BZOJ1483/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定$n(n \le 10^6)$个小球，排着一排，每个球都有一种颜色</p><p>现在要求维护两种操作：</p><ol><li> 将所有颜色为$x$的球变成颜色为$y$的球</li><li> 查询这排小球有多少连续相同的色段</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们维护每种颜色的位置链表</p><p>当发生合并时，将$size$小的链表并入$size$大的链表</p><p>枚举$x$颜色每个位置，暴力染成$y$，如果和左右节点染色后颜色相同则答案发生修改</p><p>并入时$size$翻倍，因此每个点最多并入$log_2n$次，复杂度$O(nlog_2n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> G[N], nxt[N], v[N], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> id[N], c[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> n, m, op, x, y, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (siz[id[x]] &gt; siz[id[y]]) swap(id[x], id[y]);</span><br><span class="line">    x = id[x], y = id[y];</span><br><span class="line">    <span class="keyword">if</span> (!siz[x]) <span class="keyword">return</span>;</span><br><span class="line">    siz[y] += siz[x]; siz[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = v[i];</span><br><span class="line">        <span class="keyword">if</span> (c[u - <span class="number">1</span>] == y) ans--;</span><br><span class="line">        <span class="keyword">if</span> (c[u + <span class="number">1</span>] == y) ans--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G[x]; i; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = v[i];</span><br><span class="line">        c[u] = y;</span><br><span class="line">        <span class="keyword">if</span> (!nxt[i]) &#123;</span><br><span class="line">            nxt[i] = G[y];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G[y] = G[x], G[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[i - <span class="number">1</span>]) ans--;</span><br><span class="line">        siz[c[i]]++;</span><br><span class="line">        id[c[i]] = c[i];</span><br><span class="line">        v[++cnt] = i;</span><br><span class="line">        nxt[cnt] = G[c[i]];</span><br><span class="line">        G[c[i]] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            merge(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启发式合并 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6597 Game [不平等博弈+三进制状态]</title>
      <link href="2019/08/20/HDU6597/"/>
      <url>2019/08/20/HDU6597/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定一个多个3*3的棋盘格，包含#,.,O和X</p><p>Alice和Bob轮流对这些棋盘格做操作，当一方不能操作了算输</p><p>Alice每次可以选择一个O，将其变成#</p><p>同时，对以下三种事件挑选一种发生：[不能不选]</p><ol><li><p>选择的格子上下格子均变成#</p></li><li><p>选择的格子左右格子均变成#</p></li><li><p>上述两种事件同时发生</p></li></ol><p>Bob每次可以选择一个X，将其变成#，没有任何伴随事件</p><p>如果Alice或者Bob始终能赢则对应输出Alice和Bob</p><p>否则如果先手或者后手始终能赢则对应输出First和Second</p><p>否则直接输出Others</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$SN={Alice \ can \ get|Bob \ can \ get}$</p><p>非平等博弈只存在三种情况：</p><ol><li> $SN&gt;0$：Alice总能够取胜</li><li> $SN&lt;0$：Bob总能取胜</li><li> $SN==0$：后手总能取胜</li></ol><p>我们对$3*3$棋盘进行三进制状压</p><p>暴力预处理出每种状态下的$SN$，$Multi-SN$情况将$SN$相加判断即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> red(i, n) for (int i = n - 1; ~i; i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">27</span> * <span class="number">27</span> * <span class="number">27</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    S() &#123;&#125;</span><br><span class="line">    S(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> S &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x == b.x &amp;&amp; y == b.y; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x * b.y &lt; y * b.x; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> S &amp;b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> &lt; b || *<span class="keyword">this</span> == b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">S INF(0, -1), SN[N];</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">9</span>], nst[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">auto</span> msk = [&amp;]() &#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    red(i, <span class="number">9</span>) t = t * <span class="number">3</span> + nst[i];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> getmid = [&amp;](S &amp;a, S &amp;b) &#123;</span><br><span class="line">    ll down = max(a.y, b.y);</span><br><span class="line">    ll up = a.x * (down / a.y) + b.x * (down / b.y);</span><br><span class="line">    down &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (up % <span class="number">2</span> == <span class="number">0</span>) up /= <span class="number">2</span>, down /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> S(up, down);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Decode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rep(i, <span class="number">9</span>) st[i] = x % <span class="number">3</span>, x /= <span class="number">3</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rep(i, N) &#123;</span><br><span class="line">        S L = INF, R = INF;</span><br><span class="line">        Decode(i);</span><br><span class="line">        <span class="keyword">auto</span> updL = [&amp;]() &#123;</span><br><span class="line">            S s = SN[msk()];</span><br><span class="line">            <span class="keyword">if</span> (L == INF || L &lt; s) L = s;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> updR = [&amp;]() &#123;</span><br><span class="line">            S s = SN[msk()];</span><br><span class="line">            <span class="keyword">if</span> (R == INF || s &lt; R) R = s;</span><br><span class="line">        &#125;;</span><br><span class="line">        rep(j, <span class="number">9</span>) <span class="keyword">if</span> (st[j] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j / <span class="number">3</span>, y = j % <span class="number">3</span>;</span><br><span class="line">            rep(k, <span class="number">9</span>) nst[k] = st[k];</span><br><span class="line">            nst[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x) nst[j - <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">2</span>) nst[j + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            updL();</span><br><span class="line">            <span class="keyword">if</span> (y) nst[j - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">2</span>) nst[j + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            updL();</span><br><span class="line">            <span class="keyword">if</span> (x) nst[j - <span class="number">3</span>] = st[j - <span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">2</span>) nst[j + <span class="number">3</span>] = st[j + <span class="number">3</span>];</span><br><span class="line">            updL();</span><br><span class="line">        &#125;</span><br><span class="line">        rep(j, <span class="number">9</span>) <span class="keyword">if</span> (st[j] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j / <span class="number">3</span>, y = j % <span class="number">3</span>;</span><br><span class="line">            rep(k, <span class="number">9</span>) nst[k] = st[k];</span><br><span class="line">            nst[j] = <span class="number">0</span>;</span><br><span class="line">            updR();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L == INF &amp;&amp; R == INF)</span><br><span class="line">            SN[i] = S(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (L == INF)</span><br><span class="line">            SN[i] = S(R.x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R == INF)</span><br><span class="line">            SN[i] = S(L.x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(L &lt; R);</span><br><span class="line">            S l = INF, r = INF, x(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (R &lt;= x || x &lt;= L) &#123;</span><br><span class="line">                <span class="keyword">if</span> (R &lt;= x) &#123;</span><br><span class="line">                    r = x;</span><br><span class="line">                    <span class="keyword">if</span> (l == INF)</span><br><span class="line">                        x.x--;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        x = getmid(l, r);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = x;</span><br><span class="line">                    <span class="keyword">if</span> (r == INF)</span><br><span class="line">                        x.x++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        x = getmid(l, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SN[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sn = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="built_in">string</span> b;</span><br><span class="line">            rep(i, <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">                rep(j, <span class="number">3</span>) b += s[j &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> msk = <span class="number">0</span>;</span><br><span class="line">            red(i, <span class="number">9</span>) msk = msk * <span class="number">3</span> + Tr(b[i]);</span><br><span class="line">            sn += SN[msk].x * (<span class="number">64</span> / SN[msk].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sn == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sn &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不平等博弈 </tag>
            
            <tag> 三进制状压 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2931 Procrastination [不平等博弈]</title>
      <link href="2019/08/20/POJ2931/"/>
      <url>2019/08/20/POJ2931/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>游戏开始有四座塔，每座均由正方体叠成，所有正方体是黑色或者白色</p><p>玩家$L$和$R$轮流操作，每次选定一个正方体，将正方体及其以上正方体全部拿走</p><p>$L$玩家只能选择白色正方体，$R$玩家只能选择黑色正方体，不能操作者输</p><p>如果$L$玩家无论先手或者后手都能赢，则称局面为$W-configuration$</p><p>定义子局面为三塔局面即为$C$，对于完整局面$(C,T)$</p><p>如果对于任意塔$T$，$(C2,T)$为$W-configuration$时，$(C1,T)$均为$W-configuration$</p><p>则称$C1$不劣于$C2$，给定$C1$和$C2$，判断$C1$是否不劣于$C2$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑一座塔的SN值，当塔为空时$SN={|}=0$</p><p>如果塔包含一个白色正方体，则玩家L拥有可转移到$0$的决策，$SN={0|}=1$</p><p>如果塔包含n个白色正方体，则$SN={0,1,…,n-1|}=n$</p><p>同理塔包含n个黑色正方体时$SN=-n$</p><p>当塔包含n个白色正方体和顶端一个黑色正方体时，$SN={0,1,…,n-1|n}={n-1|n}=n-\frac{1}{2}$</p><p>如果包含n个白色正方体和顶端两个黑色正方体时，$SN={n-1|n-\frac{1}{2}}=n-\frac{1}{2}-\frac{1}{4}$</p><p>在以上情况下在顶端再堆叠一个白色正方体，$SN={n-\frac{1}{2}-\frac{1}{4}|n-\frac{1}{2}}=n-\frac{1}{2}-\frac{1}{4}+\frac{1}{8}$</p><p>结论就比较显然了，除去最底端的连续块，黑色方块$-\frac{1}{2^i}$，白色方块$+\frac{1}{2^i}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSN</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> SN = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n &amp;&amp; T[i] == T[<span class="number">0</span>]; i++) SN += T[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> k = <span class="number">2</span>; i &lt; n; i++, k = k * <span class="number">2</span>) SN += T[i] / k;</span><br><span class="line">    <span class="keyword">return</span> SN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> T[N], d[<span class="number">3</span>], Cas;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Cas);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cas = <span class="number">1</span>; cas &lt;= Cas; cas++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">        <span class="keyword">double</span> SN1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d[i]; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">                T[j] = <span class="number">2</span> * (s[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SN1 += getSN(T, d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">        <span class="keyword">double</span> SN2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d[i]; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">                T[j] = <span class="number">2</span> * (s[<span class="number">0</span>] == <span class="string">&#x27;W&#x27;</span>) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SN2 += getSN(T, d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SN1 &gt;= SN2)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Test %d: Yes\n&quot;</span>, cas);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Test %d: No\n&quot;</span>, cas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不平等博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019NowCoder 8E Explorer [线段树分治+并查集]</title>
      <link href="2019/08/20/2019NOWCODER8E/"/>
      <url>2019/08/20/2019NOWCODER8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>有$10^9$只小怪兽，第$i$只编号为$i$</p><p>有一张$n$个点，$m$条边的无向图$(n,m \le 10^5)$</p><p>每条边只允许编号在$[l,r]$之间的小怪兽通过</p><p>问有多少小怪兽可以从$1$点抵达$n$点</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>我们对边标号区间$[l,r]$进行离散，最多产生$2*m-1$个区间，左闭右开处理</p><p>对区间进行时间分治，在线段树节点上保存覆盖子树所有区间的边$id$</p><p>对线段树DFS遍历，当$1$和$n$连通时将节点包含的编号统计入答案即可</p><p>连通性判断用可回溯并查集，复杂度$O(mlog_2m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Union Find Set</span></span><br><span class="line"><span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>], top, f[N], d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i, d[i] = <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? x : sf(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; top != tag; top--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[top] &lt; <span class="number">0</span>)</span><br><span class="line">            d[-st[top]]--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[st[top]] = st[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &gt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">if</span> (d[x] == d[y]) d[y]++, st[++top] = -y;</span><br><span class="line">    f[x] = y;</span><br><span class="line">    st[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Edge</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, l, r;</span><br><span class="line">&#125; E[N];</span><br><span class="line"><span class="comment">// Segment Tree</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (E[y].l &lt;= l &amp;&amp; r &lt;= E[y].r) &#123;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (E[y].l &lt; mid) upd(x &lt;&lt; <span class="number">1</span>, l, mid, y);</span><br><span class="line">    <span class="keyword">if</span> (E[y].r &gt; mid) upd(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, r, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b[N &lt;&lt; <span class="number">2</span>], x, y, l, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, t = top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = sf(E[y].x), fy = sf(E[y].y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) Union(fx, fy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sf(<span class="number">1</span>) == sf(n)) &#123;</span><br><span class="line">        ans += b[r] - b[l];</span><br><span class="line">        back(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">        back(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    dfs(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, r);</span><br><span class="line">    back(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;l, &amp;r);</span><br><span class="line">        E[i] = &#123;x, y, l, r + <span class="number">1</span>&#125;;</span><br><span class="line">        b[++cnt] = l;</span><br><span class="line">        b[++cnt] = r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> siz = unique(b + <span class="number">1</span>, b + cnt + <span class="number">1</span>) - (b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        E[i].l = lower_bound(b + <span class="number">1</span>, b + siz + <span class="number">1</span>, E[i].l) - b;</span><br><span class="line">        E[i].r = lower_bound(b + <span class="number">1</span>, b + siz + <span class="number">1</span>, E[i].r) - b;</span><br><span class="line">        upd(<span class="number">1</span>, <span class="number">1</span>, siz, i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>, siz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树分治 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 938 G Shortest Path Queries [线段树分治+并查集+线性基]</title>
      <link href="2019/08/19/CF938G/"/>
      <url>2019/08/19/CF938G/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定一张无向边权图，要求维护三个操作</p><p>OP1.$[x,y,z]$:在点$x$和点$y$之间加一条边权为z的边，保证之前没有边</p><p>OP2.$[x,y]$:将点$x$和$y$之间的边删除，保证之前有边</p><p>OP3.$[x,y]$:查询$x$到$y$的路径的异或最小值，可以是非简单路</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>图上两点异或路径的最小值为生成树上异或距离和树上环的组合</p><p>我们以OP3为时间线建线段树，将覆盖操作时间点的边保存在线段树节点</p><p>对OP3的线段树进行DFS遍历，用并查集维护两点间的$xor$距离</p><p>当成环时将环加入$xor$线性基，在叶节点查询$xor$线性基和$xor$距离组合的最小值即可</p><p>线性基空间$O(30)$可以选择直接传参，并查集空间$O(n)$需回溯</p><p>时间复杂度$O(mlog_2t)$，$t$为OP3的数量，$m$为总边数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> PII = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// Xor Base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">31</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; ~j; --j)</span><br><span class="line">            <span class="keyword">if</span> ((x &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p[j]) &#123;</span><br><span class="line">                    p[j] = x;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x ^= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; ~j; --j) x = min(x, x ^ p[j]);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; S;</span><br><span class="line"><span class="comment">// Union Find Set</span></span><br><span class="line"><span class="keyword">int</span> st[N &lt;&lt; <span class="number">1</span>], top, f[N], val[N], d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i, val[i] = <span class="number">0</span>, d[i] = <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> f[x] == x ? x : sf(f[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x != f[x]; x = f[x]) res ^= val[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; top != tag; top--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[top] &lt; <span class="number">0</span>)</span><br><span class="line">            d[-st[top]]--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[st[top]] = st[top];</span><br><span class="line">            val[st[top]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &gt; d[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">if</span> (d[x] == d[y]) d[y]++, st[++top] = -y;</span><br><span class="line">    f[x] = y;</span><br><span class="line">    val[x] = _val;</span><br><span class="line">    st[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Edge</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w, l, r;</span><br><span class="line">&#125; E[N];</span><br><span class="line"><span class="comment">// Query</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; Q[N];</span><br><span class="line"><span class="comment">// Segment Tree</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> l + r | l != r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (E[y].l &lt;= l &amp;&amp; r &lt;= E[y].r) &#123;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (E[y].l &lt;= mid) upd(l, mid, y);</span><br><span class="line">    <span class="keyword">if</span> (E[y].r &gt; mid) upd(mid + <span class="number">1</span>, r, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Base S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = idx(l, r), t = top, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = sf(E[y].x), fy = sf(E[y].y);</span><br><span class="line">        <span class="keyword">int</span> dx = ask(E[y].x), dy = ask(E[y].y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">            S.ins(dx ^ dy ^ E[y].w);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Union(fx, fy, dx ^ dy ^ E[y].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">int</span> dx = ask(Q[l].x), dy = ask(Q[l].y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S.ask(dx ^ dy));</span><br><span class="line">        back(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l, mid, S);</span><br><span class="line">    dfs(mid + <span class="number">1</span>, r, S);</span><br><span class="line">    back(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;PII, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="keyword">int</span> n, m, x, y, z, q, op, tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">        E[i] = &#123;x, y, z, tot + <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        id[&#123;x, y&#125;] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">            E[++m] = &#123;x, y, z, tot + <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            id[&#123;x, y&#125;] = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">            E[id[&#123;x, y&#125;]].r = tot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            Q[++tot] = &#123;x, y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i].r == <span class="number">-1</span>) E[i].r = tot;</span><br><span class="line">        <span class="keyword">if</span> (E[i].l &lt;= E[i].r) upd(<span class="number">1</span>, tot, i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, tot, S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树分治 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019NowCoder 10F Popping Balloons [枚举+线段树]</title>
      <link href="2019/08/18/2019NOWCODER10F/"/>
      <url>2019/08/18/2019NOWCODER10F/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>给定$n(n \le 10^5)$个点的坐标$(x,y)$</p><p>选择三条距离相邻距离为r的竖线和三条相邻距离为r的横线，使得线上的点数量最多</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑枚举横线的选取，数据结构维护竖线的极值</p><p>我们把相邻为r的三条竖线的值的和保存在第一条竖线上，即可数据结构维护   </p><p>考虑枚举的横线和竖线的重复点部分，我们将枚举的横线上的点删除，修改竖线，统计完加回</p><p>每个点只会被删除三次，因此总复杂度$O(nlog_2n) $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[N];</span><br><span class="line"><span class="keyword">int</span> d[N], T[N &lt;&lt; <span class="number">2</span>], M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    T[M + x] += y;</span><br><span class="line">    <span class="keyword">for</span> (x = (M + x) / <span class="number">2</span>; x; x /= <span class="number">2</span>) T[x] = max(T[x &lt;&lt; <span class="number">1</span>], T[(x &lt;&lt; <span class="number">1</span>) ^ <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, r; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        d[y]++;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) d[i] = d[i] + d[i + r] + d[i + <span class="number">2</span> * r];</span><br><span class="line">    <span class="keyword">for</span> (M = <span class="number">1</span>; M &lt; (L + <span class="number">3</span>); M &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) T[M + i + <span class="number">1</span>] = d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i; i--) T[i] = max(T[i &lt;&lt; <span class="number">1</span>], T[(i &lt;&lt; <span class="number">1</span>) ^ <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y : v[i + j * r]) &#123;</span><br><span class="line">                tans++;</span><br><span class="line">                upd(y + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">1</span> - r &gt; <span class="number">0</span>) upd(y + <span class="number">1</span> - r, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">1</span> - <span class="number">2</span> * r &gt; <span class="number">0</span>) upd(y + <span class="number">1</span> - <span class="number">2</span> * r, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, T[<span class="number">1</span>] + tans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y : v[i + j * r]) &#123;</span><br><span class="line">                tans++;</span><br><span class="line">                upd(y + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">1</span> - r &gt; <span class="number">0</span>) upd(y + <span class="number">1</span> - r, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">1</span> - <span class="number">2</span> * r &gt; <span class="number">0</span>) upd(y + <span class="number">1</span> - <span class="number">2</span> * r, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6653 Halt Hater [构造]</title>
      <link href="2019/08/18/HDU6653/"/>
      <url>2019/08/18/HDU6653/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>你位于$(0,-1)$到$(0,0)$的路上，每到一个整点，你可以选择左右转或者直行，右转不产生代价，左转的代价为$a$，直行的代价为$b$，求抵达目标点$(x,y)$的最小代价</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑到右转不花费代价，我们将每四条边缩点，以方格中心为点重构图 </p><p>在新图中，直行代价为$b$，斜行代价为$a$，先求出通过斜行或者直行走到一条直线上的最小代价，然后求解一条直线的最小代价即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function">ll <span class="title">Calc</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) swap(x, y);</span><br><span class="line">    ll res = x * min(a, <span class="number">2</span> * b);</span><br><span class="line">    y -= x;</span><br><span class="line">    res += (y / <span class="number">2</span>) * <span class="number">2</span> * min(a, b);</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res += b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> T, x, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;x, &amp;y);</span><br><span class="line">        ll ans = Calc(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y));</span><br><span class="line">        ans = min(ans, Calc(<span class="built_in">abs</span>(x - <span class="number">1</span>), <span class="built_in">abs</span>(y + <span class="number">1</span>)));</span><br><span class="line">        ans = min(ans, Calc(<span class="built_in">abs</span>(x - <span class="number">1</span>), <span class="built_in">abs</span>(y)));</span><br><span class="line">        ans = min(ans, Calc(<span class="built_in">abs</span>(x), <span class="built_in">abs</span>(y + <span class="number">1</span>)));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ✨题解杂货铺 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
